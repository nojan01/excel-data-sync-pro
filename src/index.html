<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self';">
    <title>Excel Data Sync Pro</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='bg' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%232e8b57'/%3E%3Cstop offset='100%25' stop-color='%231e7145'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' rx='12' fill='url(%23bg)'/%3E%3Crect x='18' y='20' width='16' height='60' rx='3' fill='white'/%3E%3Crect x='42' y='32' width='16' height='48' rx='3' fill='white'/%3E%3Crect x='66' y='44' width='16' height='36' rx='3' fill='white'/%3E%3Ccircle cx='78' cy='22' r='12' fill='rgba(255,255,255,0.3)'/%3E%3Cpath d='M72 25 A7 7 0 1 1 81 18' fill='none' stroke='white' stroke-width='2.5' stroke-linecap='round'/%3E%3Cpolygon points='83 14 83 22 77 18' fill='white'/%3E%3C/svg%3E">
    <!-- Electron-Modus: Excel wird via Node.js xlsx-populate geladen (erh√§lt Formatierung) -->
    <style>
        :root {
            --primary: #217346;
            --primary-dark: #0d5c35;
            --primary-light: #2e8b57;
            --bg-dark: #1e1e1e;
            --bg-medium: #252526;
            --bg-light: #2d2d30;
            --bg-lighter: #3c3c3c;
            --text: #e0e0e0;
            --text-muted: #888;
            --border: #404040;
            --success: #4caf50;
            --warning: #ff9800;
            --error: #f44336;
            --info: #2196f3;
        }
        
        /* Gr√ºne Checkboxen */
        .green-checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--primary);
        }
        
        /* Light Theme */
        body.light-theme {
            --bg-dark: #f5f5f5;
            --bg-medium: #ffffff;
            --bg-light: #e8e8e8;
            --bg-lighter: #d0d0d0;
            --text: #1e1e1e;
            --text-muted: #666666;
            --border: #cccccc;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        .header {
            background: var(--bg-medium);
            border-bottom: 1px solid var(--border);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            font-weight: 600;
            color: var(--primary-light);
        }
        
        .logo-icon {
            width: 32px;
            height: 32px;
            background: var(--primary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
        }
        
        .header-actions {
            margin-left: auto;
            display: flex;
            gap: 10px;
        }
        
        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            background: var(--bg-lighter, #3c3c3c);
            color: var(--text, #e0e0e0);
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--primary-light);
        }
        
        .btn-warning {
            background: var(--warning);
            color: #1e1e1e;
        }
        
        .btn-warning:hover {
            background: #ffa726;
        }
        
        .btn-info {
            background: #9c27b0;
            color: white;
        }
        
        .btn-info:hover {
            background: #ab47bc;
        }
        
        .btn-unsaved {
            animation: pulse-save 1.5s infinite;
            box-shadow: 0 0 10px rgba(66, 165, 245, 0.5);
        }
        
        @keyframes pulse-save {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .btn-secondary {
            background: var(--bg-lighter);
            color: var(--text);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            background: var(--border);
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        .btn-success:hover {
            background: #66bb6a;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Main Layout */
        .main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        /* Sidebar - Konfiguration */
        .sidebar {
            width: 320px;
            background: var(--bg-medium);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: width 0.3s ease, min-width 0.3s ease;
        }
        
        .sidebar.collapsed {
            width: 48px;
            min-width: 48px;
        }
        
        .sidebar.collapsed .sidebar-content {
            display: none;
        }
        
        .sidebar.collapsed .sidebar-header-text {
            display: none;
        }
        
        .sidebar.collapsed .sidebar-toggle {
            transform: rotate(180deg);
        }
        
        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
            min-height: 52px;
        }
        
        .sidebar-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            overflow: hidden;
        }
        
        .sidebar-toggle {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 6px;
            border-radius: 4px;
            transition: background 0.2s, transform 0.3s;
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .sidebar-toggle:hover {
            background: var(--bg-lighter);
            color: var(--text-primary);
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .config-section {
            margin-bottom: 20px;
        }
        
        .config-section-title {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }
        
        .config-group {
            background: var(--bg-light);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }
        
        .config-label {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 6px;
            display: block;
        }
        
        .config-select, .config-input {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 14px;
        }
        
        .config-select:focus, .config-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .file-info {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 6px;
            word-break: break-all;
        }
        
        .file-info.loaded {
            color: var(--success);
        }
        
        /* Content Area */
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Search Section */
        .search-section {
            padding: 20px;
            background: var(--bg-medium);
            border-bottom: 1px solid var(--border);
        }
        
        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .search-input {
            flex: 1;
            padding: 14px 18px;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 17px;
            min-height: 48px;
            min-width: 500px;
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .search-input::placeholder {
            color: var(--text-muted);
        }
        
        /* Such-Historie Dropdown */
        .search-wrapper {
            position: relative;
            flex: 1;
        }
        
        .search-history-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-medium);
            border: 1px solid var(--border);
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
        }
        
        .search-history-dropdown.show {
            display: block;
        }
        
        .search-history-item {
            padding: 10px 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
        }
        
        .search-history-item:last-child {
            border-bottom: none;
        }
        
        .search-history-item:hover {
            background: var(--bg-light);
        }
        
        .search-history-item.selected {
            background: var(--bg-lighter);
        }
        
        .search-history-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .search-history-count {
            font-size: 11px;
            color: var(--text-muted);
            margin-left: 10px;
        }
        
        .search-history-delete {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 2px 6px;
            margin-left: 8px;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .search-history-delete:hover {
            color: var(--error);
            background: rgba(244, 67, 54, 0.1);
        }
        
        .search-history-header {
            padding: 8px 14px;
            font-size: 11px;
            text-transform: uppercase;
            color: var(--text-muted);
            background: var(--bg-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .search-history-clear {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 11px;
        }
        
        .search-history-clear:hover {
            color: var(--error);
        }
        
        .search-results-info {
            font-size: 14px;
            color: var(--text-muted);
        }
        
        .search-results-info strong {
            color: var(--primary-light);
        }
        
        /* Results Table */
        .results-section {
            flex: 1 1 0;
            min-height: 0;
            max-height: 30vh;
            overflow: hidden;
            padding: 10px 20px;
            display: flex;
            flex-direction: column;
        }
        
        .results-table-container {
            flex: 1 1 0;
            min-height: 80px;
            overflow: auto;
            background: var(--bg-medium);
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .results-table th,
        .results-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
        }
        
        .results-table th {
            background: var(--bg-light);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        /* Sortierbare Header */
        .sortable-header {
            cursor: grab;
            user-select: none;
            transition: background 0.15s, opacity 0.15s;
        }
        
        .sortable-header:hover {
            background: var(--bg-lighter);
        }
        
        .sortable-header.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .sortable-header.drag-over {
            background: var(--primary);
            color: white;
        }
        
        /* Zellen-Auswahl */
        .cell-selected {
            background: rgba(33, 150, 243, 0.3) !important;
            outline: 2px solid var(--primary) !important;
            outline-offset: -2px;
        }
        
        .cell-selection-anchor {
            background: rgba(33, 150, 243, 0.4) !important;
        }
        
        /* Zeilen-Highlighting */
        .row-highlight-green { background: rgba(76, 175, 80, 0.2) !important; }
        .row-highlight-yellow { background: rgba(255, 235, 59, 0.25) !important; }
        .row-highlight-orange { background: rgba(255, 152, 0, 0.25) !important; }
        .row-highlight-red { background: rgba(244, 67, 54, 0.2) !important; }
        .row-highlight-blue { background: rgba(33, 150, 243, 0.2) !important; }
        .row-highlight-purple { background: rgba(156, 39, 176, 0.2) !important; }
        
        /* Kontextmen√º */
        .context-menu {
            position: fixed;
            background: var(--bg-medium);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 4px 0;
            min-width: 180px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
        }
        
        .context-menu-item:hover {
            background: var(--bg-light);
        }
        
        .context-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }
        
        .color-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        /* Diff/Preview Tabelle */
        .diff-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .diff-table th,
        .diff-table td {
            padding: 8px 10px;
            text-align: left;
            border: 1px solid var(--border);
            white-space: nowrap;
        }
        
        .diff-table th {
            background: var(--bg-light);
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        .diff-row-add {
            background: rgba(76, 175, 80, 0.15);
        }
        
        .diff-row-delete {
            background: rgba(244, 67, 54, 0.15);
        }
        
        .diff-row-change {
            background: rgba(255, 152, 0, 0.15);
        }
        
        .diff-row-empty {
            background: var(--bg-light);
            font-style: italic;
            color: var(--text-muted);
        }
        
        .diff-flag {
            font-weight: 700;
            text-align: center;
            min-width: 30px;
        }
        
        .diff-flag-A { color: #4CAF50; }
        .diff-flag-D { color: #F44336; }
        .diff-flag-C { color: #FF9800; }
        
        .results-table tr:hover {
            background: var(--bg-light);
        }
        
        .results-table tr.selected {
            background: rgba(33, 115, 70, 0.3);
        }
        
        .results-table td[contenteditable="true"] {
            cursor: text;
            min-width: 50px;
        }
        
        .results-table td[contenteditable="true"]:focus {
            outline: 2px solid var(--primary);
            outline-offset: -2px;
            background: var(--bg-darker);
        }
        
        .results-table td.edited {
            background: rgba(255, 193, 7, 0.2);
            border-left: 3px solid var(--warning);
        }
        
        .results-table td[contenteditable]:focus {
            outline: 2px solid var(--primary);
            outline-offset: -2px;
            background: rgba(0, 123, 255, 0.1);
        }
        
        .results-table tr.editing-row {
            background: rgba(0, 123, 255, 0.05);
        }
        
        /* Row Selection Styles */
        .results-table tr.row-selected {
            background: rgba(33, 115, 70, 0.1) !important;
        }
        
        .results-table tr.row-selected:hover {
            background: rgba(33, 115, 70, 0.15) !important;
        }
        
        .row-select-checkbox {
            cursor: pointer;
            accent-color: var(--primary);
            width: 16px;
            height: 16px;
        }
        
        .row-checkbox-cell {
            text-align: center;
            padding: 8px;
            background: var(--bg-medium) !important;
            border-right: 1px solid var(--border);
        }
        
        .row-checkbox-cell.selected {
            background: rgba(33, 115, 70, 0.3) !important;
        }
        
        .row-select {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .highlight {
            background: var(--warning);
            color: black;
            padding: 1px 2px;
            border-radius: 2px;
        }
        
        /* New Row Panel */
        .new-row-panel {
            background: var(--bg-medium);
            border: 2px solid var(--success);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .new-row-panel.hidden {
            display: none;
        }
        
        .new-row-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .new-row-title {
            font-weight: 600;
            font-size: 16px;
            color: var(--success);
        }
        
        .new-row-form {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
            padding: 15px;
            background: var(--bg-dark);
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        
        .new-row-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .new-row-field label {
            font-size: 12px;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .new-row-field input {
            padding: 8px 10px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 13px;
        }
        
        .new-row-field input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .new-row-actions {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        /* Transfer Panel */
        .transfer-panel {
            background: var(--bg-medium);
            border-top: 1px solid var(--border);
            padding: 20px;
        }
        
        .transfer-panel.hidden {
            display: none;
        }
        
        .transfer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .transfer-title {
            font-weight: 600;
            font-size: 16px;
        }
        
        .transfer-form {
            display: flex;
            gap: 20px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        
        .transfer-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .transfer-field label {
            font-size: 13px;
            color: var(--text-muted);
        }
        
        .transfer-field select,
        .transfer-field input {
            padding: 10px 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 14px;
            min-width: 150px;
        }
        
        .transfer-field select:focus,
        .transfer-field input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .transfer-field input[type="text"] {
            min-width: 250px;
        }
        
        /* Status Messages */
        .status {
            padding: 10px 15px;
            border-radius: 4px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid var(--success);
            color: var(--success);
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid var(--error);
            color: var(--error);
        }
        
        .status.info {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid var(--info);
            color: var(--info);
        }
        
        /* Empty State */
        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            color: var(--text-muted);
            padding: 20px 40px;
            text-align: center;
        }
        
        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }
        
        .empty-state-title {
            font-size: 20px;
            margin-bottom: 10px;
            color: var(--text);
        }
        
        .empty-state-text {
            max-width: 400px;
            line-height: 1.6;
        }
        
        /* Column Mapping Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            overflow: hidden;
        }
        
        .modal-overlay.hidden {
            display: none;
        }
        
        .modal {
            background: var(--bg-medium);
            border-radius: 8px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            resize: both;
            overflow: hidden;
            min-width: 400px;
            min-height: 300px;
        }
        
        .modal.modal-large {
            resize: both;
            overflow: hidden;
        }
        
        /* Verhindert Scroll-Durchgang bei offenen Modals */
        body.modal-open {
            overflow: hidden;
        }
        
        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .modal-close:hover {
            color: var(--text);
        }
        
        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }
        
        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        /* Mapping List Styles */
        .mapping-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .mapping-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-light);
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        
        .mapping-item select {
            flex: 1;
            padding: 8px 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 14px;
            min-width: 150px;
        }
        
        .mapping-item select:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .mapping-arrow {
            color: var(--primary-light);
            font-size: 18px;
            font-weight: bold;
            padding: 0 5px;
        }
        
        .mapping-target {
            color: var(--text-muted);
            font-size: 13px;
            min-width: 150px;
        }
        
        .mapping-remove {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .mapping-remove:hover {
            background: var(--error);
            border-color: var(--error);
            color: white;
        }
        
        /* Column Visibility Control */
        .column-toggle-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 8px;
            padding: 15px;
            background: var(--bg-light);
            border-radius: 6px;
            margin-bottom: 10px;
            min-height: 80px;
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid var(--border);
        }
        
        .column-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .column-toggle:hover {
            border-color: var(--primary);
        }
        
        .column-toggle.hidden-col {
            opacity: 0.5;
            background: var(--bg-lighter);
        }
        
        .column-toggle input {
            cursor: pointer;
        }
        
        .column-toggle label {
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }
        
        /* Transfer History */
        .history-section {
            margin-top: 20px;
        }
        
        .history-list {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-light);
            border-radius: 6px;
            padding: 10px;
        }
        
        .history-item {
            font-size: 12px;
            padding: 6px 8px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }
        
        .history-item:last-child {
            border-bottom: none;
        }
        
        .history-time {
            color: var(--text-muted);
            font-size: 11px;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="logo">
            <div class="logo-icon" style="font-size: 16px; line-height: 1.2;">üìä</div>
            <span>Excel Data Sync Pro</span>
        </div>
        <div class="header-actions">
            <button class="btn btn-primary" id="btnImportConfig" title="Gemeinsame config.json aus Programmordner laden">
                üìÇ config.json laden
            </button>
            <button class="btn btn-primary" id="btnExportConfig" title="Konfiguration als config.json speichern">
                üíæ config.json speichern
            </button>
            <button class="btn btn-secondary" id="btnHelp" title="Hilfe (F1)">
                ‚ùì Hilfe
            </button>
        </div>
    </header>
    
    <main class="main">
        <!-- Sidebar - Konfiguration -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-header-left">
                    <span>‚öôÔ∏è</span>
                    <span class="sidebar-header-text">Konfiguration</span>
                </div>
                <button class="sidebar-toggle" id="sidebarToggle" title="Sidebar ein-/ausklappen">‚óÄ</button>
            </div>
            <div class="sidebar-content">
                <!-- Arbeitsordner -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="workingDirectory">üìÅ Arbeitsordner</div>
                    <div class="config-group">
                        <button class="btn btn-primary" id="btnSelectWorkingDir" style="width: 100%; margin-bottom: 10px;" data-i18n="selectWorkingDir">
                            üìÇ Ordner ausw√§hlen
                        </button>
                        <div class="file-info" id="workingDirInfo" data-i18n="noWorkingDirSet" style="word-break: break-all;">Kein Ordner gew√§hlt</div>
                        <button class="btn btn-secondary" id="btnClearWorkingDir" style="width: 100%; margin-top: 8px; display: none;" data-i18n="clearWorkingDir">
                            ‚úñÔ∏è Arbeitsordner l√∂schen
                        </button>
                    </div>
                </div>
                
                <!-- Datei 1 - Quelle -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="file1Source">üìÑ Datei 1 (Quelle)</div>
                    <div class="config-group">
                        <button class="btn btn-primary" id="btnLoadFile1" style="width: 100%; margin-bottom: 10px;" data-i18n="loadSourceFile">
                            üìÇ Quelldatei laden
                        </button>
                        <div class="file-info" id="file1Info" data-i18n="noFileLoaded">Keine Datei geladen</div>
                        
                        <label class="config-label" style="margin-top: 12px;" data-i18n="worksheet">Arbeitsblatt:</label>
                        <select class="config-select" id="selectSheet1" disabled>
                            <option value="" data-i18n="loadFileFirst">-- Erst Datei laden --</option>
                        </select>
                    </div>
                </div>
                
                <!-- Datei 2 - Ziel -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="file2Target">üìÑ Datei 2 (Ziel)</div>
                    <div class="config-group">
                        <button class="btn btn-primary" id="btnLoadFile2" style="width: 100%; margin-bottom: 10px;" data-i18n="loadTargetFile">
                            üìÇ Zieldatei laden
                        </button>
                        <div class="file-info" id="file2Info" data-i18n="noFileLoaded">Keine Datei geladen</div>
                        
                        <label class="config-label" style="margin-top: 12px;" data-i18n="worksheet">Arbeitsblatt:</label>
                        <select class="config-select" id="selectSheet2" disabled>
                            <option value="" data-i18n="loadFileFirst">-- Erst Datei laden --</option>
                        </select>
                    </div>
                </div>
                
                <!-- Spalten-Mapping -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="columnMapping">üîó Spalten-Zuordnung</div>
                    <div class="config-group">
                        <button class="btn btn-primary" id="btnConfigMapping" style="width: 100%;" data-i18n="configureColumns">
                            ‚öôÔ∏è Spalten konfigurieren
                        </button>
                        <div class="file-info" id="mappingInfo" data-i18n="loadBothFiles">Laden Sie beide Dateien</div>
                        <div id="mappingPreview" style="margin-top: 10px; font-size: 12px; color: var(--text-muted);"></div>
                    </div>
                </div>
                
                <!-- Template f√ºr neuen Monat -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="monthTemplate">üìÑ Monats-Template</div>
                    <div class="config-group">
                        <button class="btn btn-success" id="btnNewMonth" disabled style="width: 100%; margin-bottom: 10px;" title="Erstellt neue Monatsdatei aus Template" data-i18n="newMonthFile">
                            üìÖ Neue Monatsdatei
                        </button>
                        <button class="btn btn-primary" id="btnLoadTemplate" style="width: 100%; margin-bottom: 10px;" data-i18n="loadTemplate">
                            üìÇ Template laden
                        </button>
                        <button class="btn btn-secondary" id="btnCreateTemplate" style="width: 100%; margin-bottom: 10px;" data-i18n="createTemplateFromSource" title="Erstellt ein leeres Template aus einer Quelldatei mit allen Formatierungen">
                            üîß Template aus Quelldatei
                        </button>
                        <div class="file-info" id="templateInfo" data-i18n="noTemplateLoaded">Kein Template geladen</div>
                        <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;" data-i18n="templateHint">
                            Leere Excel-Vorlage f√ºr "üìÖ Neue Monatsdatei"
                        </div>
                    </div>
                </div>
                
                <!-- Transfer History -->
                <div class="config-section history-section">
                    <div class="config-section-title" data-i18n="lastTransfers">üìã Letzte √úbertragungen</div>
                    <div class="history-list" id="historyList">
                        <div style="color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px;" data-i18n="noTransfersYet">
                            Noch keine √úbertragungen
                        </div>
                    </div>
                </div>
                
                <!-- Einstellungen: Sprache & Theme (unten) -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="settings">‚öôÔ∏è Einstellungen</div>
                    <div class="config-group" style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 100px;">
                            <label class="config-label" data-i18n="language">Sprache</label>
                            <select class="config-select" id="selectLanguage" style="width: 100%;">
                                <option value="de">üá©üá™ Deutsch</option>
                                <option value="en">üá¨üáß English</option>
                            </select>
                        </div>
                        <div style="flex: 1; min-width: 100px;">
                            <label class="config-label" data-i18n="theme">Design</label>
                            <select class="config-select" id="selectTheme" style="width: 100%;">
                                <option value="dark" data-i18n="themeDark">üåô Dunkel</option>
                                <option value="light" data-i18n="themeLight">‚òÄÔ∏è Hell</option>
                            </select>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-secondary" id="btnLicense" style="width: 100%;">
                            üìú <span data-i18n="license">Lizenz</span>
                        </button>
                    </div>
                </div>
            </div>
        </aside>
        
        <!-- Content -->
        <div class="content">
            <!-- Search Section -->
            <div class="search-section">
                <div class="search-box">
                    <div class="search-wrapper">
                        <input type="text" class="search-input" id="searchInput" 
                               placeholder="Suche... (* ? f√ºr Platzhalter, AND/OR f√ºr Verkn√ºpfung)" disabled autocomplete="off">
                        <div class="search-history-dropdown" id="searchHistoryDropdown"></div>
                    </div>
                    <button class="btn btn-primary" id="btnSearch" disabled>
                        üîç Suchen
                    </button>
                    <button class="btn btn-primary" id="btnNewRow" disabled title="Neue Zeile manuell erstellen">
                        ‚ûï Neue Zeile
                    </button>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <div class="search-results-info" id="searchResultsInfo"></div>
                    
                    <!-- Search Results Pagination -->
                    <div id="searchPagination" style="display: none; align-items: center; gap: 8px;">
                        <button class="btn btn-secondary btn-sm" id="btnSearchFirstPage" title="Erste Seite">‚èÆ</button>
                        <button class="btn btn-secondary btn-sm" id="btnSearchPrevPage" title="Vorherige Seite">‚óÄ</button>
                        <span id="searchPageInfo" style="color: var(--text-muted); font-size: 13px; min-width: 120px; text-align: center;">Seite 1 von 1</span>
                        <button class="btn btn-secondary btn-sm" id="btnSearchNextPage" title="N√§chste Seite">‚ñ∂</button>
                        <button class="btn btn-secondary btn-sm" id="btnSearchLastPage" title="Letzte Seite">‚è≠</button>
                        <select id="searchPageSize" style="padding: 4px 8px; border-radius: 4px; background: var(--bg-light); border: 1px solid var(--border); color: var(--text-primary);">
                            <option value="50">50 / Seite</option>
                            <option value="100" selected>100 / Seite</option>
                            <option value="250">250 / Seite</option>
                            <option value="500">500 / Seite</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- New Row Panel (editierbare Vorlage) -->
            <div class="new-row-panel hidden" id="newRowPanel">
                <div class="new-row-header">
                    <div class="new-row-title">‚úèÔ∏è Neue Zeile erstellen</div>
                    <button class="btn btn-secondary btn-sm" id="btnCloseNewRow">‚úï Schlie√üen</button>
                </div>
                <div class="new-row-form" id="newRowForm">
                    <!-- Wird dynamisch mit den konfigurierten Spalten gef√ºllt -->
                </div>
                <div class="new-row-actions">
                    <div class="transfer-field">
                        <label>Flag:</label>
                        <select id="newRowFlag">
                            <option value="A">A (Add)</option>
                            <option value="D">D (Delete)</option>
                            <option value="C">C (Change)</option>
                            <option value="leer">Leerzeile</option>
                        </select>
                    </div>
                    <div class="transfer-field">
                        <label>Kommentar:</label>
                        <input type="text" id="newRowComment" placeholder="Freier Text...">
                    </div>
                    <button class="btn btn-primary" id="btnAddNewRowToQueue">
                        ‚ûï Zur Warteschlange
                    </button>
                    <button class="btn btn-primary" id="btnTransferNewRowDirect">
                        ‚û°Ô∏è Direkt √ºbertragen
                    </button>
                    <button class="btn btn-secondary" id="btnAddEmptyRow" title="Leere Zeile einf√ºgen (unabh√§ngig von Flag-Spalte)">
                        ‚¨ú Leerzeile
                    </button>
                </div>
                <div id="newRowStatus"></div>
            </div>
            
            <!-- Results -->
            <div class="results-section" id="resultsSection">
                <div class="empty-state" id="emptyState">
                    <div class="empty-state-icon">üìä</div>
                    <div class="empty-state-title">Bereit zum Starten</div>
                    <div class="empty-state-text">
                        1. Laden Sie die Quelldatei (Datei 1)<br>
                        2. Laden Sie die Zieldatei (Datei 2)<br>
                        3. Konfigurieren Sie die Spalten-Zuordnung<br>
                        4. Suchen Sie nach Zeilen und √ºbertragen Sie diese
                    </div>
                </div>
                
                <div class="results-table-container" id="resultsTableContainer" style="display: none;">
                    <table class="results-table" id="resultsTable">
                        <thead id="resultsTableHead"></thead>
                        <tbody id="resultsTableBody"></tbody>
                    </table>
                </div>
            </div>
            
            <!-- Transfer Panel -->
            <div class="transfer-panel hidden" id="transferPanel">
                <div class="transfer-header">
                    <div class="transfer-title">üì§ Zeile(n) zur √úbertragung vorbereiten (<span id="selectedCount">1</span> ausgew√§hlt)</div>
                </div>
                <div class="transfer-form">
                    <div class="transfer-field">
                        <label>Spalte 1 - Flag:</label>
                        <select id="transferFlag">
                            <option value="A">A (Add)</option>
                            <option value="D">D (Delete)</option>
                            <option value="C">C (Change)</option>
                            <option value="leer">Leerzeile</option>
                        </select>
                    </div>
                    <div class="transfer-field">
                        <label>Spalte 2 - Kommentar:</label>
                        <input type="text" id="transferComment" placeholder="Freier Text...">
                    </div>
                    <button class="btn btn-primary" id="btnAddToQueue">
                        ‚ûï Markierte zur Warteschlange
                    </button>
                    <button class="btn btn-primary" id="btnTransferDirect">
                        ‚û°Ô∏è Markierte direkt √ºbertragen
                    </button>
                    <button class="btn btn-primary" id="btnSelectAll" style="margin-left: auto;">
                        ‚òëÔ∏è Alle ausw√§hlen
                    </button>
                    <button class="btn btn-primary" id="btnDeselectAll">
                        ‚òêAlles abw√§hlen
                    </button>
                </div>
                <div id="transferStatus"></div>
            </div>
            
            <!-- Queue Panel -->
            <div class="transfer-panel" id="queuePanel" style="border-top: 2px solid var(--primary);">
                <div class="transfer-header">
                    <div class="transfer-title">üìã Warteschlange (<span id="queueCount">0</span> Zeilen)</div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-primary" id="btnClearQueue" disabled>
                            üóëÔ∏è Leeren
                        </button>
                        <button class="btn btn-secondary" id="btnPreviewTransfer" disabled title="Vorschau der √Ñnderungen anzeigen">
                            üëÅÔ∏è Vorschau
                        </button>
                        <button class="btn btn-primary" id="btnExportPS" disabled title="Exportiert Warteschlange als JSON zur Zieldatei" style="border: 2px solid white; box-shadow: 0 0 4px rgba(255,255,255,0.5);">
                            üì§ Export zur Zieldatei
                        </button>
                        <button class="btn btn-primary" id="btnDataExplorer" disabled title="Datenexplorer - Zieldatei anzeigen und exportieren">
                            Datenexplorer
                        </button>
                    </div>
                </div>
                <div class="queue-list" id="queueList">
                    <div class="queue-empty">Keine Zeilen in der Warteschlange</div>
                </div>
            </div>
        </div>
    </main>
    
    <!-- Footer -->
    <footer style="background: var(--bg-medium); border-top: 1px solid var(--border); padding: 8px 20px; text-align: center; color: var(--text-muted); font-size: 12px;">
        ¬© Norbert Jander 2025 ¬∑ v1.0.10
    </footer>
    
    <!-- Mapping Modal -->
    <div class="modal-overlay hidden" id="mappingModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">üîó Spalten-Zuordnung konfigurieren</div>
                <button class="modal-close" id="btnCloseMappingModal">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: var(--text-muted);">
                    W√§hlen Sie, welche Spalten aus Datei 1 in welche Spalten von Datei 2 kopiert werden sollen.
                </p>
                
                <div class="config-group">
                    <label class="config-label">Start-Spalte in Datei 2 (f√ºr Quelldaten):</label>
                    <div id="targetStartColumnDisplay" style="padding: 8px 12px; background: var(--bg-light); border-radius: 6px; font-weight: bold; color: var(--excel-green);">
                        Spalte C (automatisch berechnet)
                    </div>
                    <div style="font-size: 12px; color: var(--text-muted); margin-top: 6px;">
                        üìå Die Start-Spalte wird automatisch berechnet: Flag + Kommentar Spalten werden vorangestellt.
                    </div>
                </div>
                
                <div class="config-group">
                    <label class="config-label">Duplikat-Pr√ºfung (Spalte aus Datei 1):</label>
                    <select class="config-select" id="duplicateCheckColumn"></select>
                    <div style="font-size: 12px; color: var(--text-muted); margin-top: 6px;">
                        Diese Spalte wird gepr√ºft, ob der Wert bereits in Datei 2 existiert.
                    </div>
                </div>
                
                <div class="config-section-title" style="margin-top: 20px;">Zu kopierende Spalten aus Datei 1:</div>
                <div class="mapping-list" id="mappingList"></div>
                
                <button class="btn btn-primary" id="btnAddMapping" style="margin-top: 10px;">
                    ‚ûï Spalte hinzuf√ºgen
                </button>
                
                <!-- Extra-Spalten Konfiguration -->
                <div class="config-section-title" style="margin-top: 25px; padding-top: 15px; border-top: 1px solid var(--border);">
                    üìù Extra-Spalten (optional)
                </div>
                <p style="margin-bottom: 15px; color: var(--text-muted); font-size: 13px;">
                    Zus√§tzliche Spalten f√ºr Flag-Markierungen und Kommentare. Diese werden separat von den Quelldaten in die Zieldatei geschrieben.
                </p>
                
                <!-- Flag-Spalte -->
                <div class="extra-column-config" style="background: var(--bg-light); padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <input type="checkbox" id="enableFlagColumn" class="green-checkbox">
                        <label style="font-weight: bold; cursor: pointer;" for="enableFlagColumn">üè∑Ô∏è Flag-Spalte</label>
                        <span id="flagColumnDisplay" style="color: var(--text-muted); font-size: 12px; margin-left: auto;">‚Üí Spalte A</span>
                    </div>
                    <div id="flagColumnConfig" style="display: flex; flex-wrap: wrap; gap: 10px; padding-left: 26px;">
                        <div style="flex: 1; min-width: 200px;">
                            <label class="config-label" style="font-size: 12px;">Verf√ºgbare Werte (kommagetrennt):</label>
                            <input type="text" class="search-input" id="flagValues" value="A,D,C,leer" style="font-size: 13px; padding: 6px 10px;" placeholder="z.B. A,D,C,leer">
                        </div>
                    </div>
                </div>
                
                <!-- Kommentar-Spalte -->
                <div class="extra-column-config" style="background: var(--bg-light); padding: 12px; border-radius: 6px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <input type="checkbox" id="enableCommentColumn" class="green-checkbox">
                        <label style="font-weight: bold; cursor: pointer;" for="enableCommentColumn">üí¨ Kommentar-Spalte</label>
                        <span id="commentColumnDisplay" style="color: var(--text-muted); font-size: 12px; margin-left: auto;">‚Üí Spalte B</span>
                    </div>
                    <div id="commentColumnConfig" style="display: flex; flex-wrap: wrap; gap: 10px; padding-left: 26px;">
                        <div style="flex: 1; min-width: 200px;">
                            <label class="config-label" style="font-size: 12px;">Platzhalter-Text:</label>
                            <input type="text" class="search-input" id="commentPlaceholder" value="Freier Text..." style="font-size: 13px; padding: 6px 10px;" placeholder="Platzhalter f√ºr Eingabefeld">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="btnCancelMapping">Abbrechen</button>
                <button class="btn btn-primary" id="btnSaveMapping">üíæ Speichern</button>
            </div>
        </div>
    </div>
    
    <!-- Create Template Modal -->
    <div class="modal-overlay hidden" id="createTemplateModal">
        <div class="modal" style="max-width: 550px; resize: none;">
            <div class="modal-header">
                <div class="modal-title" data-i18n="createTemplateTitle">üîß Template aus Quelldatei erstellen</div>
                <button class="modal-close" id="btnCloseCreateTemplateModal">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: var(--text-muted);" data-i18n="createTemplateDesc">
                    Erstellt ein leeres Template mit allen Formatierungen und bedingten Formatierungen aus der Quelldatei.
                </p>
                <div style="margin-bottom: 15px; padding: 10px; background: var(--bg-dark); border-radius: 6px;">
                    <strong data-i18n="sourceFileLabel">Quelldatei:</strong> <span id="createTemplateSourceName" style="color: var(--text-muted);">-</span>
                </div>
                
                <!-- Extra-Spalten im Template -->
                <div style="margin-bottom: 15px; padding: 12px; background: var(--bg-dark); border-radius: 6px; border: 1px solid var(--border);">
                    <label class="config-label" style="margin-bottom: 10px; display: block;" data-i18n="extraColumnsInTemplate">Extra-Spalten im Template erstellen:</label>
                    <div style="display: flex; gap: 20px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="templateFlagColumn" class="green-checkbox" style="margin-right: 8px;">
                            <span>üè∑Ô∏è <span data-i18n="flagColumn">Flag-Spalte (A)</span></span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="templateCommentColumn" class="green-checkbox" style="margin-right: 8px;">
                            <span>üí¨ <span data-i18n="commentColumn">Kommentar-Spalte (B)</span></span>
                        </label>
                    </div>
                    <p style="font-size: 10px; color: var(--text-muted); margin-top: 8px;" data-i18n="extraColumnsHint">
                        Aktivieren, wenn in "Spalten konfigurieren" die entsprechenden Optionen genutzt werden.
                    </p>
                </div>
                
                <label class="config-label" data-i18n="selectSheets">Arbeitsbl√§tter ausw√§hlen:</label>
                <div id="createTemplateSheetList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 6px; padding: 10px; margin-bottom: 15px; background: var(--bg-dark);">
                    <div style="color: var(--text-muted); text-align: center;" data-i18n="loadSourceFirst">Laden Sie zuerst eine Quelldatei</div>
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="btn btn-secondary" id="btnSelectAllSheets" style="flex: 1;" data-i18n="selectAll">‚úì Alle ausw√§hlen</button>
                    <button class="btn btn-secondary" id="btnDeselectAllSheets" style="flex: 1;" data-i18n="deselectAll">‚úó Alle abw√§hlen</button>
                </div>
                <p style="font-size: 11px; color: var(--text-muted);" data-i18n="templateInfoText">
                    üí° Die Header-Zeile wird behalten, alle Datenzeilen werden gel√∂scht. CF-Regeln werden auf ganze Spalten erweitert.
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="btnCancelCreateTemplate" data-i18n="cancel">Abbrechen</button>
                <button class="btn btn-primary" id="btnConfirmCreateTemplate" data-i18n="createAndSave">üîß Template erstellen & speichern</button>
            </div>
        </div>
    </div>
    
    <!-- New Month Modal -->
    <div class="modal-overlay hidden" id="newMonthModal">
        <div class="modal" style="max-width: 450px; width: 90%; resize: none;">
            <div class="modal-header">
                <div class="modal-title">üìÖ Neue Monatsdatei erstellen</div>
                <button class="modal-close" id="btnCloseNewMonthModal">&times;</button>
            </div>
            <div class="modal-body" style="overflow: hidden;">
                <p style="margin-bottom: 15px; color: var(--text-muted);">
                    Erstellt eine Kopie der Template-Datei unter neuem Namen und setzt sie als Datei 2.
                </p>
                <label class="config-label">Neuer Dateiname:</label>
                <input type="text" class="search-input" id="newMonthFilename" style="width: 100%; min-width: 0; box-sizing: border-box; margin-bottom: 15px;" placeholder="z.B. Vertragsliste_2025-01.xlsx">
                <p style="font-size: 12px; color: var(--text-muted);">
                    üí° Template: <strong id="newMonthTemplateName">-</strong>
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="btnCancelNewMonth">Abbrechen</button>
                <button class="btn btn-primary" id="btnConfirmNewMonth">üìÖ Erstellen & Laden</button>
            </div>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div class="modal-overlay hidden" id="helpModal">
        <div class="modal" style="max-width: 800px;">
            <div class="modal-header">
                <div class="modal-title">‚ùì Hilfe - Excel Data Sync Pro</div>
                <button class="modal-close" id="btnCloseHelpModal">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <h3 style="margin-bottom: 10px;">üöÄ Schnellstart</h3>
                <ol style="line-height: 2; padding-left: 20px; margin-bottom: 20px;">
                    <li><strong>Quelldatei laden:</strong> Klicken Sie auf "üìÇ Quelldatei laden" und w√§hlen Sie die Excel-Datei, aus der Zeilen kopiert werden sollen.</li>
                    <li><strong>Zieldatei laden:</strong> Laden Sie die Excel-Datei, in die die Zeilen eingef√ºgt werden sollen.</li>
                    <li><strong>Spalten konfigurieren:</strong> Legen Sie fest, welche Spalten kopiert werden sollen.</li>
                    <li><strong>Suchen & √úbertragen:</strong> Suchen Sie nach Zeilen und √ºbertragen Sie diese zur Zieldatei.</li>
                </ol>
                
                <h3 style="margin-bottom: 10px;">üìÇ Dateien laden</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    <strong>Quelldatei (Datei 1):</strong> Die Excel-Datei, aus der Sie Daten kopieren m√∂chten.<br>
                    <strong>Zieldatei (Datei 2):</strong> Die Excel-Datei, in die die Daten eingef√ºgt werden.<br>
                    Nach dem Laden k√∂nnen Sie das gew√ºnschte Arbeitsblatt ausw√§hlen.
                </p>
                
                <h3 style="margin-bottom: 10px;">üîó Spalten-Zuordnung</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    Klicken Sie auf "‚öôÔ∏è Spalten konfigurieren" um festzulegen:<br>
                    ‚Ä¢ <strong>Start-Spalte:</strong> Ab welcher Spalte die Daten in Datei 2 eingef√ºgt werden (Spalte 1+2 = Flag & Kommentar)<br>
                    ‚Ä¢ <strong>Duplikat-Pr√ºfung:</strong> Welche Spalte zur Erkennung von Duplikaten verwendet wird<br>
                    ‚Ä¢ <strong>Zu kopierende Spalten:</strong> Welche Spalten aus Datei 1 √ºbertragen werden
                </p>
                
                <h3 style="margin-bottom: 10px;">üîç Suche</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Geben Sie einen Suchbegriff ein und dr√ºcken Sie Enter oder klicken Sie auf "üîç Suchen".<br>
                    Die Suche durchsucht alle Spalten der Quelldatei. Die letzten 15 Suchen werden gespeichert.
                </p>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 20px; margin-bottom: 10px;">
                    <code style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">*</code>
                    <span>Beliebig viele Zeichen (z.B. <code>ABC*</code>, <code>*123*</code>)</span>
                    <code style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">?</code>
                    <span>Genau ein Zeichen (z.B. <code>A?C</code> findet ABC, ADC, ...)</span>
                </div>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Erweiterte Suche mit AND/OR:</strong>
                </p>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 20px; margin-bottom: 20px;">
                    <code style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">A AND B</code>
                    <span>Findet Zeilen die sowohl A als auch B enthalten</span>
                    <code style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">A OR B</code>
                    <span>Findet Zeilen die A oder B (oder beides) enthalten</span>
                    <code style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Eurofighter AND 2025</code>
                    <span>Beispiel: Eurofighter-Eintr√§ge aus 2025</span>
                </div>
                
                <h3 style="margin-bottom: 10px;">‚úèÔ∏è Suchergebnisse bearbeiten</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    Die Zellen in den Suchergebnissen sind <strong>direkt editierbar</strong>!<br>
                    Klicken Sie in eine Zelle und √§ndern Sie den Wert. Bearbeitete Zellen werden gelb markiert.<br>
                    Die √Ñnderungen werden beim √úbertragen zur Zieldatei √ºbernommen.
                </p>
                
                <h3 style="margin-bottom: 10px;">üì§ √úbertragung</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    <strong>Flag:</strong> A (Add), D (Delete), C (Change) oder Leerzeile<br>
                    <strong>Kommentar:</strong> Optionaler Text f√ºr Spalte 2<br>
                    <strong>Zur Warteschlange:</strong> Sammelt mehrere Zeilen f√ºr gemeinsame √úbertragung<br>
                    <strong>Direkt √ºbertragen:</strong> F√ºgt die Zeilen sofort zur Warteschlange und √ºbertr√§gt
                </p>
                
                <h3 style="margin-bottom: 10px;">üìã Warteschlange</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;
                ">
                    Die Warteschlange zeigt alle zur √úbertragung vorgemerkten Zeilen.<br>
                    <strong>üëÅÔ∏è Vorschau:</strong> Zeigt eine Diff-Ansicht mit allen √Ñnderungen vor der √úbertragung<br>
                    <strong>‚úÖ Direkt √ºbertragen:</strong> Schreibt alle Zeilen direkt in die Excel-Zieldatei<br>
                    <strong>üóëÔ∏è Leeren:</strong> Entfernt alle Zeilen aus der Warteschlange
                </p>
                
                <h3 style="margin-bottom: 10px;">‚ûï Neue Zeile manuell erstellen</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    Mit "‚ûï Neue Zeile" k√∂nnen Sie Zeilen manuell eingeben, ohne sie in der Quelldatei suchen zu m√ºssen.<br>
                    Ideal f√ºr Leerzeilen oder Daten, die nicht in der Quelldatei vorhanden sind.
                </p>
                
                <h3 style="margin-bottom: 10px;">üìä Datenexplorer</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Der Datenexplorer ist ein leistungsstarkes Werkzeug zum √ñffnen, Durchsuchen, Bearbeiten und Filtern von Excel-Dateien.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üìÇ Datei √∂ffnen</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    ‚Ä¢ Klicken Sie auf "üìä Datenexplorer" und dann "üìÇ Datei √∂ffnen"<br>
                    ‚Ä¢ W√§hlen Sie das gew√ºnschte Arbeitsblatt aus dem Dropdown
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üîç Suche & Filter</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Volltextsuche:</strong> Durchsucht alle Spalten mit Platzhalter-Unterst√ºtzung (* und ?)<br>
                    <strong>Spaltenfilter:</strong> Klicken Sie auf "+ Filter hinzuf√ºgen" f√ºr gezielte Filterung:<br>
                </p>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 15px; margin: 0 0 10px 15px; font-size: 13px;">
                    <code>enth√§lt / enth√§lt nicht</code><span>Teilstring-Suche</span>
                    <code>gleich / ungleich</code><span>Exakte √úbereinstimmung</span>
                    <code>beginnt mit / endet mit</code><span>Position im Text</span>
                    <code>ist leer / ist nicht leer</code><span>Leere Zellen finden</span>
                    <code>&gt; / &lt; / &gt;= / &lt;=</code><span>Numerische Vergleiche</span>
                </div>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üìã Spalten verwalten</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Spalten ein-/ausblenden:</strong> √úber "Spalten" ‚Üí Checkboxen aktivieren/deaktivieren<br>
                    <strong>Sortierung:</strong> Rechtsklick auf Spalten√ºberschrift √∂ffnet Kontextmen√º mit Sortieroptionen:<br>
                </p>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 15px; margin: 0 0 10px 15px; font-size: 13px;">
                    <code>A‚ÜíZ / Z‚ÜíA</code><span>Alphabetische Sortierung</span>
                    <code>0‚Üí9 / 9‚Üí0</code><span>Numerische Sortierung</span>
                    <code>Datum ‚Üë / Datum ‚Üì</code><span>Datumsortierung (deutsches Format)</span>
                </div>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Drag & Drop:</strong> Spalten per Drag & Drop neu anordnen
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">‚úèÔ∏è Zellen bearbeiten</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Alle Zellen sind <strong>direkt editierbar</strong>! Klicken Sie in eine Zelle und √§ndern Sie den Wert.<br>
                    Bearbeitete Zellen werden <span style="background: rgba(255, 193, 7, 0.3); padding: 2px 6px; border-radius: 3px;">gelb markiert</span>.<br>
                    <strong>Strg+Z / Strg+Y:</strong> √Ñnderungen r√ºckg√§ngig machen / wiederherstellen
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">ÔøΩ Multi-Zellen-Auswahl</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Klick:</strong> Einzelne Zelle ausw√§hlen<br>
                    <strong>Shift+Klick:</strong> Bereich von Zellen ausw√§hlen (von letzter Auswahl bis Klickposition)<br>
                    <strong>Strg+Klick:</strong> Einzelne Zellen zur Auswahl hinzuf√ºgen/entfernen<br>
                    <strong>Maus ziehen:</strong> Rechteckigen Bereich ausw√§hlen<br>
                    <strong>Rechtsklick auf Auswahl:</strong> Kontextmen√º mit Optionen:
                </p>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 15px; margin: 0 0 10px 15px; font-size: 13px;">
                    <code>üóëÔ∏è Inhalte l√∂schen</code><span>L√∂scht alle ausgew√§hlten Zellinhalte</span>
                    <code>üìã Kopieren</code><span>Kopiert Zellinhalte in die Zwischenablage</span>
                    <code>‚ùå Auswahl aufheben</code><span>Hebt die aktuelle Auswahl auf</span>
                </div>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üé® Zeilen markieren</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Rechtsklick auf Zeile:</strong> √ñffnet Kontextmen√º zur farbigen Markierung<br>
                    Verf√ºgbare Farben: üü¢ Gr√ºn, üü° Gelb, üü† Orange, üî¥ Rot, üîµ Blau, üü£ Lila<br>
                    Markierungen helfen beim visuellen Organisieren und bleiben beim Filtern erhalten.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üëÅÔ∏è Vorschau</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Klicken Sie auf "üëÅÔ∏è Vorschau" um das gesamte Datenblatt mit allen √Ñnderungen zu sehen,<br>
                    bevor Sie exportieren. Bearbeitete Zellen werden hervorgehoben.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üì§ Speichern & Export</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>üíæ Speichern:</strong> Speichert alle √Ñnderungen direkt in die Originaldatei<br>
                    ‚Ä¢ Zeigt Best√§tigungsdialog mit Anzahl der √Ñnderungen<br>
                    ‚Ä¢ Alle Formatierungen der Originaldatei bleiben erhalten<br><br>
                    <strong>üìä Als XLSX exportieren:</strong> Speichert als neue Datei<br>
                    ‚Ä¢ Auswahl welche Arbeitsbl√§tter mit exportiert werden sollen<br>
                    ‚Ä¢ Alle Formatierungen werden beibehalten<br>
                    ‚Ä¢ Nur sichtbare Spalten werden exportiert
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üìã Arbeitsbl√§tter wechseln</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    W√§hlen Sie ein anderes Arbeitsblatt aus dem Dropdown. Alle Ihre √Ñnderungen werden automatisch zwischengespeichert und bleiben beim Wechsel zwischen Sheets erhalten.
                </p>
                
                <h3 style="margin-bottom: 10px;">üìÑ Template-Funktionen</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Templates dienen als Vorlagen f√ºr neue Monatsdateien. Alle Formatierungen werden √ºbernommen.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üìÇ Template laden</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    L√§dt eine bestehende Excel-Datei als Template f√ºr neue Monatsdateien.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üìÖ Neue Monatsdatei erstellen</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Erstellt eine Kopie des Templates mit neuem Namen (z.B. f√ºr einen neuen Monat).<br>
                    Die neue Datei wird automatisch als Zieldatei (Datei 2) geladen.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üîß Template aus Quelldatei erstellen</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    Erstellt ein leeres Template aus einer bestehenden Datei:<br>
                    ‚Ä¢ W√§hlen Sie welche Arbeitsbl√§tter √ºbernommen werden sollen<br>
                    ‚Ä¢ Alle Formatierungen, bedingte Formatierungen und Formeln bleiben erhalten<br>
                    ‚Ä¢ Die Datenzeilen werden entfernt, nur √úberschriften bleiben
                </p>
                
                <h3 style="margin-bottom: 10px;">üìÅ Arbeitsordner</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    Legen Sie einen Arbeitsordner fest, der als Standard-Verzeichnis f√ºr alle Datei-Dialoge verwendet wird.<br>
                    Die config.json wird zuerst im Arbeitsordner gesucht, dann im Programmordner.
                </p>
                
                <h3 style="margin-bottom: 10px;">üíæ Konfiguration</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    <strong>config.json laden:</strong> L√§dt eine gespeicherte Konfiguration (Spalten-Zuordnung, Dateipfade)<br>
                    <strong>config.json speichern:</strong> Speichert die aktuelle Konfiguration f√ºr sp√§teren Zugriff<br>
                    üí° Ideal f√ºr Teams: Eine config.json auf dem Netzlaufwerk f√ºr alle Nutzer!
                </p>
                
                <h3 style="margin-bottom: 10px;">‚å®Ô∏è Tastenk√ºrzel</h3>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 20px; margin-bottom: 20px;">
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Strg+F</kbd>
                    <span>Fokus auf Suchfeld setzen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Strg+S</kbd>
                    <span>Warteschlange exportieren / Daten speichern</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Strg+Enter</kbd>
                    <span>Ausgew√§hlte Zeilen direkt √ºbertragen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Strg+Z</kbd>
                    <span>Letzte Bearbeitung r√ºckg√§ngig machen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Strg+Y</kbd>
                    <span>R√ºckg√§ngig gemachte Bearbeitung wiederherstellen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">F5</kbd>
                    <span>Suche aktualisieren / Daten neu laden</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">F1</kbd>
                    <span>Diese Hilfe √∂ffnen/schlie√üen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Enter</kbd>
                    <span>Suche starten (im Suchfeld) / N√§chste Zeile (in Tabelle)</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Esc</kbd>
                    <span>Dialog schlie√üen / Bearbeitung abbrechen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Tab</kbd>
                    <span>Zur n√§chsten Zelle in den Suchergebnissen</span>
                </div>
                
                <h3 style="margin-bottom: 10px;">‚ö†Ô∏è Wichtige Hinweise</h3>
                <p style="color: var(--text-muted); line-height: 1.6;">
                    ‚Ä¢ Die Zieldatei (Datei 2) muss in Excel <strong>geschlossen</strong> sein, bevor Sie √ºbertragen<br>
                    ‚Ä¢ Duplikate werden automatisch erkannt und als Warnung angezeigt<br>
                    ‚Ä¢ √Ñnderungen werden direkt in die Excel-Datei geschrieben (kein separater Export n√∂tig)<br>
                    ‚Ä¢ Die Sidebar kann mit dem ‚óÄ Button eingeklappt werden
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="btnCloseHelp">Schlie√üen</button>
            </div>
        </div>
    </div>
    
    <!-- License Modal -->
    <div class="modal-overlay hidden" id="licenseModal">
        <div class="modal" style="max-width: 900px;">
            <div class="modal-header">
                <div class="modal-title">üìú <span data-i18n="licenseTitle">Lizenzinformationen</span></div>
                <button class="modal-close" id="btnCloseLicenseModal">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <!-- Excel Data Sync Pro License -->
                <h3 style="margin-bottom: 10px;">üõ°Ô∏è Excel Data Sync Pro Lizenz</h3>
                <div style="background: var(--bg-lighter); padding: 15px; border-radius: 6px; margin-bottom: 20px; font-family: monospace; font-size: 12px; line-height: 1.6;">
                    <strong>MIT License</strong><br><br>
                    Copyright (c) 2025 Norbert Jander<br><br>
                    Permission is hereby granted, free of charge, to any person obtaining a copy
                    of this software and associated documentation files (the "Software"), to deal
                    in the Software without restriction, including without limitation the rights
                    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                    copies of the Software, and to permit persons to whom the Software is
                    furnished to do so, subject to the following conditions:<br><br>
                    The above copyright notice and this permission notice shall be included in all
                    copies or substantial portions of the Software.<br><br>
                    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                    SOFTWARE.
                </div>
                
                <!-- German Explanation -->
                <h3 style="margin-bottom: 10px;">üá©üá™ Was bedeutet die MIT-Lizenz? (Deutsch)</h3>
                <div style="color: var(--text-muted); line-height: 1.6; margin-bottom: 20px; padding: 15px; background: var(--bg-light); border-radius: 6px; border-left: 4px solid var(--primary);">
                    <p style="margin-bottom: 10px;"><strong>Die MIT-Lizenz ist eine der freiz√ºgigsten Open-Source-Lizenzen.</strong></p>
                    <p style="margin-bottom: 10px;">Sie d√ºrfen diese Software:</p>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>‚úÖ <strong>Nutzen</strong> ‚Äì f√ºr private und kommerzielle Zwecke</li>
                        <li>‚úÖ <strong>Kopieren</strong> ‚Äì beliebig viele Kopien erstellen</li>
                        <li>‚úÖ <strong>Modifizieren</strong> ‚Äì den Quellcode anpassen</li>
                        <li>‚úÖ <strong>Verbreiten</strong> ‚Äì weitergeben oder ver√∂ffentlichen</li>
                        <li>‚úÖ <strong>Verkaufen</strong> ‚Äì auch kommerzielle Nutzung ist erlaubt</li>
                    </ul>
                    <p style="margin-bottom: 10px;"><strong>Einzige Bedingung:</strong> Der Urheberrechtshinweis und der Lizenztext m√ºssen in allen Kopien enthalten sein.</p>
                    <p><strong>‚ö†Ô∏è Haftungsausschluss:</strong> Die Software wird "wie sie ist" bereitgestellt, ohne jegliche Garantie.</p>
                </div>
                
                <!-- English Explanation -->
                <h3 style="margin-bottom: 10px;">üá¨üáß What does the MIT License mean? (English)</h3>
                <div style="color: var(--text-muted); line-height: 1.6; margin-bottom: 20px; padding: 15px; background: var(--bg-light); border-radius: 6px; border-left: 4px solid var(--primary);">
                    <p style="margin-bottom: 10px;"><strong>The MIT License is one of the most permissive open-source licenses.</strong></p>
                    <p style="margin-bottom: 10px;">You are allowed to:</p>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>‚úÖ <strong>Use</strong> ‚Äì for private and commercial purposes</li>
                        <li>‚úÖ <strong>Copy</strong> ‚Äì create as many copies as you want</li>
                        <li>‚úÖ <strong>Modify</strong> ‚Äì adapt the source code</li>
                        <li>‚úÖ <strong>Distribute</strong> ‚Äì share or publish it</li>
                        <li>‚úÖ <strong>Sell</strong> ‚Äì commercial use is allowed</li>
                    </ul>
                    <p style="margin-bottom: 10px;"><strong>Only requirement:</strong> The copyright notice and license text must be included in all copies.</p>
                    <p><strong>‚ö†Ô∏è Disclaimer:</strong> The software is provided "as is", without warranty of any kind.</p>
                </div>
                
                <!-- Third Party Licenses -->
                <h3 style="margin-bottom: 10px;">üì¶ <span data-i18n="thirdPartyLicenses">Drittanbieter-Lizenzen</span></h3>
                <p style="color: var(--text-muted); margin-bottom: 15px;" data-i18n="thirdPartyDesc">Excel Data Sync Pro verwendet folgende Open-Source-Bibliotheken:</p>
                
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- Electron -->
                    <div style="background: var(--bg-light); padding: 12px; border-radius: 6px; border: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong style="color: var(--text-primary);">‚ö° Electron</strong>
                            <span style="background: var(--success); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">MIT</span>
                        </div>
                        <p style="color: var(--text-muted); font-size: 12px; margin-top: 5px;">Cross-platform desktop app framework</p>
                        <a href="https://www.electronjs.org/" style="color: var(--primary-light); font-size: 12px;">electronjs.org</a>
                    </div>
                    
                    <!-- xlsx-populate -->
                    <div style="background: var(--bg-light); padding: 12px; border-radius: 6px; border: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong style="color: var(--text-primary);">üìä xlsx-populate</strong>
                            <span style="background: var(--success); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">MIT</span>
                        </div>
                        <p style="color: var(--text-muted); font-size: 12px; margin-top: 5px;">Excel XLSX manipulation with formatting preservation</p>
                        <a href="https://github.com/dtjohnson/xlsx-populate" style="color: var(--primary-light); font-size: 12px;">github.com/dtjohnson/xlsx-populate</a>
                    </div>
                    
                    <!-- electron-builder -->
                    <div style="background: var(--bg-light); padding: 12px; border-radius: 6px; border: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong style="color: var(--text-primary);">üì¶ electron-builder</strong>
                            <span style="background: var(--success); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">MIT</span>
                        </div>
                        <p style="color: var(--text-muted); font-size: 12px; margin-top: 5px;">Build and publish Electron apps</p>
                        <a href="https://www.electron.build/" style="color: var(--primary-light); font-size: 12px;">electron.build</a>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: var(--bg-lighter); border-radius: 6px; text-align: center;">
                    <p style="color: var(--text-muted); font-size: 13px;" data-i18n="allLicensesMIT">
                        Alle verwendeten Bibliotheken sind unter der MIT-Lizenz oder kompatiblen Open-Source-Lizenzen lizenziert.
                    </p>
                    <p style="color: var(--text-muted); font-size: 12px; margin-top: 8px;">
                        <strong>387</strong> <span data-i18n="packagesTotal">Pakete gesamt</span> ¬∑ 
                        <strong>MIT:</strong> 287 ¬∑ 
                        <strong>ISC:</strong> 62 ¬∑ 
                        <strong>Apache-2.0:</strong> 10 ¬∑ 
                        <strong>BSD:</strong> 13
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="btnCloseLicense" data-i18n="close">Schlie√üen</button>
            </div>
        </div>
    </div>

    <!-- Transfer Preview / Diff Modal -->
    <div class="modal-overlay hidden" id="diffPreviewModal">
        <div class="modal" style="max-width: 1000px; width: 90vw; max-height: 85vh;">
            <div class="modal-header">
                <div class="modal-title">üëÅÔ∏è Vorschau: <span id="diffPreviewCount">0</span> Zeile(n) werden √ºbertragen</div>
                <button class="modal-close" id="btnCloseDiffModal">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 60vh; overflow-y: auto; padding: 15px;">
                <div id="diffPreviewInfo" style="margin-bottom: 15px; padding: 12px; background: var(--bg-light); border-radius: 6px; border-left: 4px solid var(--primary);">
                    <strong>Zieldatei:</strong> <span id="diffTargetFile">-</span><br>
                    <strong>Arbeitsblatt:</strong> <span id="diffTargetSheet">-</span><br>
                    <strong>Neue Zeilen ab Zeile:</strong> <span id="diffTargetRow">-</span>
                </div>
                
                <div style="margin-bottom: 10px; display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="display: inline-block; width: 16px; height: 16px; background: rgba(76, 175, 80, 0.3); border: 1px solid #4CAF50; border-radius: 3px;"></span>
                        <span style="font-size: 13px;">Neue Zeile</span>
                    </span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="display: inline-block; width: 16px; height: 16px; background: rgba(244, 67, 54, 0.3); border: 1px solid #F44336; border-radius: 3px;"></span>
                        <span style="font-size: 13px;">Delete-Flag</span>
                    </span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="display: inline-block; width: 16px; height: 16px; background: rgba(255, 152, 0, 0.3); border: 1px solid #FF9800; border-radius: 3px;"></span>
                        <span style="font-size: 13px;">Change-Flag</span>
                    </span>
                </div>
                
                <div id="diffPreviewTable" style="overflow-x: auto;">
                    <!-- Wird dynamisch gef√ºllt -->
                </div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="btn btn-secondary" id="btnCancelDiff">Abbrechen</button>
                <button class="btn btn-success" id="btnConfirmTransfer">‚úÖ Jetzt √ºbertragen</button>
            </div>
        </div>
    </div>

    <!-- Column Context Menu for Data Explorer -->
    <div id="columnContextMenu" class="context-menu hidden" style="display: none; position: fixed; z-index: 10000; background: var(--bg-medium); border: 1px solid var(--border); border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); min-width: 180px; padding: 4px 0;">
        <div class="context-menu-header" style="padding: 8px 12px; font-weight: bold; color: var(--text-muted); font-size: 12px; border-bottom: 1px solid var(--border);">
            Spalte: <span id="contextMenuColumnName">-</span>
        </div>
        <div class="context-menu-item" data-action="sort-alpha-asc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üî§</span> Alphabetisch A ‚Üí Z
        </div>
        <div class="context-menu-item" data-action="sort-alpha-desc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üî§</span> Alphabetisch Z ‚Üí A
        </div>
        <div class="context-menu-divider" style="height: 1px; background: var(--border); margin: 4px 0;"></div>
        <div class="context-menu-item" data-action="sort-num-asc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üî¢</span> Numerisch 1 ‚Üí 9
        </div>
        <div class="context-menu-item" data-action="sort-num-desc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üî¢</span> Numerisch 9 ‚Üí 1
        </div>
        <div class="context-menu-divider" style="height: 1px; background: var(--border); margin: 4px 0;"></div>
        <div class="context-menu-item" data-action="sort-date-asc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üìÖ</span> Datum Alt ‚Üí Neu
        </div>
        <div class="context-menu-item" data-action="sort-date-desc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üìÖ</span> Datum Neu ‚Üí Alt
        </div>
        <div class="context-menu-divider" style="height: 1px; background: var(--border); margin: 4px 0;"></div>
        <div class="context-menu-item" data-action="hide-column" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üëÅÔ∏è‚Äçüó®Ô∏è</span> Spalte ausblenden
        </div>
    </div>

    <!-- Data Explorer Modal -->
    <div class="modal-overlay hidden" id="dataExplorerModal">
        <div class="modal modal-large" style="max-width: 95vw; width: 1400px; max-height: 90vh; min-width: 600px; min-height: 400px;">
            <div class="modal-header">
                <div class="modal-title">üìä Datenexplorer - <span id="explorerFileName">Keine Datei geladen</span></div>
                <button class="modal-close" id="btnCloseExplorerX">&times;</button>
            </div>
            <div class="modal-body" style="display: flex; flex-direction: column; gap: 15px; padding: 15px; overflow-y: auto; flex: 1; min-height: 0;">
                <!-- Explorer Controls -->
                <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end; flex-shrink: 0;">
                    <button class="btn btn-primary" id="btnExplorerOpenFile">
                        üìÇ Datei √∂ffnen
                    </button>
                    <div class="transfer-field">
                        <label>Arbeitsblatt:</label>
                        <select id="explorerSheetSelect" class="config-select" style="min-width: 200px;">
                            <option value="">-- Datei laden --</option>
                        </select>
                    </div>
                    <div class="transfer-field" style="flex: 1;">
                        <label>Volltextsuche:</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="explorerSearch" class="config-input" placeholder="Suchbegriff eingeben..." style="flex: 1; min-width: 200px;">
                            <button class="btn btn-primary btn-sm" id="btnExplorerSearch" title="Suche starten (Enter)">üîç</button>
                        </div>
                    </div>
                    <button class="btn btn-primary" id="btnToggleColumns" title="Spalten ein-/ausblenden">
                        üëÅÔ∏è Spalten
                    </button>
                    <button class="btn btn-primary" id="btnExplorerPreview" title="Vorschau des gesamten Datenblattes mit √Ñnderungen" disabled>
                        üëÅÔ∏è Vorschau
                    </button>
                    <button class="btn btn-success" id="btnExplorerSave" title="√Ñnderungen in Originaldatei speichern">
                        üíæ Speichern
                    </button>
                    <button class="btn btn-primary" id="btnExplorerExport">
                        üìä Als XLSX exportieren
                    </button>
                </div>
                
                <!-- Filter Controls -->
                <div id="explorerFilterControls" style="display: flex; flex-direction: column; gap: 10px; padding: 12px; background: var(--bg-light); border-radius: 6px; border: 1px solid var(--border); flex-shrink: 0;">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <span style="font-weight: 600; font-size: 14px;">üîç Filter</span>
                        <button class="btn btn-primary btn-sm" id="btnAddExplorerFilter">‚ûï Filter hinzuf√ºgen</button>
                        <button class="btn btn-secondary btn-sm" id="btnClearExplorerFilters" disabled>üóëÔ∏è Filter zur√ºcksetzen</button>
                    </div>
                    <div id="explorerFilters" style="display: flex; flex-direction: column; gap: 8px;"></div>
                </div>
                
                <!-- Column Visibility Panel (initially hidden) -->
                <div id="columnTogglePanel" style="display: none; flex-direction: column; gap: 10px; padding: 15px; background: var(--bg-light); border-radius: 6px; margin-bottom: 10px; border: 1px solid var(--border); flex-shrink: 0;">
                    <div style="display: flex; gap: 10px; margin-bottom: 5px;">
                        <button class="btn btn-secondary btn-sm" id="btnShowAllColumns">Alle anzeigen</button>
                        <button class="btn btn-secondary btn-sm" id="btnHideAllColumns">Alle ausblenden</button>
                    </div>
                    <div id="columnToggles" style="display: flex; flex-wrap: wrap; gap: 8px; max-height: 200px; overflow-y: auto;"></div>
                </div>
                
                <!-- Row Move Toolbar (initially hidden) -->
                <div id="rowMoveToolbar" style="display: none; gap: 10px; padding: 12px; background: linear-gradient(135deg, #217346 0%, #1a5c38 100%); border-radius: 6px; align-items: center; flex-wrap: wrap; flex-shrink: 0;">
                    <span style="color: white; font-weight: 600;">üîÄ <span id="selectedRowCount">0</span> Zeile(n) ausgew√§hlt</span>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <span style="color: white;">Verschieben:</span>
                        <select id="movePosition" class="config-select" style="min-width: 80px; padding: 4px 8px;">
                            <option value="before">Vor</option>
                            <option value="after">Nach</option>
                        </select>
                        <span style="color: white;">Zeile</span>
                        <input type="number" id="moveTargetRow" class="config-input" style="width: 80px; padding: 4px 8px;" min="1" placeholder="Nr.">
                        <button class="btn btn-sm" id="btnExecuteMove" style="background: white; color: #217346; font-weight: 600;">‚úì Verschieben</button>
                    </div>
                    <button class="btn btn-sm" id="btnClearRowSelection" style="background: rgba(255,255,255,0.2); color: white; margin-left: auto;">‚úï Auswahl aufheben</button>
                </div>
                
                <!-- Results Info -->
                <div style="display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; flex-wrap: wrap; gap: 10px;">
                    <span id="explorerResultCount" style="color: var(--text-muted);">Keine Daten geladen.</span>
                    
                    <!-- Pagination Controls -->
                    <div id="explorerPagination" style="display: none; align-items: center; gap: 8px;">
                        <button class="btn btn-secondary btn-sm" id="btnExplorerFirstPage" title="Erste Seite">‚èÆ</button>
                        <button class="btn btn-secondary btn-sm" id="btnExplorerPrevPage" title="Vorherige Seite">‚óÄ</button>
                        <span id="explorerPageInfo" style="color: var(--text-muted); font-size: 13px; min-width: 120px; text-align: center;">Seite 1 von 1</span>
                        <button class="btn btn-secondary btn-sm" id="btnExplorerNextPage" title="N√§chste Seite">‚ñ∂</button>
                        <button class="btn btn-secondary btn-sm" id="btnExplorerLastPage" title="Letzte Seite">‚è≠</button>
                        <select id="explorerPageSize" style="padding: 4px 8px; border-radius: 4px; background: var(--bg-light); border: 1px solid var(--border); color: var(--text-primary);">
                            <option value="50">50 / Seite</option>
                            <option value="100" selected>100 / Seite</option>
                            <option value="250">250 / Seite</option>
                            <option value="500">500 / Seite</option>
                            <option value="1000">1000 / Seite</option>
                        </select>
                    </div>
                    
                    <span id="explorerStatus" style="color: var(--text-muted); font-size: 12px;"></span>
                </div>
                
                <!-- Table Container -->
                <div id="explorerTableContainer" style="flex: 1; min-height: 200px; overflow: auto; background: var(--bg-dark); border-radius: 6px; border: 1px solid var(--border);">
                    <table class="results-table" id="explorerTable">
                        <thead id="explorerTableHead"></thead>
                        <tbody id="explorerTableBody">
                            <tr><td style="text-align: center; padding: 40px; color: var(--text-muted);">üìÇ Bitte eine Excel-Datei laden</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="btnCloseExplorerFooter">Schlie√üen</button>
            </div>
        </div>
    </div>
    
    <!-- Explorer Preview Modal -->
    <div class="modal-overlay hidden" id="explorerPreviewModal">
        <div class="modal" style="max-width: 95vw; width: 1600px; max-height: 95vh;">
            <div class="modal-header">
                <div class="modal-title">üëÅÔ∏è Vorschau: <span id="previewFileName">-</span> - <span id="previewSheetName">-</span></div>
                <button class="modal-close" id="btnClosePreviewX">&times;</button>
            </div>
            <div class="modal-body" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; max-height: calc(95vh - 120px); overflow: hidden;">
                <!-- Info -->
                <div style="display: flex; gap: 20px; flex-wrap: wrap; padding: 12px; background: var(--bg-light); border-radius: 6px; border-left: 4px solid var(--primary);">
                    <div>
                        <strong>Zeilen:</strong> <span id="previewRowCount">0</span>
                    </div>
                    <div>
                        <strong>Spalten:</strong> <span id="previewColCount">0</span>
                    </div>
                    <div>
                        <strong>Bearbeitete Zellen:</strong> <span id="previewEditCount" style="color: var(--warning);">0</span>
                    </div>
                </div>
                
                <!-- Legende -->
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <span style="font-weight: 600;">Legende:</span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="display: inline-block; width: 20px; height: 20px; background: rgba(255, 193, 7, 0.3); border: 2px solid #FFC107; border-radius: 3px;"></span>
                        <span style="font-size: 13px;">Bearbeitete Zelle</span>
                    </span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="display: inline-block; width: 20px; height: 20px; background: var(--bg-light); border: 1px solid var(--border); border-radius: 3px;"></span>
                        <span style="font-size: 13px;">Unver√§ndert</span>
                    </span>
                </div>
                
                <!-- Tabellen-Container -->
                <div id="previewTableContainer" style="flex: 1; overflow: auto; background: var(--bg-dark); border-radius: 6px; border: 1px solid var(--border);">
                    <!-- Wird dynamisch gef√ºllt -->
                </div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="btn btn-secondary" id="btnClosePreview">Schlie√üen</button>
            </div>
        </div>
    </div>
    
    <!-- Filter Template f√ºr Explorer -->
    <template id="explorerFilterTemplate">
        <div class="explorer-filter-row" style="display: flex; gap: 10px; align-items: center; padding: 8px; background: var(--bg-dark); border-radius: 4px;">
            <select class="filter-column config-select" style="min-width: 180px;"></select>
            <select class="filter-operator config-select" style="min-width: 120px;">
                <option value="contains">enth√§lt</option>
                <option value="equals">gleich</option>
                <option value="startsWith">beginnt mit</option>
                <option value="endsWith">endet mit</option>
            </select>
            <input type="text" class="filter-value config-input" placeholder="Filterwert" style="flex: 1; min-width: 150px;">
            <button type="button" class="btn btn-secondary btn-sm remove-filter">‚úï</button>
        </div>
    </template>

    <script>
        // ============================================
        // ELECTRON-ONLY MODE
        // ============================================
        console.log('üöÄ Electron-Modus aktiv');
        
        // ============================================
        // INTERNATIONALIZATION (i18n)
        // ============================================
        const translations = {
            de: {
                // Header
                appTitle: 'Excel Data Sync Pro',
                loadConfig: 'üìÇ config.json laden',
                saveConfig: 'üíæ config.json speichern',
                help: '‚ùì Hilfe',
                
                // Sidebar
                configuration: 'Konfiguration',
                settings: '‚öôÔ∏è Einstellungen',
                language: 'Sprache',
                theme: 'Design',
                themeDark: 'üåô Dunkel',
                themeLight: '‚òÄÔ∏è Hell',
                
                // Working Directory
                workingDirectory: 'üìÅ Arbeitsordner',
                selectWorkingDir: 'üìÇ Ordner ausw√§hlen',
                noWorkingDirSet: 'Kein Ordner gew√§hlt',
                clearWorkingDir: '‚úñÔ∏è Arbeitsordner l√∂schen',
                workingDirSet: '‚úì ',
                workingDirCleared: 'Arbeitsordner gel√∂scht',
                
                // Files
                file1Source: 'üìÑ Datei 1 (Quelle)',
                file2Target: 'üìÑ Datei 2 (Ziel)',
                loadSourceFile: 'üìÇ Quelldatei laden',
                loadTargetFile: 'üìÇ Zieldatei laden',
                noFileLoaded: 'Keine Datei geladen',
                worksheet: 'Arbeitsblatt:',
                loadFileFirst: '-- Erst Datei laden --',
                
                // Mapping
                columnMapping: 'üîó Spalten-Zuordnung',
                configureColumns: '‚öôÔ∏è Spalten konfigurieren',
                loadBothFiles: 'Laden Sie beide Dateien',
                columnsConfigured: 'Spalte(n) konfiguriert',
                
                // Template
                monthTemplate: 'üìÑ Monats-Template',
                loadTemplate: 'üìÇ Template laden',
                createTemplateFromSource: 'üîß Template aus Quelldatei',
                noTemplateLoaded: 'Kein Template geladen',
                templateHint: 'Leere Excel-Vorlage f√ºr "üìÖ Neue Monatsdatei"',
                createTemplateTitle: 'üîß Template aus Quelldatei erstellen',
                createTemplateDesc: 'Erstellt ein leeres Template mit allen Formatierungen und bedingten Formatierungen aus der Quelldatei.',
                sourceFileLabel: 'Quelldatei:',
                selectSheets: 'Arbeitsbl√§tter ausw√§hlen:',
                loadSourceFirst: 'Laden Sie zuerst eine Quelldatei',
                selectAll: '‚úì Alle ausw√§hlen',
                deselectAll: '‚úó Alle abw√§hlen',
                templateInfoText: 'üí° Die Header-Zeile wird behalten, alle Datenzeilen werden gel√∂scht. CF-Regeln werden auf ganze Spalten erweitert.',
                createAndSave: 'üîß Template erstellen & speichern',
                templateCreated: 'Template erfolgreich erstellt',
                sheetsProcessed: 'Arbeitsbl√§tter verarbeitet',
                cfRulesPreserved: 'CF-Regeln erhalten',
                extraColumnsInTemplate: 'Extra-Spalten im Template erstellen:',
                flagColumn: 'Flag-Spalte (A)',
                commentColumn: 'Kommentar-Spalte (B)',
                extraColumnsHint: 'Aktivieren, wenn in "Spalten konfigurieren" die entsprechenden Optionen genutzt werden.',
                
                // History
                lastTransfers: 'üìã Letzte √úbertragungen',
                noTransfersYet: 'Noch keine √úbertragungen',
                
                // Search
                searchPlaceholder: 'Suche... (Platzhalter: * = beliebig, ? = ein Zeichen)',
                search: 'üîç Suchen',
                newRow: '‚ûï Neue Zeile',
                
                // Results
                readyToStart: 'Bereit zum Starten',
                instructions: '1. Laden Sie die Quelldatei (Datei 1)<br>2. Laden Sie die Zieldatei (Datei 2)<br>3. Konfigurieren Sie die Spalten-Zuordnung<br>4. Suchen Sie nach Zeilen und √ºbertragen Sie diese',
                noResults: 'Keine Treffer f√ºr',
                results: 'Treffer f√ºr',
                
                // Transfer
                prepareTransfer: 'üì§ Zeile(n) zur √úbertragung vorbereiten',
                selected: 'ausgew√§hlt',
                flag: 'Spalte 1 - Flag:',
                comment: 'Spalte 2 - Kommentar:',
                commentPlaceholder: 'Freier Text...',
                addToQueue: '‚ûï Markierte zur Warteschlange',
                transferDirect: '‚û°Ô∏è Markierte direkt √ºbertragen',
                selectAll: '‚òëÔ∏è Alle ausw√§hlen',
                deselectAll: '‚òêAlles abw√§hlen',
                
                // Queue
                queue: 'üìã Warteschlange',
                rows: 'Zeilen',
                clear: 'üóëÔ∏è Leeren',
                directTransfer: '‚úÖ Direkt √ºbertragen',
                dataExplorer: 'Datenexplorer',
                newMonthFile: 'üìÖ Neue Monatsdatei',
                noRowsInQueue: 'Keine Zeilen in der Warteschlange',
                
                // New Row
                createNewRow: '‚úèÔ∏è Neue Zeile erstellen',
                close: '‚úï Schlie√üen',
                toQueue: '‚ûï Zur Warteschlange',
                transferDirectly: '‚û°Ô∏è Direkt √ºbertragen',
                
                // Messages
                noTargetFile: 'Keine Zieldatei geladen',
                selectAtLeastOne: 'Bitte w√§hlen Sie mindestens eine Zeile aus',
                rowsTransferred: 'Zeile(n) direkt √ºbertragen!',
                rowsAdded: 'Zeile(n) zur Warteschlange hinzugef√ºgt',
                edited: 'bearbeitet',
                duplicates: 'Duplikat(e)',
                configFirst: 'Bitte zuerst Spalten konfigurieren',
                
                // Data Explorer
                explorerTitle: 'Datenexplorer',
                noFileLoadedExplorer: 'Keine Datei geladen',
                openFile: 'üìÇ Datei √∂ffnen',
                fullTextSearch: 'Volltextsuche:',
                searchPlaceholderExplorer: 'Suchbegriff eingeben...',
                columns: 'üëÅÔ∏è Spalten',
                exportXlsx: 'üìä Als XLSX exportieren',
                saveFile: 'üíæ Speichern',
                filter: 'üîç Filter',
                addFilter: '‚ûï Filter hinzuf√ºgen',
                resetFilters: 'üóëÔ∏è Filter zur√ºcksetzen',
                showAll: 'Alle anzeigen',
                hideAll: 'Alle ausblenden',
                noDataLoaded: 'No data loaded.',
                pleaseLoadFile: 'üìÇ Please load an Excel file',
                contains: 'enth√§lt',
                equals: 'gleich',
                startsWith: 'beginnt mit',
                endsWith: 'endet mit',
                selectColumn: 'Spalte w√§hlen',
                filterValue: 'Filterwert',
                
                // New Month Modal
                createNewMonthFile: 'üìÖ Neue Monatsdatei erstellen',
                newMonthDescription: 'Erschafft eine Kopie der Template-Datei unter neuem Namen und setzt sie als Datei 2.',
                newFilename: 'Neuer Dateiname:',
                filenamePlaceholder: 'z.B. Vertragsliste_2025-01.xlsx',
                templateLabel: 'üí° Template:',
                cancel: 'Abbrechen',
                createAndLoad: 'üìÖ Erstellen & Laden',
                
                // Footer
                copyright: '¬© Norbert Jander 2025 ¬∑ v1.0.10',
                
                // Extra Columns
                extraColumns: 'Extra-Spalten',
                enableFlag: 'Flag-Spalte (A/D/C)',
                enableComment: 'Kommentar-Spalte',
                
                // License
                license: 'Lizenz',
                licenseTitle: 'Lizenzinformationen',
                thirdPartyLicenses: 'Drittanbieter-Lizenzen',
                thirdPartyDesc: 'Excel Data Sync Pro verwendet folgende Open-Source-Bibliotheken:',
                allLicensesMIT: 'Alle verwendeten Bibliotheken sind unter der MIT-Lizenz oder kompatiblen Open-Source-Lizenzen lizenziert.',
                packagesTotal: 'Pakete gesamt'
            },
            en: {
                // Header
                appTitle: 'Excel Data Sync Pro',
                loadConfig: 'üìÇ Load config.json',
                saveConfig: 'üíæ Save config.json',
                help: '‚ùì Help',
                
                // Sidebar
                configuration: 'Configuration',
                settings: '‚öôÔ∏è Settings',
                language: 'Language',
                theme: 'Theme',
                themeDark: 'üåô Dark',
                themeLight: '‚òÄÔ∏è Light',
                
                // Working Directory
                workingDirectory: 'üìÅ Working Directory',
                selectWorkingDir: 'üìÇ Select Folder',
                noWorkingDirSet: 'No folder selected',
                clearWorkingDir: '‚úñÔ∏è Clear Working Directory',
                workingDirSet: '‚úì ',
                workingDirCleared: 'Working directory cleared',
                
                // Files
                file1Source: 'üìÑ File 1 (Source)',
                file2Target: 'üìÑ File 2 (Target)',
                loadSourceFile: 'üìÇ Load Source File',
                loadTargetFile: 'üìÇ Load Target File',
                noFileLoaded: 'No file loaded',
                worksheet: 'Worksheet:',
                loadFileFirst: '-- Load file first --',
                
                // Mapping
                columnMapping: 'üîó Column Mapping',
                configureColumns: '‚öôÔ∏è Configure Columns',
                loadBothFiles: 'Load both files',
                columnsConfigured: 'column(s) configured',
                
                // Template
                monthTemplate: 'üìÑ Month Template',
                loadTemplate: 'üìÇ Load Template',
                createTemplateFromSource: 'üîß Template from Source',
                noTemplateLoaded: 'No template loaded',
                templateHint: 'Empty Excel template for "üìÖ New Month File"',
                createTemplateTitle: 'üîß Create Template from Source',
                createTemplateDesc: 'Creates an empty template with all formatting and conditional formatting from the source file.',
                sourceFileLabel: 'Source file:',
                selectSheets: 'Select worksheets:',
                loadSourceFirst: 'Load a source file first',
                selectAll: '‚úì Select all',
                deselectAll: '‚úó Deselect all',
                templateInfoText: 'üí° The header row is kept, all data rows are deleted. CF rules are extended to entire columns.',
                createAndSave: 'üîß Create & save template',
                templateCreated: 'Template created successfully',
                sheetsProcessed: 'Worksheets processed',
                cfRulesPreserved: 'CF rules preserved',
                extraColumnsInTemplate: 'Create extra columns in template:',
                flagColumn: 'Flag column (A)',
                commentColumn: 'Comment column (B)',
                extraColumnsHint: 'Enable if these options are used in "Configure columns".',
                
                // History
                lastTransfers: 'üìã Recent Transfers',
                noTransfersYet: 'No transfers yet',
                
                // Search
                searchPlaceholder: 'Search... (Wildcards: * = any, ? = one character)',
                search: 'üîç Search',
                newRow: '‚ûï New Row',
                
                // Results
                readyToStart: 'Ready to Start',
                instructions: '1. Load the source file (File 1)<br>2. Load the target file (File 2)<br>3. Configure the column mapping<br>4. Search for rows and transfer them',
                noResults: 'No results for',
                results: 'results for',
                
                // Transfer
                prepareTransfer: 'üì§ Prepare row(s) for transfer',
                selected: 'selected',
                flag: 'Column 1 - Flag:',
                comment: 'Column 2 - Comment:',
                commentPlaceholder: 'Free text...',
                addToQueue: '‚ûï Add to Queue',
                transferDirect: '‚û°Ô∏è Transfer Directly',
                selectAll: '‚òëÔ∏è Select All',
                deselectAll: '‚òê Deselect All',
                
                // Queue
                queue: 'üìã Queue',
                rows: 'rows',
                clear: 'üóëÔ∏è Clear',
                directTransfer: '‚úÖ Transfer Directly',
                dataExplorer: 'Data Explorer',
                newMonthFile: 'üìÖ New Month File',
                noRowsInQueue: 'No rows in queue',
                
                // New Row
                createNewRow: '‚úèÔ∏è Create New Row',
                close: '‚úï Close',
                toQueue: '‚ûï To Queue',
                transferDirectly: '‚û°Ô∏è Transfer Directly',
                
                // Messages
                noTargetFile: 'No target file loaded',
                selectAtLeastOne: 'Please select at least one row',
                rowsTransferred: 'row(s) transferred directly!',
                rowsAdded: 'row(s) added to queue',
                edited: 'edited',
                duplicates: 'duplicate(s)',
                configFirst: 'Please configure columns first',
                
                // Data Explorer
                explorerTitle: 'Data Explorer',
                noFileLoadedExplorer: 'No file loaded',
                openFile: 'üìÇ Open File',
                fullTextSearch: 'Full-text search:',
                searchPlaceholderExplorer: 'Enter search term...',
                columns: 'üëÅÔ∏è Columns',
                exportXlsx: 'üìä Export as XLSX',
                saveFile: 'üíæ Save',
                filter: 'üîç Filter',
                addFilter: '‚ûï Add Filter',
                resetFilters: 'üóëÔ∏è Reset Filters',
                showAll: 'Show all',
                hideAll: 'Hide all',
                noDataLoaded: 'No data loaded.',
                pleaseLoadFile: 'üìÇ Please load an Excel file',
                contains: 'contains',
                equals: 'equals',
                startsWith: 'starts with',
                endsWith: 'ends with',
                selectColumn: 'Select column',
                filterValue: 'Filter value',
                
                // New Month Modal
                createNewMonthFile: 'üìÖ Create New Month File',
                newMonthDescription: 'Creates a copy of the template file with a new name and sets it as File 2.',
                newFilename: 'New filename:',
                filenamePlaceholder: 'e.g. ContractList_2025-01.xlsx',
                templateLabel: 'üí° Template:',
                cancel: 'Cancel',
                createAndLoad: 'üìÖ Create & Load',
                
                // Footer
                copyright: '¬© Norbert Jander 2025 ¬∑ v1.0.10',
                
                // Extra Columns
                extraColumns: 'Extra Columns',
                enableFlag: 'Flag Column (A/D/C)',
                enableComment: 'Comment Column',
                
                // License
                license: 'License',
                licenseTitle: 'License Information',
                thirdPartyLicenses: 'Third-Party Licenses',
                thirdPartyDesc: 'Excel Data Sync Pro uses the following open-source libraries:',
                allLicensesMIT: 'All libraries used are licensed under the MIT License or compatible open-source licenses.',
                packagesTotal: 'packages total'
            }
        };
        
        let currentLanguage = localStorage.getItem('excelSyncLanguage') || 'de';
        let currentTheme = localStorage.getItem('excelSyncTheme') || 'dark';
        
        function t(key) {
            return translations[currentLanguage]?.[key] || translations['de'][key] || key;
        }
        
        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('excelSyncLanguage', lang);
            applyTranslations();
        }
        
        function setTheme(theme) {
            currentTheme = theme;
            localStorage.setItem('excelSyncTheme', theme);
            if (theme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        }
        
        function applyTranslations() {
            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const text = t(key);
                if (el.tagName === 'INPUT' && el.type === 'text') {
                    el.placeholder = text;
                } else if (el.tagName === 'OPTION') {
                    el.textContent = text;
                } else {
                    // Keep existing content if it's a dynamic element (like file info)
                    const dynamicElements = ['file1Info', 'file2Info', 'templateInfo', 'mappingInfo'];
                    if (!dynamicElements.includes(el.id)) {
                        el.innerHTML = text;
                    }
                }
            });
            
            // Header
            document.querySelector('.logo span').textContent = t('appTitle');
            document.getElementById('btnImportConfig').innerHTML = t('loadConfig');
            document.getElementById('btnExportConfig').innerHTML = t('saveConfig');
            document.getElementById('btnHelp').innerHTML = t('help');
            document.querySelector('.sidebar-header-text').textContent = t('configuration');
            
            // Search section
            document.getElementById('searchInput').placeholder = t('searchPlaceholder');
            document.getElementById('btnSearch').innerHTML = t('search');
            document.getElementById('btnNewRow').innerHTML = t('newRow');
            
            // Empty state
            document.querySelector('.empty-state-title').textContent = t('readyToStart');
            document.querySelector('.empty-state-text').innerHTML = t('instructions');
            
            // Footer
            document.querySelector('footer').innerHTML = t('copyright');
            
            // Queue panel
            document.getElementById('btnClearQueue').innerHTML = t('clear');
            document.getElementById('btnDataExplorer').innerHTML = 'üìä ' + t('dataExplorer');
            document.getElementById('btnNewMonth').innerHTML = t('newMonthFile');
            
            // Transfer panel
            document.getElementById('btnAddToQueue').innerHTML = t('addToQueue');
            document.getElementById('btnTransferDirect').innerHTML = t('transferDirect');
            document.getElementById('btnSelectAll').innerHTML = t('selectAll');
            document.getElementById('btnDeselectAll').innerHTML = t('deselectAll');
            
            // Theme dropdown options
            const darkOpt = document.querySelector('#selectTheme option[value="dark"]');
            const lightOpt = document.querySelector('#selectTheme option[value="light"]');
            if (darkOpt) darkOpt.textContent = t('themeDark');
            if (lightOpt) lightOpt.textContent = t('themeLight');
            
            // Sidebar buttons
            const btnLoadFile1 = document.getElementById('btnLoadFile1');
            const btnLoadFile2 = document.getElementById('btnLoadFile2');
            const btnConfigMapping = document.getElementById('btnConfigMapping');
            const btnLoadTemplate = document.getElementById('btnLoadTemplate');
            if (btnLoadFile1) btnLoadFile1.innerHTML = t('loadSourceFile');
            if (btnLoadFile2) btnLoadFile2.innerHTML = t('loadTargetFile');
            if (btnConfigMapping) btnConfigMapping.innerHTML = t('configureColumns');
            if (btnLoadTemplate) btnLoadTemplate.innerHTML = t('loadTemplate');
            
            // New row panel
            const newRowTitle = document.querySelector('.new-row-title');
            const btnCloseNewRow = document.getElementById('btnCloseNewRow');
            const btnAddNewRowToQueue = document.getElementById('btnAddNewRowToQueue');
            const btnTransferNewRowDirect = document.getElementById('btnTransferNewRowDirect');
            if (newRowTitle) newRowTitle.textContent = t('createNewRow');
            if (btnCloseNewRow) btnCloseNewRow.innerHTML = t('close');
            if (btnAddNewRowToQueue) btnAddNewRowToQueue.innerHTML = t('toQueue');
            if (btnTransferNewRowDirect) btnTransferNewRowDirect.innerHTML = t('transferDirectly');
            
            // Data Explorer Modal
            const explorerTitle = document.querySelector('#dataExplorerModal .modal-title');
            if (explorerTitle) {
                // Nur den Text vor dem Span aktualisieren, nicht das ganze HTML ersetzen
                const fileNameSpan = document.getElementById('explorerFileName');
                const currentFileName = fileNameSpan ? fileNameSpan.textContent : t('noFileLoadedExplorer');
                // Verwende einen TextNode f√ºr den Titel-Prefix
                explorerTitle.childNodes[0].textContent = `üìä ${t('explorerTitle')} - `;
                // Falls der Span nicht existiert oder entfernt wurde, neu erstellen
                if (!explorerTitle.querySelector('#explorerFileName')) {
                    const newSpan = document.createElement('span');
                    newSpan.id = 'explorerFileName';
                    newSpan.textContent = currentFileName;
                    explorerTitle.appendChild(newSpan);
                }
            }
            const btnExplorerOpenFile = document.getElementById('btnExplorerOpenFile');
            const btnToggleColumns = document.getElementById('btnToggleColumns');
            const btnExplorerExport = document.getElementById('btnExplorerExport');
            const btnExplorerSave = document.getElementById('btnExplorerSave');
            const btnAddExplorerFilter = document.getElementById('btnAddExplorerFilter');
            const btnClearExplorerFilters = document.getElementById('btnClearExplorerFilters');
            const btnShowAllColumns = document.getElementById('btnShowAllColumns');
            const btnHideAllColumns = document.getElementById('btnHideAllColumns');
            const btnCloseExplorerFooter = document.getElementById('btnCloseExplorerFooter');
            const explorerResultCount = document.getElementById('explorerResultCount');
            const explorerSearch = document.getElementById('explorerSearch');
            
            if (btnExplorerOpenFile) btnExplorerOpenFile.innerHTML = t('openFile');
            if (btnToggleColumns) btnToggleColumns.innerHTML = t('columns');
            if (btnExplorerExport) btnExplorerExport.innerHTML = t('exportXlsx');
            if (btnExplorerSave) btnExplorerSave.innerHTML = t('saveFile');
            if (btnAddExplorerFilter) btnAddExplorerFilter.innerHTML = t('addFilter');
            if (btnClearExplorerFilters) btnClearExplorerFilters.innerHTML = t('resetFilters');
            if (btnShowAllColumns) btnShowAllColumns.textContent = t('showAll');
            if (btnHideAllColumns) btnHideAllColumns.textContent = t('hideAll');
            if (btnCloseExplorerFooter) btnCloseExplorerFooter.textContent = t('close');
            if (explorerResultCount && (explorerResultCount.textContent === 'Keine Daten geladen.' || explorerResultCount.textContent === 'No data loaded.')) {
                explorerResultCount.textContent = t('noDataLoaded');
            }
            if (explorerSearch) explorerSearch.placeholder = t('searchPlaceholderExplorer');
            
            // Explorer filter section label
            const filterLabel = document.querySelector('#explorerFilterControls > div > span');
            if (filterLabel) filterLabel.textContent = t('filter');
            
            // Explorer worksheet label and full-text search label
            const worksheetLabels = document.querySelectorAll('#dataExplorerModal .transfer-field label');
            worksheetLabels.forEach(label => {
                if (label.textContent === 'Arbeitsblatt:' || label.textContent === 'Worksheet:') {
                    label.textContent = t('worksheet');
                }
                if (label.textContent === 'Volltextsuche:' || label.textContent === 'Full-text search:') {
                    label.textContent = t('fullTextSearch');
                }
            });
            
            // Explorer filter operator options
            document.querySelectorAll('#explorerFilters .filter-operator').forEach(select => {
                const options = select.querySelectorAll('option');
                options.forEach(opt => {
                    if (opt.value === 'contains') opt.textContent = t('contains');
                    if (opt.value === 'equals') opt.textContent = t('equals');
                    if (opt.value === 'startsWith') opt.textContent = t('startsWith');
                    if (opt.value === 'endsWith') opt.textContent = t('endsWith');
                });
            });
            
            // New Month Modal
            const newMonthTitle = document.querySelector('#newMonthModal .modal-title');
            const newMonthDesc = document.querySelector('#newMonthModal .modal-body > p:first-of-type');
            const newMonthLabel = document.querySelector('#newMonthModal .config-label');
            const newMonthFilename = document.getElementById('newMonthFilename');
            const newMonthTemplateLabel = document.querySelector('#newMonthModal .modal-body > p:last-of-type');
            const btnCancelNewMonth = document.getElementById('btnCancelNewMonth');
            const btnConfirmNewMonth = document.getElementById('btnConfirmNewMonth');
            
            if (newMonthTitle) newMonthTitle.textContent = t('createNewMonthFile');
            if (newMonthDesc) newMonthDesc.textContent = t('newMonthDescription');
            if (newMonthLabel) newMonthLabel.textContent = t('newFilename');
            if (newMonthFilename) newMonthFilename.placeholder = t('filenamePlaceholder');
            if (newMonthTemplateLabel) {
                const templateName = document.getElementById('newMonthTemplateName');
                newMonthTemplateLabel.innerHTML = `${t('templateLabel')} <strong id="newMonthTemplateName">${templateName ? templateName.textContent : '-'}</strong>`; 
            }
            if (btnCancelNewMonth) btnCancelNewMonth.textContent = t('cancel');
            if (btnConfirmNewMonth) btnConfirmNewMonth.innerHTML = t('createAndLoad');
        }
        
        // ==================== JSDoc Type Definitions ====================
        /**
         * @typedef {Object} FileState
         * @property {string|null} name - File name
         * @property {Object|null} workbook - Workbook object
         * @property {string[]} sheets - List of sheet names
         * @property {string|null} selectedSheet - Currently selected sheet
         * @property {Array<Array<string|number>>} data - Sheet data
         * @property {string[]} headers - Column headers
         * @property {string|null} filePath - Full file path
         */

        /**
         * @typedef {Object} MappingConfig
         * @property {number[]} sourceColumns - Source column indices to copy
         * @property {number} targetStartColumn - Target start column (default 1)
         * @property {number} duplicateCheckColumn - Column index for duplicate check
         */

        /**
         * @typedef {Object} TransferQueueItem
         * @property {Array<string|number>} data - Row data array
         * @property {string} flag - Flag value (A/D/C or empty)
         * @property {string} comment - Comment text
         * @property {string} checkValue - Value used for duplicate checking
         * @property {boolean} [wasEdited] - Whether the row was edited
         */

        /**
         * @typedef {Object} TemplateState
         * @property {string|null} name - Template file name
         * @property {Object|null} data - Template data
         * @property {string|null} filePath - Template file path
         */

        /**
         * @typedef {Object} PaginationState
         * @property {number} currentPage - Current page number (1-based)
         * @property {number} pageSize - Items per page
         * @property {number[]} pageSizeOptions - Available page size options
         */

        /**
         * @typedef {Object} AppState
         * @property {FileState} file1 - Source file state
         * @property {FileState} file2 - Target file state
         * @property {MappingConfig} mapping - Column mapping configuration
         * @property {number|null} selectedRow - Currently selected row index
         * @property {number[]} selectedRows - Array of selected row indices
         * @property {Array<Array<string|number>>} searchResults - Search results
         * @property {Array<Object>} history - Transfer history
         * @property {TransferQueueItem[]} transferQueue - Items queued for transfer
         * @property {TemplateState} template - Template file state
         * @property {Object|null} lastDirectoryHandle - Last used directory handle
         * @property {PaginationState} searchPagination - Search results pagination
         */

        // ==================== Undo/Redo System ====================
        const undoRedoState = {
            // Suchergebnisse
            searchUndoStack: [],
            searchRedoStack: [],
            // Datenexplorer
            explorerUndoStack: [],
            explorerRedoStack: [],
            maxStackSize: 50
        };
        
        function pushSearchUndo(action) {
            undoRedoState.searchUndoStack.push(action);
            if (undoRedoState.searchUndoStack.length > undoRedoState.maxStackSize) {
                undoRedoState.searchUndoStack.shift();
            }
            undoRedoState.searchRedoStack = []; // Redo-Stack leeren bei neuer Aktion
        }
        
        function pushExplorerUndo(action) {
            undoRedoState.explorerUndoStack.push(action);
            if (undoRedoState.explorerUndoStack.length > undoRedoState.maxStackSize) {
                undoRedoState.explorerUndoStack.shift();
            }
            undoRedoState.explorerRedoStack = []; // Redo-Stack leeren bei neuer Aktion
        }
        
        function undoSearch() {
            if (undoRedoState.searchUndoStack.length === 0) return false;
            
            const action = undoRedoState.searchUndoStack.pop();
            undoRedoState.searchRedoStack.push(action);
            
            // Urspr√ºnglichen Wert wiederherstellen
            const { rowIndex, colIndex, oldValue, newValue } = action;
            state.searchResults[rowIndex].data[colIndex] = oldValue;
            
            // UI aktualisieren
            const cell = document.querySelector(`#resultsTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
            if (cell) {
                cell.textContent = oldValue;
                cell.classList.toggle('edited', oldValue !== cell.dataset.original);
            }
            return true;
        }
        
        function redoSearch() {
            if (undoRedoState.searchRedoStack.length === 0) return false;
            
            const action = undoRedoState.searchRedoStack.pop();
            undoRedoState.searchUndoStack.push(action);
            
            // Neuen Wert wiederherstellen
            const { rowIndex, colIndex, oldValue, newValue } = action;
            state.searchResults[rowIndex].data[colIndex] = newValue;
            
            // UI aktualisieren
            const cell = document.querySelector(`#resultsTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
            if (cell) {
                cell.textContent = newValue;
                cell.classList.toggle('edited', newValue !== cell.dataset.original);
            }
            return true;
        }
        
        function undoExplorer() {
            if (undoRedoState.explorerUndoStack.length === 0) return false;
            
            const action = undoRedoState.explorerUndoStack.pop();
            undoRedoState.explorerRedoStack.push(action);
            
            // Pr√ºfe auf moveRows Aktion
            if (action.type === 'moveRows') {
                // Stelle den vorherigen Zustand wieder her
                explorerState.data = JSON.parse(JSON.stringify(action.previousData));
                explorerState.originalData = JSON.parse(JSON.stringify(action.previousOriginalData));
                
                // FilteredData neu erstellen
                explorerState.filteredData = explorerState.data.map((row, idx) => ({
                    row: row,
                    originalIndex: idx
                }));
                
                // Suchfilter erneut anwenden wenn aktiv
                const searchTerm = elements.explorerSearch?.value?.trim().toLowerCase();
                if (searchTerm) {
                    explorerState.filteredData = explorerState.filteredData.filter(item => 
                        item.row.some(cell => String(cell ?? '').toLowerCase().includes(searchTerm))
                    );
                }
                
                // Tabelle neu rendern
                renderExplorerTable();
                showNotification('Zeilen-Verschiebung r√ºckg√§ngig gemacht', 'info');
                return true;
            }
            
            // Pr√ºfe auf Multi-Aktion (mehrere Zellen gleichzeitig)
            if (action.type === 'multi') {
                action.actions.forEach(subAction => {
                    const { rowIndex, colIndex, oldValue, originalValue } = subAction;
                    explorerState.data[rowIndex][colIndex] = oldValue;
                    
                    const cellKey = `${rowIndex}-${colIndex}`;
                    if (oldValue === originalValue) {
                        explorerState.editedCells.delete(cellKey);
                    } else {
                        explorerState.editedCells.set(cellKey, oldValue);
                    }
                    
                    // UI aktualisieren
                    const cell = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                    if (cell) {
                        cell.textContent = oldValue;
                        cell.dataset.lastValue = oldValue;
                        cell.classList.toggle('edited', oldValue !== cell.dataset.original);
                    }
                });
                updateExplorerEditStatus();
                showNotification(`${action.actions.length} Zelle(n) wiederhergestellt`, 'info');
                return true;
            }
            
            // Urspr√ºnglichen Wert wiederherstellen (Standard-Zellbearbeitung)
            const { rowIndex, colIndex, oldValue, newValue } = action;
            explorerState.data[rowIndex][colIndex] = oldValue;
            
            const cellKey = `${rowIndex}-${colIndex}`;
            if (oldValue === action.originalValue) {
                explorerState.editedCells.delete(cellKey);
            } else {
                explorerState.editedCells.set(cellKey, oldValue);
            }
            
            // UI aktualisieren
            const cell = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
            if (cell) {
                cell.textContent = oldValue;
                cell.classList.toggle('edited', oldValue !== cell.dataset.original);
            }
            updateExplorerEditStatus();
            return true;
        }
        
        function redoExplorer() {
            if (undoRedoState.explorerRedoStack.length === 0) return false;
            
            const action = undoRedoState.explorerRedoStack.pop();
            undoRedoState.explorerUndoStack.push(action);
            
            // Pr√ºfe auf moveRows Aktion
            if (action.type === 'moveRows') {
                // F√ºhre die Verschiebung erneut aus
                const selectedIndices = action.movedIndices;
                const targetRow = action.targetRow;
                const movePosition = action.movePosition;
                let targetIndex = targetRow - 1;
                
                // Extrahiere die Zeilen
                const rowsToMove = [];
                const sortedDescending = [...selectedIndices].sort((a, b) => b - a);
                sortedDescending.forEach(idx => {
                    rowsToMove.unshift({
                        data: explorerState.data[idx],
                        original: explorerState.originalData[idx]
                    });
                });
                
                // Entferne die Zeilen
                sortedDescending.forEach(idx => {
                    explorerState.data.splice(idx, 1);
                    explorerState.originalData.splice(idx, 1);
                });
                
                // Berechne neuen Zielindex
                let newTargetIndex = targetIndex;
                selectedIndices.forEach(idx => {
                    if (idx < targetIndex) {
                        newTargetIndex--;
                    }
                });
                
                if (movePosition === 'after') {
                    newTargetIndex++;
                }
                
                // F√ºge die Zeilen ein
                rowsToMove.forEach((row, i) => {
                    explorerState.data.splice(newTargetIndex + i, 0, row.data);
                    explorerState.originalData.splice(newTargetIndex + i, 0, row.original);
                });
                
                // FilteredData neu erstellen
                explorerState.filteredData = explorerState.data.map((row, idx) => ({
                    row: row,
                    originalIndex: idx
                }));
                
                // Suchfilter erneut anwenden wenn aktiv
                const searchTerm = elements.explorerSearch?.value?.trim().toLowerCase();
                if (searchTerm) {
                    explorerState.filteredData = explorerState.filteredData.filter(item => 
                        item.row.some(cell => String(cell ?? '').toLowerCase().includes(searchTerm))
                    );
                }
                
                renderExplorerTable();
                showNotification('Zeilen-Verschiebung wiederhergestellt', 'info');
                return true;
            }
            
            // Pr√ºfe auf Multi-Aktion (mehrere Zellen gleichzeitig)
            if (action.type === 'multi') {
                action.actions.forEach(subAction => {
                    const { rowIndex, colIndex, newValue, originalValue } = subAction;
                    explorerState.data[rowIndex][colIndex] = newValue;
                    
                    const cellKey = `${rowIndex}-${colIndex}`;
                    if (newValue === originalValue) {
                        explorerState.editedCells.delete(cellKey);
                    } else {
                        explorerState.editedCells.set(cellKey, newValue);
                    }
                    
                    // UI aktualisieren
                    const cell = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                    if (cell) {
                        cell.textContent = newValue;
                        cell.dataset.lastValue = newValue;
                        cell.classList.toggle('edited', newValue !== cell.dataset.original);
                    }
                });
                updateExplorerEditStatus();
                showNotification(`${action.actions.length} Zelle(n) gel√∂scht`, 'info');
                return true;
            }
            
            // Neuen Wert wiederherstellen (Standard-Zellbearbeitung)
            const { rowIndex, colIndex, oldValue, newValue, originalValue } = action;
            explorerState.data[rowIndex][colIndex] = newValue;
            
            const cellKey = `${rowIndex}-${colIndex}`;
            if (newValue === originalValue) {
                explorerState.editedCells.delete(cellKey);
            } else {
                explorerState.editedCells.set(cellKey, newValue);
            }
            
            // UI aktualisieren
            const cell = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
            if (cell) {
                cell.textContent = newValue;
                cell.classList.toggle('edited', newValue !== cell.dataset.original);
            }
            updateExplorerEditStatus();
            return true;
        }
        
        function showUndoRedoFeedback(action) {
            // Kurzes visuelles Feedback
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--bg-lighter);
                color: var(--text);
                padding: 8px 16px;
                border-radius: 4px;
                font-size: 13px;
                z-index: 10000;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                animation: fadeInOut 1.5s ease-in-out;
            `;
            toast.textContent = action;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 1500);
        }
        
        // CSS f√ºr Toast-Animation hinzuf√ºgen
        const undoRedoStyle = document.createElement('style');
        undoRedoStyle.textContent = `
            @keyframes fadeInOut {
                0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
                20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                80% { opacity: 1; transform: translateX(-50%) translateY(0); }
                100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            }
        `;
        document.head.appendChild(undoRedoStyle);

        // ==================== Auto-Save System ====================
        const AUTO_SAVE_KEY = 'excelsync_autosave';
        const AUTO_SAVE_INTERVAL = 30000; // 30 Sekunden
        let autoSaveTimer = null;
        
        function getAutoSaveData() {
            // Sammle alle bearbeiteten Daten
            const data = {
                timestamp: Date.now(),
                version: '1.1',
                // Quelldatei (Datei 1)
                file1: {
                    filePath: state.file1.filePath || null,
                    name: state.file1.name || null,
                    selectedSheet: state.file1.selectedSheet || null
                },
                // Zieldatei (Datei 2)
                file2: {
                    filePath: state.file2.filePath || null,
                    name: state.file2.name || null,
                    selectedSheet: state.file2.selectedSheet || null
                },
                // Mapping
                mapping: state.mapping,
                // Datenexplorer
                explorer: {
                    filePath: explorerState.filePath,
                    fileName: explorerState.fileName,
                    selectedSheet: explorerState.selectedSheet,
                    editedCells: Array.from(explorerState.editedCells.entries())
                },
                // Warteschlange
                transferQueue: state.transferQueue,
                // Suchergebnisse-Bearbeitungen (nur wenn Suche aktiv)
                searchEdits: []
            };
            
            // Suchergebnis-Bearbeitungen sammeln
            document.querySelectorAll('#resultsTableBody td.edited').forEach(td => {
                data.searchEdits.push({
                    row: parseInt(td.dataset.row),
                    col: parseInt(td.dataset.col),
                    original: td.dataset.original,
                    current: td.textContent
                });
            });
            
            return data;
        }
        
        function autoSave() {
            const data = getAutoSaveData();
            
            // Nur speichern wenn es etwas zu speichern gibt
            const hasExplorerEdits = data.explorer.editedCells.length > 0;
            const hasQueueItems = data.transferQueue.length > 0;
            const hasSearchEdits = data.searchEdits.length > 0;
            
            if (hasExplorerEdits || hasQueueItems || hasSearchEdits) {
                try {
                    localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify(data));
                    console.log('Auto-Save: Daten gesichert', {
                        explorerEdits: data.explorer.editedCells.length,
                        queueItems: data.transferQueue.length,
                        searchEdits: data.searchEdits.length
                    });
                } catch (e) {
                    console.warn('Auto-Save fehlgeschlagen:', e);
                }
            }
        }
        
        function clearAutoSave() {
            localStorage.removeItem(AUTO_SAVE_KEY);
        }
        
        async function checkAutoSaveRecovery() {
            try {
                const saved = localStorage.getItem(AUTO_SAVE_KEY);
                if (!saved) return;
                
                const data = JSON.parse(saved);
                const age = Date.now() - data.timestamp;
                const ageMinutes = Math.round(age / 60000);
                
                // Nur wiederherstellen wenn weniger als 24 Stunden alt
                if (age > 24 * 60 * 60 * 1000) {
                    clearAutoSave();
                    return;
                }
                
                const hasExplorerEdits = data.explorer?.editedCells?.length > 0;
                const hasQueueItems = data.transferQueue?.length > 0;
                const hasSearchEdits = data.searchEdits?.length > 0;
                const hasFile1 = data.file1?.filePath;
                const hasFile2 = data.file2?.filePath;
                
                if (!hasExplorerEdits && !hasQueueItems && !hasSearchEdits && !hasFile1 && !hasFile2) {
                    clearAutoSave();
                    return;
                }
                
                // Zusammenfassung erstellen
                let summary = 'Ungespeicherte Daten gefunden:\n\n';
                if (hasFile1) {
                    summary += `‚Ä¢ Quelldatei: ${data.file1.name || data.file1.filePath}\n`;
                }
                if (hasFile2) {
                    summary += `‚Ä¢ Zieldatei: ${data.file2.name || data.file2.filePath}\n`;
                }
                if (hasQueueItems) {
                    summary += `‚Ä¢ ${data.transferQueue.length} Eintr√§ge in der Warteschlange\n`;
                }
                if (hasExplorerEdits) {
                    summary += `‚Ä¢ ${data.explorer.editedCells.length} bearbeitete Zellen im Datenexplorer\n`;
                    if (data.explorer.fileName) {
                        summary += `  (Datei: ${data.explorer.fileName})\n`;
                    }
                }
                if (hasSearchEdits) {
                    summary += `‚Ä¢ ${data.searchEdits.length} bearbeitete Suchergebnisse\n`;
                }
                summary += `\nGespeichert vor ${ageMinutes} Minuten.\n\nM√∂chten Sie diese Daten wiederherstellen?`;
                
                if (confirm(summary)) {
                    await restoreAutoSave(data);
                } else {
                    clearAutoSave();
                }
            } catch (e) {
                console.warn('Auto-Save Recovery fehlgeschlagen:', e);
                clearAutoSave();
            }
        }
        
        async function restoreAutoSave(data) {
            console.log('[Auto-Save] Starte Wiederherstellung...', data);
            
            // Mapping wiederherstellen (vor den Dateien, da es f√ºr die Anzeige ben√∂tigt wird)
            if (data.mapping) {
                state.mapping = data.mapping;
                updateMappingPreview();
            }
            
            // Quelldatei wiederherstellen
            if (data.file1?.filePath) {
                try {
                    console.log('[Auto-Save] Lade Quelldatei:', data.file1.filePath);
                    const result = await window.electronAPI.readExcelFile(data.file1.filePath);
                    if (result.success) {
                        state.file1.name = result.fileName;
                        state.file1.filePath = data.file1.filePath;
                        state.file1.sheets = result.sheets;
                        state.file1.workbook = { SheetNames: result.sheets };
                        
                        elements.selectSheet1.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
                        elements.selectSheet1.disabled = false;
                        elements.file1Info.textContent = `‚úì ${result.fileName}`;
                        elements.file1Info.classList.add('loaded');
                        
                        const sheetToLoad = data.file1.selectedSheet || result.sheets[0];
                        elements.selectSheet1.value = sheetToLoad;
                        await loadSheet1Electron(sheetToLoad);
                        console.log('[Auto-Save] Quelldatei wiederhergestellt');
                    }
                } catch (e) {
                    console.warn('[Auto-Save] Quelldatei konnte nicht geladen werden:', e);
                }
            }
            
            // Zieldatei wiederherstellen
            if (data.file2?.filePath) {
                try {
                    console.log('[Auto-Save] Lade Zieldatei:', data.file2.filePath);
                    const result = await window.electronAPI.readExcelFile(data.file2.filePath);
                    if (result.success) {
                        state.file2.name = result.fileName;
                        state.file2.filePath = data.file2.filePath;
                        state.file2.sheets = result.sheets;
                        state.file2.workbook = { SheetNames: result.sheets };
                        
                        elements.selectSheet2.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
                        elements.selectSheet2.disabled = false;
                        elements.file2Info.textContent = `‚úì ${result.fileName}`;
                        elements.file2Info.classList.add('loaded');
                        
                        const sheetToLoad = data.file2.selectedSheet || result.sheets[0];
                        elements.selectSheet2.value = sheetToLoad;
                        await loadSheet2Electron(sheetToLoad);
                        console.log('[Auto-Save] Zieldatei wiederhergestellt');
                    }
                } catch (e) {
                    console.warn('[Auto-Save] Zieldatei konnte nicht geladen werden:', e);
                }
            }
            
            // Warteschlange wiederherstellen
            if (data.transferQueue?.length > 0) {
                state.transferQueue = data.transferQueue;
                updateQueueDisplay();
                showUndoRedoFeedback(`${data.transferQueue.length} Eintr√§ge wiederhergestellt`);
            }
            
            // Datenexplorer-Bearbeitungen werden beim √ñffnen der Datei wiederhergestellt
            if (data.explorer?.editedCells?.length > 0 && data.explorer.filePath) {
                // Speichere f√ºr sp√§tere Wiederherstellung
                window._pendingExplorerRestore = data.explorer;
            }
            
            // Button-Status nochmal aktualisieren (nach allen async Operationen)
            updateQueueDisplay();
            
            console.log('[Auto-Save] Wiederherstellung abgeschlossen. file2.filePath:', state.file2.filePath);
            
            // Auto-Save nach Wiederherstellung nicht l√∂schen (wird bei n√§chster Aktion √ºberschrieben)
        }
        
        function startAutoSave() {
            if (autoSaveTimer) clearInterval(autoSaveTimer);
            autoSaveTimer = setInterval(autoSave, AUTO_SAVE_INTERVAL);
        }
        
        function stopAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        }

        // ==================== Such-Historie System ====================
        const SEARCH_HISTORY_KEY = 'excelsync_search_history';
        const SEARCH_HISTORY_MAX = 15;
        let searchHistorySelectedIndex = -1;
        
        function getSearchHistory() {
            try {
                const saved = localStorage.getItem(SEARCH_HISTORY_KEY);
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                return [];
            }
        }
        
        function saveSearchHistory(history) {
            try {
                localStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(history));
            } catch (e) {
                console.warn('Such-Historie speichern fehlgeschlagen:', e);
            }
        }
        
        function addToSearchHistory(term, resultCount) {
            if (!term || term.trim().length === 0) return;
            
            const trimmed = term.trim();
            let history = getSearchHistory();
            
            // Existierenden Eintrag entfernen (wird oben neu eingef√ºgt)
            history = history.filter(item => item.term.toLowerCase() !== trimmed.toLowerCase());
            
            // Neuen Eintrag am Anfang einf√ºgen
            history.unshift({
                term: trimmed,
                count: resultCount,
                timestamp: Date.now()
            });
            
            // Auf Maximum begrenzen
            if (history.length > SEARCH_HISTORY_MAX) {
                history = history.slice(0, SEARCH_HISTORY_MAX);
            }
            
            saveSearchHistory(history);
        }
        
        function removeFromSearchHistory(term) {
            let history = getSearchHistory();
            history = history.filter(item => item.term !== term);
            saveSearchHistory(history);
            renderSearchHistoryDropdown();
        }
        
        function clearSearchHistory() {
            localStorage.removeItem(SEARCH_HISTORY_KEY);
            renderSearchHistoryDropdown();
            hideSearchHistoryDropdown();
        }
        
        function renderSearchHistoryDropdown(filterText = '') {
            const dropdown = document.getElementById('searchHistoryDropdown');
            if (!dropdown) return;
            
            let history = getSearchHistory();
            
            // Nach Filter filtern
            if (filterText) {
                const lower = filterText.toLowerCase();
                history = history.filter(item => item.term.toLowerCase().includes(lower));
            }
            
            if (history.length === 0) {
                dropdown.innerHTML = '';
                dropdown.classList.remove('show');
                return;
            }
            
            let html = `
                <div class="search-history-header">
                    <span>üïê Letzte Suchen</span>
                    <button class="search-history-clear" onclick="clearSearchHistory()">Alle l√∂schen</button>
                </div>
            `;
            
            history.forEach((item, index) => {
                const selected = index === searchHistorySelectedIndex ? ' selected' : '';
                html += `
                    <div class="search-history-item${selected}" 
                         data-index="${index}"
                         data-term="${escapeHtml(item.term)}">
                        <span class="search-history-text">${escapeHtml(item.term)}</span>
                        <span class="search-history-count">${item.count} Treffer</span>
                        <button class="search-history-delete" 
                                onclick="event.stopPropagation(); removeFromSearchHistory('${escapeHtml(item.term).replace(/'/g, "\\'")}')">‚úï</button>
                    </div>
                `;
            });
            
            dropdown.innerHTML = html;
            
            // Click-Handler f√ºr Items
            dropdown.querySelectorAll('.search-history-item').forEach(item => {
                item.addEventListener('click', () => {
                    const term = item.dataset.term;
                    elements.searchInput.value = term;
                    hideSearchHistoryDropdown();
                    performSearch();
                });
            });
        }
        
        function showSearchHistoryDropdown() {
            const dropdown = document.getElementById('searchHistoryDropdown');
            const history = getSearchHistory();
            
            if (history.length === 0) return;
            
            searchHistorySelectedIndex = -1;
            renderSearchHistoryDropdown(elements.searchInput.value);
            dropdown.classList.add('show');
        }
        
        function hideSearchHistoryDropdown() {
            const dropdown = document.getElementById('searchHistoryDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
            }
            searchHistorySelectedIndex = -1;
        }
        
        function navigateSearchHistory(direction) {
            const history = getSearchHistory();
            const filterText = elements.searchInput.value;
            const filtered = filterText 
                ? history.filter(item => item.term.toLowerCase().includes(filterText.toLowerCase()))
                : history;
            
            if (filtered.length === 0) return;
            
            if (direction === 'down') {
                searchHistorySelectedIndex = Math.min(searchHistorySelectedIndex + 1, filtered.length - 1);
            } else if (direction === 'up') {
                searchHistorySelectedIndex = Math.max(searchHistorySelectedIndex - 1, -1);
            }
            
            renderSearchHistoryDropdown(filterText);
            
            // Bei Auswahl den Text ins Feld setzen
            if (searchHistorySelectedIndex >= 0 && filtered[searchHistorySelectedIndex]) {
                elements.searchInput.value = filtered[searchHistorySelectedIndex].term;
            }
        }

        // ==================== State ====================
        /** @type {AppState} */
        const state = {
            file1: {
                name: null,
                workbook: null,
                sheets: [],
                selectedSheet: null,
                data: [],
                headers: [],
                filePath: null
            },
            file2: {
                name: null,
                workbook: null,
                sheets: [],
                selectedSheet: null,
                data: [],
                headers: [],
                filePath: null
            },
            mapping: {
                sourceColumns: [],
                targetStartColumn: 1,
                duplicateCheckColumn: 0
            },
            selectedRow: null,
            selectedRows: [],
            searchResults: [],
            history: [],
            transferQueue: [],
            template: {
                name: null,
                data: null
            },
            lastDirectoryHandle: null,
            // Pagination f√ºr Suchergebnisse
            searchPagination: {
                currentPage: 1,
                pageSize: 100,
                pageSizeOptions: [50, 100, 250, 500]
            },
            // Arbeitsordner
            workingDirectory: null
        };
        
        // ==================== DOM Elements ====================
        const elements = {
            // Working Directory
            btnSelectWorkingDir: document.getElementById('btnSelectWorkingDir'),
            workingDirInfo: document.getElementById('workingDirInfo'),
            btnClearWorkingDir: document.getElementById('btnClearWorkingDir'),
            
            // File 1
            btnLoadFile1: document.getElementById('btnLoadFile1'),
            fileInput1: document.getElementById('fileInput1'),
            file1Info: document.getElementById('file1Info'),
            selectSheet1: document.getElementById('selectSheet1'),
            
            // File 2
            btnLoadFile2: document.getElementById('btnLoadFile2'),
            fileInput2: document.getElementById('fileInput2'),
            file2Info: document.getElementById('file2Info'),
            selectSheet2: document.getElementById('selectSheet2'),
            
            // Mapping
            btnConfigMapping: document.getElementById('btnConfigMapping'),
            mappingInfo: document.getElementById('mappingInfo'),
            mappingModal: document.getElementById('mappingModal'),
            mappingList: document.getElementById('mappingList'),
            
            // Search
            searchInput: document.getElementById('searchInput'),
            searchHistoryDropdown: document.getElementById('searchHistoryDropdown'),
            btnSearch: document.getElementById('btnSearch'),
            btnNewRow: document.getElementById('btnNewRow'),
            searchResultsInfo: document.getElementById('searchResultsInfo'),
            
            // New Row
            newRowPanel: document.getElementById('newRowPanel'),
            newRowForm: document.getElementById('newRowForm'),
            newRowFlag: document.getElementById('newRowFlag'),
            newRowComment: document.getElementById('newRowComment'),
            btnCloseNewRow: document.getElementById('btnCloseNewRow'),
            btnAddNewRowToQueue: document.getElementById('btnAddNewRowToQueue'),
            btnTransferNewRowDirect: document.getElementById('btnTransferNewRowDirect'),
            newRowStatus: document.getElementById('newRowStatus'),
            
            // Results
            emptyState: document.getElementById('emptyState'),
            resultsTableContainer: document.getElementById('resultsTableContainer'),
            resultsTable: document.getElementById('resultsTable'),
            resultsTableHead: document.getElementById('resultsTableHead'),
            resultsTableBody: document.getElementById('resultsTableBody'),
            
            // Transfer
            transferPanel: document.getElementById('transferPanel'),
            transferFlag: document.getElementById('transferFlag'),
            transferComment: document.getElementById('transferComment'),
            btnAddToQueue: document.getElementById('btnAddToQueue'),
            btnTransferDirect: document.getElementById('btnTransferDirect'),
            btnSelectAll: document.getElementById('btnSelectAll'),
            btnDeselectAll: document.getElementById('btnDeselectAll'),
            transferStatus: document.getElementById('transferStatus'),
            
            // Queue
            queuePanel: document.getElementById('queuePanel'),
            queueList: document.getElementById('queueList'),
            queueCount: document.getElementById('queueCount'),
            btnClearQueue: document.getElementById('btnClearQueue'),
            btnExportPS: document.getElementById('btnExportPS'),
            btnPreviewTransfer: document.getElementById('btnPreviewTransfer'),
            btnNewMonth: document.getElementById('btnNewMonth'),
            btnDataExplorer: document.getElementById('btnDataExplorer'),
            
            // Diff Preview Modal
            diffPreviewModal: document.getElementById('diffPreviewModal'),
            
            // Template
            btnLoadTemplate: document.getElementById('btnLoadTemplate'),
            btnCreateTemplate: document.getElementById('btnCreateTemplate'),
            templateInput: document.getElementById('templateInput'),
            templateInfo: document.getElementById('templateInfo'),
            
            // Create Template Modal
            createTemplateModal: document.getElementById('createTemplateModal'),
            createTemplateSourceName: document.getElementById('createTemplateSourceName'),
            createTemplateSheetList: document.getElementById('createTemplateSheetList'),
            
            // New Month Modal
            newMonthModal: document.getElementById('newMonthModal'),
            newMonthFilename: document.getElementById('newMonthFilename'),
            newMonthTemplateName: document.getElementById('newMonthTemplateName'),
            
            // History
            historyList: document.getElementById('historyList'),
            
            // Config
            btnExportConfig: document.getElementById('btnExportConfig'),
            btnImportConfig: document.getElementById('btnImportConfig'),
            configInput: document.getElementById('configInput'),
            
            // Data Explorer
            dataExplorerModal: document.getElementById('dataExplorerModal'),
            explorerFileName: document.getElementById('explorerFileName'),
            explorerSheetSelect: document.getElementById('explorerSheetSelect'),
            explorerSearch: document.getElementById('explorerSearch'),
            explorerResultCount: document.getElementById('explorerResultCount'),
            explorerStatus: document.getElementById('explorerStatus'),
            explorerTableHead: document.getElementById('explorerTableHead'),
            explorerTableBody: document.getElementById('explorerTableBody'),
            btnExplorerExport: document.getElementById('btnExplorerExport'),
            btnExplorerSave: document.getElementById('btnExplorerSave'),
            btnExplorerOpenFile: document.getElementById('btnExplorerOpenFile'),
            
            // Help
            btnHelp: document.getElementById('btnHelp'),
            helpModal: document.getElementById('helpModal')
        };

        // ==================== Local Storage ====================
        const STORAGE_KEY = 'mvmcVertragslistenConfig';
        const LAST_EXPORT_KEY = 'mvmcVertragslistenLastExport';
        const DB_NAME = 'MVMCVertragsListenDB';
        const DB_VERSION = 1;
        let db = null;
        
        // ==================== Helper Functions ====================
        function showStatus(element, message, type = 'info') {
            if (!element) return;
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
            // Auto-clear after 10 seconds for success messages
            if (type === 'success') {
                setTimeout(() => {
                    if (element.querySelector('.status.success')) {
                        element.innerHTML = '';
                    }
                }, 10000);
            }
        }
        
        // Im Electron-Modus werden Datei-Downloads via electronAPI gehandhabt
        
        function updateWorkbook() {
            // Im Electron-Modus nicht ben√∂tigt - √Ñnderungen gehen direkt in die Datei
            return;
        }
        
        // Formatiert Datum und Uhrzeit f√ºr History-Eintr√§ge
        function formatHistoryDateTime() {
            const now = new Date();
            const date = now.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: '2-digit' });
            const time = now.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            return `${date} ${time}`;
        }
        
        function updateHistoryDisplay() {
            if (!elements.historyList) return;
            
            if (state.history.length === 0) {
                elements.historyList.innerHTML = `

                    <div style="color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px;">
                        Noch keine √úbertragungen
                    </div>`;
                return;
            }
            
            let html = '';
            state.history.forEach(entry => {
                html += `
                    <div class="history-item">
                        <span><strong>[${entry.flag}]</strong> ${escapeHtml(entry.preview || entry.searchValue || '')}</span>
                        <span class="history-time">${entry.time}</span>
                    </div>`;
            });
            elements.historyList.innerHTML = html;
        }
        
        // IndexedDB f√ºr gro√üe Dateien
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    if (!database.objectStoreNames.contains('files')) {
                        database.createObjectStore('files', { keyPath: 'id' });
                    }
                    if (!database.objectStoreNames.contains('config')) {
                        database.createObjectStore('config', { keyPath: 'id' });
                    }
                };
            });
        }
        
        function saveToIndexedDB(storeName, id, data) {
            return new Promise((resolve, reject) => {
                if (!db) { reject('DB not initialized'); return; }
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put({ id, data, timestamp: Date.now() });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        function loadFromIndexedDB(storeName, id) {
            return new Promise((resolve, reject) => {
                if (!db) { reject('DB not initialized'); return; }
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result?.data);
                request.onerror = () => reject(request.error);
            });
        }
        
        function saveConfig() {
            const config = {
                file1SheetName: state.file1.selectedSheet,
                file2SheetName: state.file2.selectedSheet,
                mapping: state.mapping,
                history: state.history.slice(-100),  // Keep last 100 entries
                // Extra-Spalten Konfiguration
                extraColumns: {
                    enableFlag: isFlagEnabled(),
                    enableComment: isCommentEnabled(),
                    flagColumn: getFlagColumn(),
                    flagValues: getFlagValues().join(','),
                    commentColumn: getCommentColumn(),
                    commentPlaceholder: getCommentPlaceholder()
                }
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
        }
        
        function loadConfig() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const config = JSON.parse(saved);
                    state.mapping = config.mapping || state.mapping;
                    state.history = config.history || [];
                    
                    // Extra-Spalten Konfiguration laden
                    if (config.extraColumns) {
                        const ec = config.extraColumns;
                        if (ec.enableFlag !== undefined) {
                            document.getElementById('enableFlagColumn').checked = ec.enableFlag;
                            localStorage.setItem('excelSyncEnableFlag', String(ec.enableFlag));
                        }
                        if (ec.enableComment !== undefined) {
                            document.getElementById('enableCommentColumn').checked = ec.enableComment;
                            localStorage.setItem('excelSyncEnableComment', String(ec.enableComment));
                        }
                        if (ec.flagValues) {
                            document.getElementById('flagValues').value = ec.flagValues;
                            localStorage.setItem('excelSyncFlagValues', ec.flagValues);
                        }
                        if (ec.commentPlaceholder) {
                            document.getElementById('commentPlaceholder').value = ec.commentPlaceholder;
                            localStorage.setItem('excelSyncCommentPlaceholder', ec.commentPlaceholder);
                        }
                        // UI aktualisieren
                        updateFlagDropdownOptions();
                        updateCommentPlaceholders();
                        updateFlagCommentVisibility();
                        updateColumnDisplays();
                    }
                    
                    updateHistoryDisplay();
                    return config;
                }
            } catch (e) {
                console.error('Error loading config:', e);
            }
            return null;
        }
        
        async function exportConfig() {
            const config = {
                file1SheetName: state.file1.selectedSheet,
                file2SheetName: state.file2.selectedSheet,
                mapping: state.mapping,
                exportDate: new Date().toISOString(),
                // Extra-Spalten Konfiguration
                extraColumns: {
                    enableFlag: isFlagEnabled(),
                    enableComment: isCommentEnabled(),
                    flagColumn: getFlagColumn(),
                    flagValues: getFlagValues().join(','),
                    commentColumn: getCommentColumn(),
                    commentPlaceholder: getCommentPlaceholder()
                }
            };
            
            // Im Electron-Modus: Nur Mapping und Dateipfade speichern
            if (state.file1.filePath) {
                config.file1Path = state.file1.filePath;
                config.file1Name = state.file1.name;
            }
            if (state.file2.filePath) {
                config.file2Path = state.file2.filePath;
                config.file2Name = state.file2.name;
            }
            // Template-Pfad speichern
            if (state.template.filePath) {
                config.templatePath = state.template.filePath;
                config.templateName = state.template.name;
            }
            
            // Template speichern (falls vorhanden) - f√ºr Browser-Modus als Base64
            if (state.template.data) {
                config.templateData = state.template.data;
                config.templateName = state.template.name;
            }
            
            // In IndexedDB speichern (f√ºr gro√üe Dateien)
            if (db) {
                saveToIndexedDB('config', 'lastExport', config)
                    .then(() => console.log('Konfig in IndexedDB gespeichert'))
                    .catch(e => console.error('IndexedDB Fehler:', e));
            }
            
            // Kleine Konfig (ohne Dateien) auch in LocalStorage f√ºr Fallback
            const configSmall = { ...config };
            delete configSmall.file1Data;
            delete configSmall.file2Data;
            try {
                localStorage.setItem(LAST_EXPORT_KEY, JSON.stringify(configSmall));
            } catch (e) {
                console.warn('LocalStorage Fehler:', e);
            }
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            
            // Electron-Modus: Verwende Electron-API zum Speichern
            try {
                const savePath = await window.electronAPI.saveFileDialog({
                    title: 'Konfiguration speichern',
                    defaultPath: getWorkingDirectoryPath() ? (getWorkingDirectoryPath() + '/config.json') : 'config.json',
                    filters: [{ name: 'JSON Dateien', extensions: ['json'] }]
                });
                if (savePath) {
                    await window.electronAPI.saveConfig(savePath, config);
                    showStatus(elements.transferStatus, `‚úì config.json gespeichert: ${savePath}`, 'success');
                }
            } catch (e) {
                console.error('Fehler beim Speichern:', e);
                showStatus(elements.transferStatus, `Fehler: ${e.message}`, 'error');
            }
        }
        
        function importConfig(file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const config = JSON.parse(e.target.result);
                    state.mapping = config.mapping || state.mapping;
                    
                    // Extra-Spalten Konfiguration importieren
                    if (config.extraColumns) {
                        const ec = config.extraColumns;
                        if (ec.enableFlag !== undefined) {
                            document.getElementById('enableFlagColumn').checked = ec.enableFlag;
                            localStorage.setItem('excelSyncEnableFlag', String(ec.enableFlag));
                        }
                        if (ec.enableComment !== undefined) {
                            document.getElementById('enableCommentColumn').checked = ec.enableComment;
                            localStorage.setItem('excelSyncEnableComment', String(ec.enableComment));
                        }
                        if (ec.flagValues) {
                            document.getElementById('flagValues').value = ec.flagValues;
                            localStorage.setItem('excelSyncFlagValues', ec.flagValues);
                        }
                        if (ec.commentPlaceholder) {
                            document.getElementById('commentPlaceholder').value = ec.commentPlaceholder;
                            localStorage.setItem('excelSyncCommentPlaceholder', ec.commentPlaceholder);
                        }
                        // UI aktualisieren
                        updateFlagDropdownOptions();
                        updateCommentPlaceholders();
                        updateFlagCommentVisibility();
                    }
                    
                    // Speichere in IndexedDB (kann gro√üe Dateien speichern)
                    if (db) {
                        try {
                            await saveToIndexedDB('config', 'lastExport', config);
                            console.log('Importierte Konfig in IndexedDB gespeichert');
                        } catch (dbErr) {
                            console.warn('IndexedDB Fehler:', dbErr);
                        }
                    }
                    
                    // Fallback: Speichere auch in LocalStorage (ohne Dateiinhalt wenn zu gro√ü)
                    try {
                        localStorage.setItem(LAST_EXPORT_KEY, e.target.result);
                    } catch (lsErr) {
                        // LocalStorage zu klein - speichere ohne Dateien
                        const smallConfig = { ...config };
                        delete smallConfig.file1Data;
                        delete smallConfig.file2Data;
                        localStorage.setItem(LAST_EXPORT_KEY, JSON.stringify(smallConfig));
                        console.log('LocalStorage zu klein f√ºr Dateien, nur Mapping gespeichert');
                    }
                    
                    // Lade eingebettete Excel-Dateien
                    if (config.file1Data) {
                        await loadWorkbookFromBase64(config.file1Data, config.file1Name, 1, config.file1SheetName);
                    } else if (config.file1SheetName) {
                        state.file1.pendingSheet = config.file1SheetName;
                        elements.file1Info.textContent = `‚è≥ Arbeitsblatt: ${config.file1SheetName}`;
                        elements.file1Info.style.color = 'var(--warning)';
                    }
                    
                    if (config.file2Data) {
                        await loadWorkbookFromBase64(config.file2Data, config.file2Name, 2, config.file2SheetName);
                    } else if (config.file2SheetName) {
                        state.file2.pendingSheet = config.file2SheetName;
                        elements.file2Info.textContent = `‚è≥ Arbeitsblatt: ${config.file2SheetName}`;
                        elements.file2Info.style.color = 'var(--warning)';
                    }
                    
                    // Template laden (falls vorhanden)
                    if (config.templateData) {
                        state.template.data = config.templateData;
                        state.template.name = config.templateName;
                        elements.templateInfo.textContent = config.templateName;
                        elements.btnNewMonth.disabled = false;
                    }
                    
                    updateMappingInfo();
                    updateMappingPreview();
                    saveConfig();
                    
                    // Zeige geladene Konfig-Details
                    const date = config.exportDate ? new Date(config.exportDate).toLocaleString('de-DE') : 'unbekannt';
                    const mappingCount = state.mapping.sourceColumns?.length || 0;
                    const filesIncluded = (config.file1Data ? 1 : 0) + (config.file2Data ? 1 : 0);

                    showStatus(elements.transferStatus, 
                        `‚úì Konfiguration importiert! (${mappingCount} Spalten, ${filesIncluded} Datei(en), vom ${date})`, 'success');

                    elements.mappingInfo.textContent = `${mappingCount} Spalte(n) konfiguriert`;
                    
                } catch (err) {
                    showStatus(elements.transferStatus, 'Fehler beim Importieren: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
        }
        
        // ==================== File Loading (Electron-Modus) ====================
        // Dateien werden √ºber electronAPI.openFileDialog() geladen
        // Die Browser-Funktionen loadFile(), processFile(), loadWorkbookFromBase64() wurden entfernt
        // selectSheet1/2 im Browser-Modus wurden entfernt (XLSX-basiert)
        
        function checkReadyState() {
            const hasFile1 = state.file1.filePath;
            const hasFile2 = state.file2.filePath;
            const bothLoaded = hasFile1 && hasFile2;
            
            // Mapping-Button nur deaktivieren wenn KEINE Konfig geladen AND kein Dateien
            const hasMapping = state.mapping.sourceColumns && state.mapping.sourceColumns.length > 0;
            elements.btnConfigMapping.disabled = !bothLoaded && !hasMapping;
            
            elements.searchInput.disabled = !state.file1.selectedSheet;
            elements.btnSearch.disabled = !state.file1.selectedSheet;
            
            // "Neue Zeile" Button aktivieren wenn Mapping vorhanden und Datei 2 geladen
            elements.btnNewRow.disabled = !hasMapping || !hasFile2;
            
            // Datenexplorer ist immer aktiviert (kann eigene Dateien √∂ffnen)
            elements.btnDataExplorer.disabled = false;
            
            updateMappingInfo();
            updateMappingPreview();
        }
        
        function updateMappingPreview() {
            const preview = document.getElementById('mappingPreview');
            if (!preview) return;
            
            if (!state.mapping.sourceColumns || state.mapping.sourceColumns.length === 0) {
                preview.innerHTML = '';
                return;
            }
            
            let html = '<strong>Aktuelle Konfig:</strong><br>';
            html += `Start-Spalte: ${getColumnLetter(getDataStartColumn())}<br>`;
            html += `Duplikat-Check: Spalte ${state.mapping.duplicateCheckColumn + 1}<br>`;
            html += `Spalten: ${state.mapping.sourceColumns.length}`;
            
            preview.innerHTML = html;
        }
        
        function updateMappingInfo() {
            const hasFile1 = state.file1.filePath;
            const hasFile2 = state.file2.filePath;
            
            if (!hasFile1 || !hasFile2) {
                if (state.mapping.sourceColumns && state.mapping.sourceColumns.length > 0) {
                    elements.mappingInfo.textContent = `${state.mapping.sourceColumns.length} Spalte(n) konfiguriert (Dateien laden)`;
                    elements.mappingInfo.style.color = 'var(--warning)';
                } else {
                    elements.mappingInfo.textContent = 'Laden Sie beide Dateien';
                    elements.mappingInfo.style.color = '';
                }
                return;
            }
            
            elements.mappingInfo.style.color = '';
            if (state.mapping.sourceColumns.length === 0) {
                elements.mappingInfo.textContent = 'Klicken Sie auf "Spalten konfigurieren"';
            } else {
                elements.mappingInfo.textContent = `${state.mapping.sourceColumns.length} Spalte(n) konfiguriert ‚úì`;
            }
        }
        
        function openMappingModal() {
            elements.mappingModal.classList.remove('hidden');
            renderMappingList();
        }
        
        function closeMappingModal() {
            elements.mappingModal.classList.add('hidden');
        }
        
        function renderMappingList() {
            elements.mappingList.innerHTML = '';
            
            // If no mappings yet, add all columns by default (skip first column - usually row numbers)
            if (state.mapping.sourceColumns.length === 0 && state.file1.headers.length > 1) {
                state.mapping.sourceColumns = state.file1.headers.slice(1).map((_, i) => i + 1);
            } else if (state.mapping.sourceColumns.length === 0 && state.file1.headers.length === 1) {
                state.mapping.sourceColumns = [0];
            }
            
            // Populate duplicate check column dropdown
            const dupSelect = document.getElementById('duplicateCheckColumn');
            dupSelect.innerHTML = '';
            state.file1.headers.forEach((header, idx) => {
                const option = document.createElement('option');
                option.value = idx;
                option.textContent = `${getColumnLetter(idx + 1)}: ${header || '(leer)'}`;
                if (idx === state.mapping.duplicateCheckColumn) option.selected = true;
                dupSelect.appendChild(option);
            });
            
            state.mapping.sourceColumns.forEach((colIndex, i) => {
                const item = document.createElement('div');
                item.className = 'mapping-item';
                
                const select = document.createElement('select');
                state.file1.headers.forEach((header, idx) => {
                    const option = document.createElement('option');
                    option.value = idx;
                    option.textContent = `${getColumnLetter(idx + 1)}: ${header || '(leer)'}`;
                    if (idx === colIndex) option.selected = true;
                    select.appendChild(option);
                });
                select.addEventListener('change', () => {
                    state.mapping.sourceColumns[i] = parseInt(select.value);
                });
                
                const arrow = document.createElement('span');
                arrow.className = 'mapping-arrow';
                arrow.textContent = '‚Üí';
                
                const target = document.createElement('span');
                target.className = 'mapping-target';
                const targetCol = getDataStartColumn() + i;
                target.textContent = `Spalte ${getColumnLetter(targetCol)} in Datei 2`;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'mapping-remove';
                removeBtn.textContent = '‚úï';
                removeBtn.onclick = () => {
                    state.mapping.sourceColumns.splice(i, 1);
                    renderMappingList();
                };
                
                item.appendChild(select);
                item.appendChild(arrow);
                item.appendChild(target);
                item.appendChild(removeBtn);
                elements.mappingList.appendChild(item);
            });
            
            // Update column displays
            updateColumnDisplays();
        }
        
        function addMappingColumn() {
            const nextCol = state.mapping.sourceColumns.length;
            if (nextCol < state.file1.headers.length) {
                state.mapping.sourceColumns.push(nextCol);
                renderMappingList();
            }
        }
        
        function saveMapping() {
            state.mapping.duplicateCheckColumn = parseInt(document.getElementById('duplicateCheckColumn').value);
            saveConfig();
            updateMappingInfo();
            closeMappingModal();
        }
        
        function getColumnLetter(num) {
            let result = '';
            while (num > 0) {
                num--;
                result = String.fromCharCode(65 + (num % 26)) + result;
                num = Math.floor(num / 26);
            }
            return result;
        }
        
        // ==================== Search Functions ====================
        function wildcardToRegex(pattern) {
            let escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            escaped = escaped.replace(/\*/g, '.*');
            escaped = escaped.replace(/\?/g, '.');
            return new RegExp('^' + escaped + '$', 'i');
        }
        
        /**
         * Pr√ºft ob ein Text einem Suchterm entspricht (mit Platzhalter-Unterst√ºtzung)
         */
        function matchesTerm(text, term, hasWildcards) {
            if (!text) return false;
            const str = String(text);
            if (hasWildcards) {
                return wildcardToRegex(term).test(str);
            }
            return str.toLowerCase().includes(term.toLowerCase());
        }
        
        /**
         * Parst eine Suchanfrage mit AND/OR Operatoren
         * Beispiele: "Eurofighter AND 2025", "Boeing OR Airbus", "Tiger AND (2024 OR 2025)"
         */
        function parseSearchQuery(query) {
            const trimmed = query.trim();
            
            // Pr√ºfen ob AND oder OR Operatoren vorhanden sind
            const hasAnd = / AND /i.test(trimmed);
            const hasOr = / OR /i.test(trimmed);
            
            if (!hasAnd && !hasOr) {
                // Einfache Suche
                return { type: 'simple', term: trimmed };
            }
            
            if (hasAnd && !hasOr) {
                // Nur AND
                const terms = trimmed.split(/ AND /i).map(t => t.trim()).filter(t => t);
                return { type: 'and', terms };
            }
            
            if (hasOr && !hasAnd) {
                // Nur OR
                const terms = trimmed.split(/ OR /i).map(t => t.trim()).filter(t => t);
                return { type: 'or', terms };
            }
            
            // Gemischt: OR hat niedrigere Priorit√§t, AND wird zuerst ausgewertet
            // "A AND B OR C AND D" ‚Üí (A AND B) OR (C AND D)
            const orParts = trimmed.split(/ OR /i).map(part => {
                const andTerms = part.split(/ AND /i).map(t => t.trim()).filter(t => t);
                if (andTerms.length === 1) {
                    return { type: 'simple', term: andTerms[0] };
                }
                return { type: 'and', terms: andTerms };
            });
            
            return { type: 'or', parts: orParts };
        }
        
        /**
         * Pr√ºft ob eine Zeile der geparsten Suchanfrage entspricht
         */
        function rowMatchesQuery(row, parsed) {
            const rowStr = row.join(' ').toLowerCase();
            
            function termHasWildcards(term) {
                return term.includes('*') || term.includes('?');
            }
            
            function rowContainsTerm(term) {
                const hasWc = termHasWildcards(term);
                for (const cell of row) {
                    if (matchesTerm(cell, term, hasWc)) return true;
                }
                return false;
            }
            
            if (parsed.type === 'simple') {
                return rowContainsTerm(parsed.term);
            }
            
            if (parsed.type === 'and') {
                // Alle Terme m√ºssen in der Zeile vorkommen
                return parsed.terms.every(term => rowContainsTerm(term));
            }
            
            if (parsed.type === 'or') {
                if (parsed.terms) {
                    // Einfache OR-Verkn√ºpfung
                    return parsed.terms.some(term => rowContainsTerm(term));
                }
                if (parsed.parts) {
                    // Gemischte Anfrage mit AND-Gruppen
                    return parsed.parts.some(part => rowMatchesQuery(row, part));
                }
            }
            
            return false;
        }
        
        function search() {
            const query = elements.searchInput.value.trim();
            if (!query || !state.file1.data.length) return;
            
            const hasWildcards = query.includes('*') || query.includes('?');
            const hasOperators = / (AND|OR) /i.test(query);
            state.searchResults = [];
            
            if (hasOperators) {
                // Erweiterte Suche mit AND/OR
                const parsed = parseSearchQuery(query);
                state.file1.data.forEach((row, rowIndex) => {
                    if (rowMatchesQuery(row, parsed)) {
                        state.searchResults.push({ rowIndex: rowIndex, data: row });
                    }
                });
            } else if (hasWildcards) {
                const regex = wildcardToRegex(query);
                state.file1.data.forEach((row, rowIndex) => {
                    for (let col of row) {
                        if (col && regex.test(String(col))) {
                            state.searchResults.push({ rowIndex: rowIndex, data: row });
                            break;
                        }
                    }
                });
            } else {
                const lowerQuery = query.toLowerCase();
                state.file1.data.forEach((row, rowIndex) => {
                    for (let col of row) {
                        if (col && String(col).toLowerCase().includes(lowerQuery)) {
                            state.searchResults.push({ rowIndex: rowIndex, data: row });
                            break;
                        }
                    }
                });
            }
            
            // Such-Historie aktualisieren
            addToSearchHistory(query, state.searchResults.length);
            hideSearchHistoryDropdown();
            
            displaySearchResults(query, hasWildcards || hasOperators);
        }
        
        function displaySearchResults(query, hasWildcards = false) {
            state.selectedRows = [];
            state.searchPagination.currentPage = 1; // Bei neuer Suche zur ersten Seite
            
            if (state.searchResults.length === 0) {
                elements.searchResultsInfo.innerHTML = `Keine Treffer f√ºr "<strong>${escapeHtml(query)}</strong>"`;
                elements.emptyState.style.display = 'flex';
                elements.resultsTableContainer.style.display = 'none';
                elements.transferPanel.classList.add('hidden');
                document.getElementById('searchPagination').style.display = 'none';
                return;
            }
            
            renderSearchResultsPage(query, hasWildcards);
        }
        
        function renderSearchResultsPage(query = '', hasWildcards = false) {
            const totalResults = state.searchResults.length;
            const pageSize = state.searchPagination.pageSize;
            const totalPages = Math.max(1, Math.ceil(totalResults / pageSize));
            
            // Sicherstellen, dass currentPage g√ºltig ist
            if (state.searchPagination.currentPage > totalPages) {
                state.searchPagination.currentPage = totalPages;
            }
            if (state.searchPagination.currentPage < 1) {
                state.searchPagination.currentPage = 1;
            }
            
            const startIndex = (state.searchPagination.currentPage - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, totalResults);
            const pageResults = state.searchResults.slice(startIndex, endIndex);
            
            const wildcardInfo = hasWildcards ? ' (Platzhalter)' : '';
            if (totalResults > pageSize) {
                elements.searchResultsInfo.innerHTML = 
                    `Zeige <strong>${startIndex + 1}-${endIndex}</strong> von <strong>${totalResults}</strong> Treffern f√ºr "<strong>${escapeHtml(query)}</strong>"${wildcardInfo}`;
            } else {
                elements.searchResultsInfo.innerHTML = 
                    `<strong>${totalResults}</strong> Treffer f√ºr "<strong>${escapeHtml(query)}</strong>"${wildcardInfo}`;
            }
            
            elements.emptyState.style.display = 'none';
            elements.resultsTableContainer.style.display = 'block';
            
            let headerHtml = '<tr><th style="width: 40px;"><input type="checkbox" id="selectAllCheckbox" title="Alle auf dieser Seite ausw√§hlen"></th>';
            state.file1.headers.forEach((header, i) => {
                headerHtml += `<th>${escapeHtml(header || `Spalte ${getColumnLetter(i + 1)}`)}</th>`;
            });
            headerHtml += '</tr>';
            elements.resultsTableHead.innerHTML = headerHtml;
            
            // Nur die aktuelle Seite rendern
            let bodyHtml = '';
            pageResults.forEach((result, pageIndex) => {
                const globalIndex = startIndex + pageIndex;
                bodyHtml += `<tr data-index="${globalIndex}">`;
                bodyHtml += `<td><input type="checkbox" class="row-checkbox" data-index="${globalIndex}" onclick="event.stopPropagation()"></td>`;
                state.file1.headers.forEach((_, colIndex) => {
                    const cell = result.data[colIndex];
                    const cellStr = String(cell ?? '');
                    bodyHtml += `<td contenteditable="true" data-row="${globalIndex}" data-col="${colIndex}" data-original="${escapeHtml(cellStr)}" onclick="event.stopPropagation()">${escapeHtml(cellStr)}</td>`;
                });
                bodyHtml += '</tr>';
            });
            elements.resultsTableBody.innerHTML = bodyHtml;
            
            document.querySelectorAll('#resultsTableBody td[contenteditable]').forEach(td => {
                // Speichere den letzten bekannten Wert f√ºr Undo
                td.dataset.lastValue = td.textContent;
                
                td.addEventListener('blur', function() {
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    const original = this.dataset.original;
                    const lastValue = this.dataset.lastValue;
                    const current = this.textContent;
                    
                    // Nur Undo speichern wenn sich der Wert ge√§ndert hat
                    if (lastValue !== current) {
                        pushSearchUndo({
                            rowIndex,
                            colIndex,
                            oldValue: lastValue,
                            newValue: current,
                            originalValue: original
                        });
                        // Daten im State aktualisieren
                        state.searchResults[rowIndex].data[colIndex] = current;
                        this.dataset.lastValue = current;
                    }
                    
                    this.classList.toggle('edited', original !== current);
                });
                
                td.addEventListener('input', function() {
                    const original = this.dataset.original;
                    const current = this.textContent;
                    this.classList.toggle('edited', original !== current);
                });
                
                td.addEventListener('focus', function() {
                    const rowIndex = parseInt(this.dataset.row);
                    if (!state.selectedRows.includes(rowIndex)) {
                        toggleRowSelection(rowIndex, true);
                    }
                });
            });
            
            document.getElementById('selectAllCheckbox').addEventListener('change', (e) => {
                selectAllRows(e.target.checked);
            });
            
            document.querySelectorAll('.row-checkbox').forEach(cb => {
                cb.addEventListener('change', (e) => {
                    toggleRowSelection(parseInt(e.target.dataset.index), e.target.checked);
                });
            });
            
            // Pagination UI aktualisieren
            updateSearchPagination(totalPages);
            
            // Erste Zeile auf der aktuellen Seite ausw√§hlen
            if (pageResults.length > 0) {
                toggleRowSelection(startIndex, true);
            }
            elements.transferPanel.classList.remove('hidden');
        }
        
        function updateSearchPagination(totalPages) {
            const paginationEl = document.getElementById('searchPagination');
            const pageInfoEl = document.getElementById('searchPageInfo');
            const firstBtn = document.getElementById('btnSearchFirstPage');
            const prevBtn = document.getElementById('btnSearchPrevPage');
            const nextBtn = document.getElementById('btnSearchNextPage');
            const lastBtn = document.getElementById('btnSearchLastPage');
            
            // Pagination nur anzeigen wenn mehr als eine Seite
            if (state.searchResults.length > state.searchPagination.pageSize) {
                paginationEl.style.display = 'flex';
                pageInfoEl.textContent = `Seite ${state.searchPagination.currentPage} von ${totalPages}`;
                
                // Buttons aktivieren/deaktivieren
                firstBtn.disabled = state.searchPagination.currentPage === 1;
                prevBtn.disabled = state.searchPagination.currentPage === 1;
                nextBtn.disabled = state.searchPagination.currentPage === totalPages;
                lastBtn.disabled = state.searchPagination.currentPage === totalPages;
            } else {
                paginationEl.style.display = 'none';
            }
        }
        
        function searchGoToPage(page) {
            const totalPages = Math.ceil(state.searchResults.length / state.searchPagination.pageSize);
            state.searchPagination.currentPage = Math.max(1, Math.min(page, totalPages));
            renderSearchResultsPage(elements.searchInput.value.trim());
            
            // Zum Tabellenanfang scrollen
            elements.resultsTableContainer.scrollTop = 0;
        }
        
        function searchChangePageSize(newSize) {
            state.searchPagination.pageSize = parseInt(newSize);
            state.searchPagination.currentPage = 1;
            renderSearchResultsPage(elements.searchInput.value.trim());
        }
        
        function getEditedRowData(rowIndex) {
            const cells = document.querySelectorAll(`#resultsTableBody td[data-row="${rowIndex}"]`);
            const data = [];
            cells.forEach(cell => {
                const colIndex = parseInt(cell.dataset.col);
                data[colIndex] = cell.textContent;
            });
            return data;
        }
        
        function isRowEdited(rowIndex) {
            const cells = document.querySelectorAll(`#resultsTableBody td[data-row="${rowIndex}"].edited`);
            return cells.length > 0;
        }
        
        function selectAllRows(selected) {
            const checkboxes = document.querySelectorAll('.row-checkbox');
            checkboxes.forEach(cb => {
                const index = parseInt(cb.dataset.index);
                toggleRowSelection(index, selected);
            });
        }
        
        function toggleRowSelection(index, forceState) {
            const checkbox = document.querySelector(`.row-checkbox[data-index="${index}"]`);
            const tr = document.querySelector(`#resultsTableBody tr[data-index="${index}"]`);
            if (!checkbox || !tr) return;
            
            const isSelected = forceState !== undefined ? forceState : !checkbox.checked;
            checkbox.checked = isSelected;
            tr.classList.toggle('selected', isSelected);
            
            if (isSelected) {
                if (!state.selectedRows.includes(index)) {
                    state.selectedRows.push(index);
                }
            } else {
                state.selectedRows = state.selectedRows.filter(i => i !== index);
            }
            
            document.getElementById('selectedCount').textContent = state.selectedRows.length;
            
            const allCheckbox = document.getElementById('selectAllCheckbox');
            const allCheckboxes = document.querySelectorAll('.row-checkbox');
            const checkedCount = document.querySelectorAll('.row-checkbox:checked').length;
            if (allCheckbox) {
                allCheckbox.checked = checkedCount === allCheckboxes.length;
                allCheckbox.indeterminate = checkedCount > 0 && checkedCount < allCheckboxes.length;
            }
            
            if (state.selectedRows.length > 0) {
                state.selectedRow = state.searchResults[state.selectedRows[state.selectedRows.length - 1]];
            } else {
                state.selectedRow = null;
            }
        }

        function removeFromQueue(index) {
            if (typeof index !== 'number' || index < 0 || index >= state.transferQueue.length) return;
            state.transferQueue.splice(index, 1);
            updateQueueDisplay();
        }
        
        // Sichere globale Funktionen mit Object.defineProperty (nicht √ºberschreibbar)
        Object.defineProperty(window, 'removeFromQueue', {
            value: removeFromQueue,
            writable: false,
            configurable: false
        });
        Object.defineProperty(window, 'toggleRowSelection', {
            value: toggleRowSelection,
            writable: false,
            configurable: false
        });

        // ==================== New Row Functions ====================
        function openNewRowPanel() {
            if (!state.mapping.sourceColumns || state.mapping.sourceColumns.length === 0) {
                showStatus(elements.transferStatus, 'Bitte zuerst Spalten konfigurieren', 'error');
                return;
            }
            
            // Formular mit konfigurierten Spalten aufbauen
            let html = '';
            state.mapping.sourceColumns.forEach((colIndex, i) => {
                const headerName = state.file1.headers[colIndex] || `Spalte ${colIndex + 1}`;
                html += `
                    <div class="new-row-field">
                        <label title="${headerName}">${headerName}</label>
                        <input type="text" id="newRowField_${i}" data-col-index="${colIndex}" placeholder="${headerName}">
                    </div>`;
            });
            
            elements.newRowForm.innerHTML = html;
            elements.newRowPanel.classList.remove('hidden');
            
            // Fokus auf erstes Feld
            const firstField = document.getElementById('newRowField_0');
            if (firstField) firstField.focus();
        }
        
        function closeNewRowPanel() {
            elements.newRowPanel.classList.add('hidden');
            // Felder leeren
            elements.newRowForm.innerHTML = '';
            elements.newRowComment.value = '';
            elements.newRowFlag.value = 'A';
        }
        
        function getNewRowData() {
            // Sammle alle Werte aus den Eingabefeldern
            const data = new Array(Math.max(...state.mapping.sourceColumns) + 1).fill(''); 
            
            state.mapping.sourceColumns.forEach((colIndex, i) => {
                const field = document.getElementById(`newRowField_${i}`);
                if (field) {
                    data[colIndex] = field.value;
                }
            });
            
            return data;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // ==================== New Row Functions ====================
        function addNewRowToQueue() {
            const data = getNewRowData();
            const flag = elements.newRowFlag.value;
            const comment = elements.newRowComment.value;
            const checkValue = data[state.mapping.duplicateCheckColumn] || '';
            
            state.transferQueue.push({
                data: data,
                flag: flag,
                comment: comment,
                checkValue: checkValue,
                isManual: true
            });
            
            updateQueueDisplay();
            const successMsg = '‚úÖ Neue Zeile zur Warteschlange hinzugef√ºgt!';
            showStatus(elements.transferStatus, successMsg, 'success');
            showStatus(elements.newRowStatus, successMsg, 'success');
            
            // Felder leeren f√ºr n√§chste Eingabe
            state.mapping.sourceColumns.forEach((colIndex, i) => {
                const field = document.getElementById(`newRowField_${i}`);
                if (field) field.value = '';
            });
            elements.newRowComment.value = '';
            
            const firstField = document.getElementById('newRowField_0');
            if (firstField) firstField.focus();
        }
        
        // Leerzeile hinzuf√ºgen - unabh√§ngig von Flag-Spalte
        function addEmptyRowToQueue() {
            const comment = elements.newRowComment?.value || '';
            
            // Leeres data-Array erstellen
            const data = new Array(Math.max(...state.mapping.sourceColumns) + 1).fill('');
            
            state.transferQueue.push({
                data: data,
                flag: 'leer',
                comment: comment,
                checkValue: '(Leerzeile)',
                isManual: true
            });
            
            updateQueueDisplay();
            const successMsg = '‚úÖ Leerzeile zur Warteschlange hinzugef√ºgt!';
            showStatus(elements.transferStatus, successMsg, 'success');
            showStatus(elements.newRowStatus, successMsg, 'success');
            
            // Kommentar leeren
            if (elements.newRowComment) {
                elements.newRowComment.value = '';
            }
        }

        async function transferNewRowDirect() {
            const data = getNewRowData();
            const flag = elements.newRowFlag.value;
            const comment = elements.newRowComment.value;
            
            // Pr√ºfe ob Zieldatei verf√ºgbar ist
            const hasTargetFile = state.file2.filePath;
            if (!hasTargetFile) {
                const errorMsg = 'Keine Zieldatei geladen';
                showStatus(elements.transferStatus, errorMsg, 'error');
                showStatus(elements.newRowStatus, errorMsg, 'error');
                return;
            }
            
            // Zur Warteschlange hinzuf√ºgen und direkt √ºbertragen
            if (state.file2.filePath) {
                const checkValue = data[state.mapping.duplicateCheckColumn] || '';
                
                state.transferQueue.push({
                    data: data,
                    flag: flag,
                    comment: comment,
                    checkValue: checkValue,
                    isManual: true
                });
                
                updateQueueDisplay();
                
                try {
                    // Direkt √ºbertragen
                    await transferQueueToExcel();
                    
                    // Felder leeren f√ºr n√§chste Eingabe
                    state.mapping.sourceColumns.forEach((colIndex, i) => {
                        const field = document.getElementById(`newRowField_${i}`);
                        if (field) field.value = '';
                    });
                    elements.newRowComment.value = '';
                    
                    const firstField = document.getElementById('newRowField_0');
                    if (firstField) firstField.focus();
                    
                    // Erfolgsmeldung auch im Modal anzeigen
                    showStatus(elements.newRowStatus, '‚úÖ Zeile erfolgreich √ºbertragen!', 'success');
                } catch (err) {
                    console.error('Fehler bei √úbertragung:', err);
                    const errorMsg = `Fehler: ${err.message}`;
                    showStatus(elements.transferStatus, errorMsg, 'error');
                    showStatus(elements.newRowStatus, errorMsg, 'error');
                }
                
                return;
            }
            
            // Browser-Modus: Original-Logik
            const dataStartCol = getDataStartColumn();
            const newRow = new Array(Math.max(
                state.file2.headers.length,
                dataStartCol + state.mapping.sourceColumns.length
            )).fill('');
            
            // Flag und Kommentar in automatisch berechneten Spalten
            if (isFlagEnabled()) {
                newRow[getFlagColumn() - 1] = flag;
            }
            if (isCommentEnabled()) {
                newRow[getCommentColumn() - 1] = comment;
            }
            
            state.mapping.sourceColumns.forEach((srcColIndex, i) => {
                const targetColIndex = dataStartCol - 1 + i;
                newRow[targetColIndex] = data[srcColIndex] || '';
            });
            
            state.file2.data.push(newRow);
            updateWorkbook();
            
            state.history.unshift({
                time: formatHistoryDateTime(),
                flag: flag,
                searchValue: '(Manuelle Eingabe)',
                preview: data[state.mapping.duplicateCheckColumn] || '(Neue Zeile)'
            });
            if (state.history.length > 100) state.history = state.history.slice(0, 100);
            updateHistoryDisplay();
            
            showStatus(elements.transferStatus, '‚úÖ Neue Zeile direkt √ºbertragen!', 'success');
            
            state.mapping.sourceColumns.forEach((colIndex, i) => {
                const field = document.getElementById(`newRowField_${i}`);
                if (field) field.value = '';
            });
            elements.newRowComment.value = '';
            
            const firstField = document.getElementById('newRowField_0');
            if (firstField) firstField.focus();
            
            saveConfig();
        }
        
        // ==================== Transfer ====================
        function checkForDuplicate(value) {
            if (!value || !state.file2.data.length) return null;
            
            const valueStr = String(value).toLowerCase().trim();
            const dataStartCol = getDataStartColumn();
            
            for (let i = 0; i < state.file2.data.length; i++) {
                const row = state.file2.data[i];
                for (let j = dataStartCol - 1; j < row.length; j++) {
                    if (row[j] && String(row[j]).toLowerCase().trim() === valueStr) {
                        return { rowIndex: i + 2, value: row[j] };
                    }
                }
            }
            return null;
        }
        
        async function transferSelectedDirect() {
            if (state.selectedRows.length === 0) {
                showStatus(elements.transferStatus, 'Bitte w√§hlen Sie mindestens eine Zeile aus', 'error');
                return;
            }
            
            // Pr√ºfe ob Zieldatei verf√ºgbar ist
            const hasTargetFile = state.file2.filePath;
            if (!hasTargetFile) {
                showStatus(elements.transferStatus, 'Keine Zieldatei geladen', 'error');
                return;
            }
            
            const flag = elements.transferFlag.value;
            const comment = elements.transferComment.value;
            
            // Zur Warteschlange hinzuf√ºgen und direkt √ºbertragen
            if (state.file2.filePath) {
                // Zeilen zur Warteschlange hinzuf√ºgen
                for (const rowIndex of state.selectedRows) {
                    const row = state.searchResults[rowIndex];
                    if (!row) continue;
                    
                    const rowData = getEditedRowData(rowIndex);
                    const checkValue = rowData[state.mapping.duplicateCheckColumn];
                    
                    state.transferQueue.push({
                        data: [...rowData],
                        flag: flag,
                        comment: comment,
                        checkValue: checkValue,
                        wasEdited: isRowEdited(rowIndex),
                        sourceRowIndex: row.rowIndex + 2 // +2: rowIndex ist 0-basiert, Excel ist 1-basiert + Header-Zeile
                    });
                }
                
                updateQueueDisplay();
                
                try {
                    // Direkt √ºbertragen
                    await transferQueueToExcel();
                } catch (err) {
                    console.error('Fehler bei √úbertragung:', err);
                    showStatus(elements.transferStatus, `Fehler: ${err.message}`, 'error');
                }
                
                selectAllRows(false);
                elements.transferComment.value = '';
                elements.searchInput.value = '';
                elements.searchInput.focus();
                return;
            }
            
            // Browser-Modus: Original-Logik
            let transferredCount = 0;
            let editedCount = 0;
            let duplicatesFound = [];
            const dataStartCol = getDataStartColumn();
            
            for (const rowIndex of state.selectedRows) {
                const row = state.searchResults[rowIndex];
                if (!row) continue;
                
                const rowData = getEditedRowData(rowIndex);
                const wasEdited = isRowEdited(rowIndex);
                if (wasEdited) editedCount++;
                
                const checkValue = rowData[state.mapping.duplicateCheckColumn];
                
                if (checkValue) {
                    const duplicate = checkForDuplicate(checkValue);
                    if (duplicate) {
                        duplicatesFound.push({ value: checkValue, row: duplicate.rowIndex });
                    }
                }
                
                const newRow = new Array(Math.max(
                    state.file2.headers.length,
                    dataStartCol + state.mapping.sourceColumns.length
                )).fill('');
                
                // Flag und Kommentar in automatisch berechneten Spalten
                if (isFlagEnabled()) {
                    newRow[getFlagColumn() - 1] = flag;
                }
                if (isCommentEnabled()) {
                    newRow[getCommentColumn() - 1] = comment;
                }
            
                state.mapping.sourceColumns.forEach((srcColIndex, i) => {
                    const targetColIndex = dataStartCol - 1 + i;
                    newRow[targetColIndex] = rowData[srcColIndex] || '';
                });
                
                state.file2.data.push(newRow);
                transferredCount++;
                
                state.history.unshift({
                    time: formatHistoryDateTime(),
                    flag: flag,
                    searchValue: checkValue,
                    preview: rowData[state.mapping.duplicateCheckColumn] || '(Neue Zeile)'
                });
            }
            
            updateWorkbook();
            
            if (state.history.length > 100) state.history.length = 100;
            updateHistoryDisplay();
            saveConfig();
            
            let message = `‚úì ${transferredCount} Zeile(n) direkt √ºbertragen!`;
            let status = 'success';
            if (editedCount > 0) {
                message += ` (${editedCount} bearbeitet ‚úèÔ∏è)`;
            }
            if (duplicatesFound.length > 0) {
                message += ` ‚ö†Ô∏è ${duplicatesFound.length} Duplikat(e)!`;
                status = 'warning';
            }
            
            showStatus(elements.transferStatus, message, status);
            
            selectAllRows(false);
            elements.transferComment.value = '';
            elements.searchInput.value = '';
            elements.searchInput.focus();
        }
        
        // ==================== Queue Functions ====================
        function addToQueue() {
            if (state.selectedRows.length === 0) {
                showStatus(elements.transferStatus, 'Bitte w√§hlen Sie mindestens eine Zeile aus', 'error');
                return;
            }
            
            const flag = elements.transferFlag.value;
            const comment = elements.transferComment.value;
            
            let addedCount = 0;
            let editedCount = 0;
            let skippedQueue = 0;
            const duplicatesFound = [];
            
            for (const rowIndex of state.selectedRows) {
                const row = state.searchResults[rowIndex];
                if (!row) continue;
                
                const rowData = getEditedRowData(rowIndex);
                const wasEdited = isRowEdited(rowIndex);
                if (wasEdited) editedCount++;
                
                const checkValue = rowData[state.mapping.duplicateCheckColumn];
                
                const rowAlreadyInQueue = state.transferQueue.some(item => item.rowIndex === row.rowIndex);
                if (rowAlreadyInQueue) {
                    skippedQueue++;
                    continue;
                }
                
                if (checkValue) {
                    const duplicate = checkForDuplicate(checkValue);
                    if (duplicate) {
                        duplicatesFound.push({ value: checkValue, row: duplicate.rowIndex });
                    }
                }
                
                state.transferQueue.push({
                    data: [...rowData],
                    rowIndex: row.rowIndex,
                    flag: flag,
                    comment: comment,
                    checkValue: checkValue,
                    wasEdited: wasEdited,
                    sourceRowIndex: row.rowIndex + 2 // +2: rowIndex ist 0-basiert, Excel ist 1-basiert + Header-Zeile
                });
                addedCount++;
            }
            
            updateQueueDisplay();
            elements.transferComment.value = '';
            
            let message = `‚úì ${addedCount} Zeile(n) zur Warteschlange hinzugef√ºgt`;
            let status = 'success';
            
            if (editedCount > 0) {
                message += ` (${editedCount} bearbeitet ‚úèÔ∏è)`;
            }
            if (skippedQueue > 0) {
                message += ` (${skippedQueue} bereits vorhanden)`;
            }
            if (duplicatesFound.length > 0) {
                message += ` ‚ö†Ô∏è ${duplicatesFound.length} Duplikat(e) in Zieldatei!`;
                status = 'warning';
            }
            
            showStatus(elements.transferStatus, message, status);
            
            selectAllRows(false);
            elements.searchInput.value = '';
            elements.searchInput.focus();
        }
        
        function clearQueue() {
            if (state.transferQueue.length > 0 && 
                !confirm(`Warteschlange mit ${state.transferQueue.length} Zeilen wirklich leeren?`)) {
                return;
            }
            state.transferQueue = [];
            updateQueueDisplay();
            autoSave(); // Auto-Save aktualisieren nach Leeren
        }
        
        function updateQueueDisplay() {
            const hasFile2 = state.file2.filePath;
            
            elements.queueCount.textContent = state.transferQueue.length;
            elements.btnClearQueue.disabled = state.transferQueue.length === 0;
            elements.btnExportPS.disabled = state.transferQueue.length === 0 || !hasFile2;
            elements.btnPreviewTransfer.disabled = state.transferQueue.length === 0 || !hasFile2;
            
            if (state.transferQueue.length === 0) {
                elements.queueList.innerHTML = '<div class="queue-empty">Keine Zeilen in der Warteschlange</div>';
                return;
            }
            
            let html = '';
            state.transferQueue.forEach((item, index) => {
                const preview = String(item.checkValue || item.data[0] || '').substring(0, 40);
                const editedBadge = item.wasEdited ? '<span class="queue-item-edited" title="Bearbeitet">‚úèÔ∏è</span>' : '';
                html += `
                    <div class="queue-item" style="display: flex; gap: 10px; padding: 8px; background: var(--bg-light); border-radius: 4px; margin-bottom: 5px; align-items: center;">
                        <span style="background: var(--primary); color: white; padding: 2px 8px; border-radius: 3px; font-weight: bold;">${item.flag}</span>
                        ${editedBadge}
                        <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(String(item.data))}">${escapeHtml(preview)}</span>
                        ${item.comment ? `<span style="color: var(--text-muted); font-size: 12px;" title="${escapeHtml(item.comment)}">${escapeHtml(item.comment.substring(0, 20))}</span>` : '' }
                        <button class="btn btn-secondary btn-sm" data-remove-index="${index}" title="Entfernen">‚úï</button>
                    </div>`;
            });
            elements.queueList.innerHTML = html;
            
            // Event-Delegation f√ºr Remove-Buttons
            elements.queueList.querySelectorAll('[data-remove-index]').forEach(btn => {
                btn.onclick = () => removeFromQueue(parseInt(btn.dataset.removeIndex, 10));
            });
        }
        
        async function transferQueueToExcel() {
            if (state.transferQueue.length === 0) {
                showStatus(elements.transferStatus, 'Keine Zeilen in der Warteschlange', 'error');
                return;
            }
            
            if (!state.file2.filePath) {
                showStatus(elements.transferStatus, 'Keine Zieldatei geladen', 'error');
                return;
            }
            
            const rows = state.transferQueue.map(item => {
                // Konvertiere item.data (Array) zu rowData (Objekt mit Index als Key)
                const rowData = {};
                state.mapping.sourceColumns.forEach((srcColIndex, i) => {
                    rowData[i] = item.data[srcColIndex] || '';
                });
                return {
                    flag: isFlagEnabled() ? item.flag : null,
                    comment: isCommentEnabled() ? item.comment : null,
                    data: rowData,
                    sourceRowIndex: item.sourceRowIndex || null, // Zeilen-Index aus Quelldatei f√ºr Formatierung
                    isManual: item.isManual || false
                };
            });
            
            const result = await window.electronAPI.insertExcelRows({
                filePath: state.file2.filePath,
                sheetName: state.file2.selectedSheet,
                rows: rows,
                startColumn: getDataStartColumn(),
                enableFlag: isFlagEnabled(),
                enableComment: isCommentEnabled(),
                flagColumn: getFlagColumn(),
                commentColumn: getCommentColumn(),
                // Quelldatei-Infos f√ºr Formatierungskopie
                sourceFilePath: state.file1.filePath || null,
                sourceSheetName: state.file1.selectedSheet || null,
                sourceColumns: state.mapping.sourceColumns || []
            });
            
            if (result.success) {
                state.transferQueue.forEach(item => {
                    state.history.unshift({
                        time: formatHistoryDateTime(),
                        flag: item.flag,
                        searchValue: item.checkValue,
                        preview: String(item.checkValue || item.data[0] || '').substring(0, 30)
                    });
                });
                if (state.history.length > 100) state.history = state.history.slice(0, 100);
                updateHistoryDisplay();
                
                state.transferQueue = [];
                updateQueueDisplay();
                
                // Auto-Save l√∂schen nach erfolgreicher √úbertragung
                clearAutoSave();
                
                await loadSheet2Electron(state.file2.selectedSheet);
                
                const successMsg = `‚úÖ ${result.insertedCount} Zeile(n) direkt in Excel eingef√ºgt!`;
                showStatus(elements.transferStatus, successMsg, 'success');
                showStatus(elements.newRowStatus, successMsg, 'success');
            } else {
                const errorMsg = `‚ùå Fehler: ${result.error}`;
                showStatus(elements.transferStatus, errorMsg, 'error');
                showStatus(elements.newRowStatus, errorMsg, 'error');
            }
        }
        
        // Diff-Vorschau vor Transfer anzeigen
        function showDiffPreview() {
            if (state.transferQueue.length === 0 || !state.file2.filePath) {
                showStatus(elements.transferStatus, 'Keine Zeilen in der Warteschlange oder keine Zieldatei geladen', 'error');
                return;
            }
            
            const modal = elements.diffPreviewModal;
            const targetFileName = state.file2.name || 'Zieldatei';
            const targetSheet = state.file2.selectedSheet || 'Sheet1';
            const currentRowCount = state.file2.data ? state.file2.data.length : 0;
            const startRow = currentRowCount + 1; // 1-basiert f√ºr Anzeige
            
            // Info-Bereich aktualisieren
            document.getElementById('diffTargetFile').textContent = targetFileName;
            document.getElementById('diffTargetSheet').textContent = targetSheet;
            document.getElementById('diffTargetRow').textContent = startRow;
            document.getElementById('diffPreviewCount').textContent = state.transferQueue.length;
            
            // Tabelle rendern
            const tableContainer = document.getElementById('diffPreviewTable');
            
            // Ermittle ob Flag/Kommentar aktiv sind
            const flagEnabled = isFlagEnabled();
            const commentEnabled = isCommentEnabled();
            const flagCol = getFlagColumn();      // 1-basiert
            const commentCol = getCommentColumn(); // 1-basiert
            
            // Header erstellen - Zeile zuerst, dann Spalten wie sie in der Zieldatei erscheinen
            let headerHtml = '<tr><th style="width: 50px; text-align: center;">#</th>';
            
            // Spalten√ºberschriften aus der Zieldatei verwenden
            const targetHeaders = state.file2.headers || [];
            // Automatisch berechnete Startspalte (0-basiert)
            const targetStartCol = getDataStartColumn() - 1;
            
            // Berechne welche Spalten in der Vorschau angezeigt werden sollen
            // Zeige alle Spalten von der niedrigsten bis zur h√∂chsten belegten Spalte
            const previewColumns = [];
            
            // Sammle alle belegten Spaltenindizes
            const usedColumns = new Map(); // index -> {type, sourceIndex?, name}
            
            // Flag-Spalte (wenn aktiv)
            if (flagEnabled) {
                usedColumns.set(flagCol - 1, {
                    type: 'flag',
                    name: targetHeaders[flagCol - 1] || `Flag`
                });
            }
            
            // Kommentar-Spalte (wenn aktiv)
            if (commentEnabled) {
                usedColumns.set(commentCol - 1, {
                    type: 'comment',
                    name: targetHeaders[commentCol - 1] || `Kommentar`
                });
            }
            
            // Daten-Spalten aus dem Mapping
            state.mapping.sourceColumns.forEach((srcIdx, i) => {
                const targetColIdx = targetStartCol + i;
                usedColumns.set(targetColIdx, {
                    type: 'data',
                    sourceIndex: srcIdx,
                    name: targetHeaders[targetColIdx] || `Spalte ${String.fromCharCode(65 + targetColIdx)}`
                });
            });
            
            // Finde min und max Spaltenindex
            const colIndices = Array.from(usedColumns.keys());
            const minCol = Math.min(...colIndices);
            const maxCol = Math.max(...colIndices);
            
            // Erstelle Spalten von min bis max (inkl. leerer Spalten)
            for (let i = minCol; i <= maxCol; i++) {
                if (usedColumns.has(i)) {
                    previewColumns.push({
                        index: i,
                        ...usedColumns.get(i)
                    });
                } else {
                    // Leere Spalte
                    previewColumns.push({
                        index: i,
                        type: 'empty',
                        name: targetHeaders[i] || `-`
                    });
                }
            }
            
            // Header-Zeile erstellen
            previewColumns.forEach(col => {
                const colLetter = String.fromCharCode(65 + col.index);
                const style = col.type === 'flag' ? 'background: rgba(33, 115, 70, 0.3);' : 
                              col.type === 'comment' ? 'background: rgba(33, 115, 70, 0.2);' : 
                              col.type === 'empty' ? 'background: rgba(128, 128, 128, 0.1); color: var(--text-muted);' : '';
                headerHtml += `<th style="${style}"><small style="color: var(--text-muted);">${colLetter}</small><br>${escapeHtml(col.name)}</th>`;
            });
            headerHtml += '</tr>';
            
            // Zeilen rendern
            let rowsHtml = '';
            state.transferQueue.forEach((item, idx) => {
                const rowNum = startRow + idx;
                const flagClass = item.flag === 'A' ? 'diff-row-add' : 
                                  item.flag === 'D' ? 'diff-row-delete' : 
                                  item.flag === 'C' ? 'diff-row-change' : '';
                
                rowsHtml += `<tr class="${flagClass}">`;
                rowsHtml += `<td style="text-align: center; font-weight: bold; color: var(--text-muted);">${rowNum}</td>`;
                
                // Zellen in der richtigen Reihenfolge
                previewColumns.forEach(col => {
                    if (col.type === 'flag') {
                        const flagValue = item.flag || '';
                        const flagStyle = 'font-weight: bold; text-align: center; background: rgba(33, 115, 70, 0.15);';
                        rowsHtml += `<td style="${flagStyle}"><span class="diff-flag">${flagValue}</span></td>`;
                    } else if (col.type === 'comment') {
                        const commentValue = item.comment || '';
                        const commentStyle = 'font-style: italic; background: rgba(33, 115, 70, 0.1);';
                        rowsHtml += `<td style="${commentStyle}">${escapeHtml(String(commentValue))}</td>`;
                    } else if (col.type === 'empty') {
                        // Leere Spalte - wird nicht beschrieben
                        rowsHtml += `<td style="color: var(--text-muted); text-align: center;">-</td>`;
                    } else {
                        const cellValue = item.data[col.sourceIndex] !== undefined ? item.data[col.sourceIndex] : '';
                        rowsHtml += `<td>${escapeHtml(String(cellValue))}</td>`;
                    }
                });
                
                rowsHtml += '</tr>';
            });
            
            tableContainer.innerHTML = `
                <table class="diff-table">
                    <thead>${headerHtml}</thead>
                    <tbody>${rowsHtml}</tbody>
                </table>
            `;
            
            // Modal anzeigen
            modal.classList.remove('hidden');
        }
        
        function closeDiffPreview() {
            elements.diffPreviewModal.classList.add('hidden');
        }
        
        function confirmTransferFromDiff() {
            closeDiffPreview();
            transferQueueToExcel();
        }
        
        // ==================== Working Directory Functions ====================
        async function selectWorkingDirectory() {
            try {
                const folderPath = await window.electronAPI.openFolderDialog({
                    title: t('selectWorkingDir') || 'Arbeitsordner ausw√§hlen'
                });
                
                if (!folderPath) return;
                
                state.workingDirectory = folderPath;
                updateWorkingDirectoryUI();
                
                // Im localStorage speichern f√ºr Persistenz
                localStorage.setItem('workingDirectory', folderPath);
                
                showStatus(elements.transferStatus, `‚úì ${t('workingDirSet')}${folderPath}`, 'success');
            } catch (err) {
                console.error('Fehler beim Ausw√§hlen des Arbeitsordners:', err);
                showStatus(elements.transferStatus, `Fehler: ${err.message}`, 'error');
            }
        }
        
        function clearWorkingDirectory() {
            state.workingDirectory = null;
            localStorage.removeItem('workingDirectory');
            updateWorkingDirectoryUI();
            showStatus(elements.transferStatus, `‚úì ${t('workingDirCleared')}`, 'success');
        }
        
        function updateWorkingDirectoryUI() {
            if (state.workingDirectory) {
                // Zeige den Ordnernamen (letzter Teil des Pfads)
                const folderName = state.workingDirectory.split(/[/\\]/).pop();
                elements.workingDirInfo.textContent = `‚úì ${folderName}`;
                elements.workingDirInfo.title = state.workingDirectory;
                elements.workingDirInfo.classList.add('loaded');
                elements.btnClearWorkingDir.style.display = 'block';
            } else {
                elements.workingDirInfo.textContent = t('noWorkingDirSet');
                elements.workingDirInfo.title = '';
                elements.workingDirInfo.classList.remove('loaded');
                elements.btnClearWorkingDir.style.display = 'none';
            }
        }
        
        function getWorkingDirectoryPath() {
            return state.workingDirectory || undefined;
        }
        
        // Arbeitsordner beim Start laden
        function loadWorkingDirectoryFromStorage() {
            const savedPath = localStorage.getItem('workingDirectory');
            if (savedPath) {
                state.workingDirectory = savedPath;
                updateWorkingDirectoryUI();
            }
        }
        
        // ==================== Electron-Specific Functions ====================
        async function loadFile1Electron() {
            const filePath = await window.electronAPI.openFileDialog({
                title: 'Quelldatei √∂ffnen',
                filters: [{ name: 'Excel', extensions: ['xlsx', 'xls'] }],
                defaultPath: getWorkingDirectoryPath()
            });
            if (!filePath) return;
            
            const result = await window.electronAPI.readExcelFile(filePath);
            if (!result.success) {
                showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                return;
            }
            
            state.file1.name = result.fileName;
            state.file1.filePath = filePath;
            state.file1.sheets = result.sheets;
            state.file1.workbook = { SheetNames: result.sheets };
            
            elements.selectSheet1.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
            elements.selectSheet1.disabled = false;
            elements.file1Info.textContent = `‚úì ${result.fileName}`;
            elements.file1Info.classList.add('loaded');
            
            await loadSheet1Electron(result.sheets[0]);
        }
        
        async function loadFile2Electron() {
            const filePath = await window.electronAPI.openFileDialog({
                title: 'Zieldatei √∂ffnen',
                filters: [{ name: 'Excel', extensions: ['xlsx', 'xls'] }],
                defaultPath: getWorkingDirectoryPath()
            });
            if (!filePath) return;
            
            const result = await window.electronAPI.readExcelFile(filePath);
            if (!result.success) {
                showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                return;
            }
            
            state.file2.name = result.fileName;
            state.file2.filePath = filePath;
            state.file2.sheets = result.sheets;
            state.file2.workbook = { SheetNames: result.sheets };
            
            elements.selectSheet2.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
            elements.selectSheet2.disabled = false;
            elements.file2Info.textContent = `‚úì ${result.fileName}`;
            elements.file2Info.classList.add('loaded');
            
            await loadSheet2Electron(result.sheets[0]);
        }
        
        async function loadSheet1Electron(sheetName) {
            if (!state.file1.filePath || !sheetName) return;
            
            const result = await window.electronAPI.readExcelSheet(state.file1.filePath, sheetName);
            if (!result.success) {
                showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                return;
            }
            
            state.file1.selectedSheet = sheetName;
            state.file1.headers = result.headers;
            state.file1.data = result.data.slice(1);
            
            saveConfig();
            checkReadyState();
        }
        
        async function loadSheet2Electron(sheetName) {
            if (!state.file2.filePath || !sheetName) return;
            
            const result = await window.electronAPI.readExcelSheet(state.file2.filePath, sheetName);
            if (!result.success) {
                showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                return;
            }
            
            state.file2.selectedSheet = sheetName;
            state.file2.headers = result.headers;
            state.file2.data = result.data.slice(1);
            
            saveConfig();
            checkReadyState();
        }
        
        async function loadTemplateElectron() {
            const filePath = await window.electronAPI.openFileDialog({
                title: 'Template-Datei √∂ffnen',
                filters: [{ name: 'Excel', extensions: ['xlsx', 'xls'] }],
                defaultPath: getWorkingDirectoryPath()
            });
            if (!filePath) return;
            
            const result = await window.electronAPI.readExcelFile(filePath);
            if (!result.success) {
                showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                return;
            }
            
            state.template.filePath = filePath;
            state.template.name = result.fileName;
            
            elements.templateInfo.textContent = `‚úì ${result.fileName}`;
            elements.templateInfo.classList.add('loaded');
            elements.btnNewMonth.disabled = false;
            
            showStatus(elements.transferStatus, `‚úì Template geladen: ${result.fileName}`, 'success');
        }
        
        /**
         * Erstellt ein Template aus einer Quelldatei mit allen Formatierungen
         * - √ñffnet Quelldatei-Dialog
         * - Zeigt Sheet-Auswahl Modal
         * - √ñffnet Speicher-Dialog f√ºr neues Template
         * - Erstellt leeres Template mit erweiterten CF-Ranges
         */
        
        // State f√ºr Template-Erstellung
        let createTemplateState = {
            sourcePath: null,
            sheets: []
        };
        
        async function createTemplateFromSourceElectron() {
            const lang = localStorage.getItem('excelSyncLanguage') || 'de';
            const isDE = lang === 'de';
            
            // 1. Quelldatei ausw√§hlen
            const sourcePath = await window.electronAPI.openFileDialog({
                title: isDE ? 'Quelldatei ausw√§hlen (mit Formatierungen)' : 'Select source file (with formatting)',
                filters: [{ name: 'Excel', extensions: ['xlsx'] }],
                defaultPath: getWorkingDirectoryPath()
            });
            if (!sourcePath) return;
            
            // 2. Datei lesen um Sheets zu bekommen
            const fileResult = await window.electronAPI.readExcelFile(sourcePath);
            if (!fileResult.success) {
                showStatus(elements.transferStatus, `‚ùå ${isDE ? 'Fehler' : 'Error'}: ${fileResult.error}`, 'error');
                return;
            }
            
            // State speichern
            createTemplateState.sourcePath = sourcePath;
            createTemplateState.sheets = fileResult.sheets;
            
            // 3. Modal mit Sheet-Auswahl anzeigen
            elements.createTemplateSourceName.textContent = fileResult.fileName;
            
            // Sheet-Liste aufbauen
            const sheetListHtml = fileResult.sheets.map((sheetName, index) => `
                <label style="display: flex; align-items: center; padding: 6px 8px; cursor: pointer; border-radius: 4px; transition: background 0.2s;" 
                       onmouseover="this.style.background='var(--bg-medium)'" 
                       onmouseout="this.style.background='transparent'">
                    <input type="checkbox" class="template-sheet-checkbox" value="${sheetName}" checked 
                           style="margin-right: 10px; width: 16px; height: 16px; cursor: pointer;">
                    <span style="flex: 1;">${sheetName}</span>
                    <span style="color: var(--text-muted); font-size: 11px;">Sheet ${index + 1}</span>
                </label>
            `).join('');
            
            elements.createTemplateSheetList.innerHTML = sheetListHtml;
            
            // Modal anzeigen
            elements.createTemplateModal.classList.remove('hidden');
        }
        
        async function confirmCreateTemplate() {
            const lang = localStorage.getItem('excelSyncLanguage') || 'de';
            const isDE = lang === 'de';
            
            // Ausgew√§hlte Sheets sammeln
            const checkboxes = document.querySelectorAll('.template-sheet-checkbox:checked');
            const selectedSheets = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedSheets.length === 0) {
                showStatus(elements.transferStatus, isDE ? '‚ö†Ô∏è Bitte mindestens ein Arbeitsblatt ausw√§hlen' : '‚ö†Ô∏è Please select at least one worksheet', 'error');
                return;
            }
            
            // Extra-Spalten Optionen lesen
            const addFlagColumn = document.getElementById('templateFlagColumn').checked;
            const addCommentColumn = document.getElementById('templateCommentColumn').checked;
            
            // Modal schlie√üen
            elements.createTemplateModal.classList.add('hidden');
            
            // Speicherort f√ºr Template w√§hlen
            const outputPath = await window.electronAPI.saveFileDialog({
                title: isDE ? 'Template speichern als' : 'Save template as',
                defaultPath: createTemplateState.sourcePath.replace('.xlsx', '_Template.xlsx'),
                filters: [{ name: 'Excel', extensions: ['xlsx'] }]
            });
            if (!outputPath) return;
            
            // Template erstellen
            showStatus(elements.transferStatus, isDE ? '‚è≥ Template wird erstellt...' : '‚è≥ Creating template...', 'pending');
            
            const result = await window.electronAPI.createTemplateFromSource({
                sourcePath: createTemplateState.sourcePath,
                outputPath,
                selectedSheets,
                addFlagColumn,
                addCommentColumn
            });
            
            if (!result.success) {
                showStatus(elements.transferStatus, `‚ùå ${isDE ? 'Fehler' : 'Error'}: ${result.error}`, 'error');
                return;
            }
            
            // Erfolgsmeldung mit Stats
            const stats = result.stats;
            const extraInfo = stats.extraColumnsAdded > 0 
                ? (isDE ? `, ${stats.extraColumnsAdded} Extra-Spalte(n)` : `, ${stats.extraColumnsAdded} extra column(s)`)
                : '';
            const msg = isDE 
                ? `‚úì Template erstellt: ${result.fileName}\n   (${stats.sheetsProcessed} Sheet(s), ${stats.cfRulesPreserved} CF-Regeln${extraInfo})`
                : `‚úì Template created: ${result.fileName}\n   (${stats.sheetsProcessed} sheet(s), ${stats.cfRulesPreserved} CF rules${extraInfo})`;
            
            showStatus(elements.transferStatus, msg, 'success');
            
            // Template automatisch laden
            const loadResult = await window.electronAPI.readExcelFile(outputPath);
            if (loadResult.success) {
                state.template.filePath = outputPath;
                state.template.name = loadResult.fileName;
                
                elements.templateInfo.textContent = `‚úì ${loadResult.fileName}`;
                elements.templateInfo.classList.add('loaded');
                elements.btnNewMonth.disabled = false;
            }
        }
        
        function closeCreateTemplateModal() {
            elements.createTemplateModal.classList.add('hidden');
        }
        
        async function applyLoadedConfig(config) {
            state.mapping = config.mapping || state.mapping;
            
            // Extra-Spalten Konfiguration laden
            if (config.extraColumns) {
                const ec = config.extraColumns;
                const flagCheckbox = document.getElementById('enableFlagColumn');
                const commentCheckbox = document.getElementById('enableCommentColumn');
                const flagValuesInput = document.getElementById('flagValues');
                const commentPlaceholderInput = document.getElementById('commentPlaceholder');
                
                if (ec.enableFlag !== undefined && flagCheckbox) {
                    flagCheckbox.checked = ec.enableFlag;
                    localStorage.setItem('excelSyncEnableFlag', String(ec.enableFlag));
                }
                if (ec.enableComment !== undefined && commentCheckbox) {
                    commentCheckbox.checked = ec.enableComment;
                    localStorage.setItem('excelSyncEnableComment', String(ec.enableComment));
                }
                if (ec.flagValues && flagValuesInput) {
                    flagValuesInput.value = ec.flagValues;
                    localStorage.setItem('excelSyncFlagValues', ec.flagValues);
                }
                if (ec.commentPlaceholder && commentPlaceholderInput) {
                    commentPlaceholderInput.value = ec.commentPlaceholder;
                    localStorage.setItem('excelSyncCommentPlaceholder', ec.commentPlaceholder);
                }
                
                // UI aktualisieren
                updateFlagDropdownOptions();
                updateCommentPlaceholders();
                updateFlagCommentVisibility();
                updateColumnDisplays();
            }
            
            // Lade Dateien aus Pfaden
            if (config.file1Path) {
                try {
                    const result = await window.electronAPI.readExcelFile(config.file1Path);
                    if (result.success) {
                        state.file1.name = result.fileName;
                        state.file1.filePath = config.file1Path;
                        state.file1.sheets = result.sheets;
                        state.file1.workbook = { SheetNames: result.sheets };
                        
                        elements.selectSheet1.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
                        elements.selectSheet1.disabled = false;
                        elements.file1Info.textContent = `‚úì ${result.fileName}`;
                        elements.file1Info.classList.add('loaded');
                        
                        const sheetToLoad = config.file1SheetName && result.sheets.includes(config.file1SheetName) 
                            ? config.file1SheetName : result.sheets[0];
                        elements.selectSheet1.value = sheetToLoad;
                        await loadSheet1Electron(sheetToLoad);
                    }
                } catch (e) {
                    console.warn('Konnte Datei 1 nicht laden:', e);
                }
            }
            
            if (config.file2Path) {
                try {
                    const result = await window.electronAPI.readExcelFile(config.file2Path);
                    if (result.success) {
                        state.file2.name = result.fileName;
                        state.file2.filePath = config.file2Path;
                        state.file2.sheets = result.sheets;
                        state.file2.workbook = { SheetNames: result.sheets };
            
                        elements.selectSheet2.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
                        elements.selectSheet2.disabled = false;
                        elements.file2Info.textContent = `‚úì ${result.fileName}`;
                        elements.file2Info.classList.add('loaded');
                        
                        const sheetToLoad = config.file2SheetName && result.sheets.includes(config.file2SheetName) 
                            ? config.file2SheetName : result.sheets[0];
                        elements.selectSheet2.value = sheetToLoad;
                        await loadSheet2Electron(sheetToLoad);
                    }
                } catch (e) {
                    console.warn('Konnte Datei 2 nicht laden:', e);
                }
            }
            
            if (config.templatePath) {
                try {
                    const result = await window.electronAPI.readExcelFile(config.templatePath);
                    if (result.success) {
                        state.template.filePath = config.templatePath;
                        state.template.name = result.fileName;
                        elements.templateInfo.textContent = `‚úì ${result.fileName}`;
                        elements.templateInfo.classList.add('loaded');
                        elements.btnNewMonth.disabled = false;
                    }
                } catch (e) {
                    console.warn('Konnte Template nicht laden:', e);
                }
            }
            
            updateMappingInfo();
            updateMappingPreview();
            saveConfig();
        }
        
        async function loadConfigFromAppDirOrDialog() {
            try {
                // Zuerst Dialog √∂ffnen
                const filePath = await window.electronAPI.openFileDialog({
                    title: 'config.json laden',
                    filters: [{ name: 'JSON', extensions: ['json'] }],
                    defaultPath: getWorkingDirectoryPath()
                });
                
                if (filePath) {
                    const result = await window.electronAPI.loadConfig(filePath);
                    if (result.success && result.config) {
                        await applyLoadedConfig(result.config);
                        showStatus(elements.transferStatus, `‚úì config.json geladen: ${filePath}`, 'success');
                    } else {
                        showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                    }
                }
            } catch (e) {
                showStatus(elements.transferStatus, `Fehler: ${e.message}`, 'error');
            }
        }
        
        // ==================== Data Explorer Functions ====================
        const explorerState = {
            filePath: null,
            fileName: null,
            sheets: [],
            selectedSheet: null,
            headers: [],
            data: [],
            originalData: [],  // Kopie der Originaldaten f√ºr Vorschau-Vergleich
            filteredData: [],  // Enth√§lt jetzt {originalIndex, row} Objekte
            searchTerm: '',
            filters: [],
            visibleColumns: [],
            columnOrder: [],  // Benutzerdefinierte Spaltenreihenfolge
            editedCells: new Map(),  // Speichert editierte Zellen: "rowIndex-colIndex" -> neuer Wert
            // Pagination
            currentPage: 1,
            pageSize: 100, // Zeilen pro Seite (konfigurierbar)
            pageSizeOptions: [50, 100, 250, 500, 1000],
            // Sortierung
            sortColumn: null,
            sortDirection: null,  // 'asc', 'desc' oder null
            sortType: 'auto',  // 'auto', 'alpha-asc', 'alpha-desc', 'num-asc', 'num-desc', 'date-asc', 'date-desc'
            // Zeilen-Markierungen
            rowHighlights: new Map(),  // rowIndex -> 'green'|'yellow'|'orange'|'red'|'blue'|'purple'
            // Zeilen-Auswahl f√ºr Verschiebung
            selectedRows: new Set(),  // Set von originalIndex Werten
            moveMode: false,  // Ob Verschiebe-Modus aktiv ist
            // Drag & Drop State
            draggedColumn: null,
            // Zellen-Auswahl f√ºr Mehrfach-Bearbeitung
            selectedCells: new Set(),  // Set von "rowIndex-colIndex" Strings
            selectionAnchor: null,  // {row, col} - Startpunkt der Auswahl
            isSelecting: false,  // Ob gerade eine Auswahl gezogen wird
            // Cache f√ºr Sheet-√Ñnderungen (bleibt bei Wechsel erhalten)
            sheetDataCache: new Map()  // sheetName -> { data, editedCells, rowHighlights, originalData }
        };
        
        // Kontextmen√º f√ºr Zeilen-Markierung
        const highlightColors = [
            { name: 'Gr√ºn', value: 'green', hex: '#4CAF50' },
            { name: 'Gelb', value: 'yellow', hex: '#FFEB3B' },
            { name: 'Orange', value: 'orange', hex: '#FF9800' },
            { name: 'Rot', value: 'red', hex: '#F44336' },
            { name: 'Blau', value: 'blue', hex: '#2196F3' },
            { name: 'Lila', value: 'purple', hex: '#9C27B0' }
        ];
        
        function showRowContextMenu(e, rowIndex) {
            e.preventDefault();
            
            // Altes Men√º entfernen
            const oldMenu = document.querySelector('.context-menu');
            if (oldMenu) oldMenu.remove();
            
            const currentColor = explorerState.rowHighlights.get(rowIndex);
            
            let menuHtml = '<div class="context-menu">';
            menuHtml += '<div class="context-menu-item" style="font-weight: 600; color: var(--text-muted); cursor: default;">üé® Zeile markieren</div>';
            menuHtml += '<div class="context-menu-divider"></div>';
            
            highlightColors.forEach(color => {
                const selected = currentColor === color.value ? ' ‚úì' : '';
                menuHtml += `
                    <div class="context-menu-item" data-action="highlight" data-color="${color.value}" data-row="${rowIndex}">
                        <span class="color-dot" style="background: ${color.hex};"></span>
                        <span>${color.name}${selected}</span>
                    </div>
                `;
            });
            
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="clear" data-row="${rowIndex}">üö´ Markierung entfernen</div>`;
            menuHtml += '</div>';
            
            const menu = document.createElement('div');
            menu.innerHTML = menuHtml;
            document.body.appendChild(menu.firstElementChild);
            
            const menuEl = document.querySelector('.context-menu');
            
            // Positionierung
            let x = e.clientX;
            let y = e.clientY;
            
            // Sicherstellen, dass das Men√º im Viewport bleibt
            const menuRect = menuEl.getBoundingClientRect();
            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 5;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 5;
            }
            
            menuEl.style.left = x + 'px';
            menuEl.style.top = y + 'px';
            
            // Event-Handler
            menuEl.querySelectorAll('[data-action="highlight"]').forEach(item => {
                item.addEventListener('click', () => {
                    const color = item.dataset.color;
                    const row = parseInt(item.dataset.row);
                    setRowHighlight(row, color);
                    menuEl.remove();
                });
            });
            
            menuEl.querySelector('[data-action="clear"]').addEventListener('click', () => {
                const row = parseInt(menuEl.querySelector('[data-action="clear"]').dataset.row);
                clearRowHighlight(row);
                menuEl.remove();
            });
            
            // Men√º bei Klick au√üerhalb schlie√üen
            const closeHandler = (event) => {
                if (!menuEl.contains(event.target)) {
                    menuEl.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            setTimeout(() => document.addEventListener('click', closeHandler), 10);
        }
        
        function setRowHighlight(rowIndex, color) {
            explorerState.rowHighlights.set(rowIndex, color);
            applyRowHighlights();
        }
        
        function clearRowHighlight(rowIndex) {
            explorerState.rowHighlights.delete(rowIndex);
            applyRowHighlights();
        }
        
        function applyRowHighlights() {
            // Alle Highlights entfernen
            document.querySelectorAll('#explorerTableBody tr').forEach(tr => {
                tr.classList.remove('row-highlight-green', 'row-highlight-yellow', 'row-highlight-orange', 
                                   'row-highlight-red', 'row-highlight-blue', 'row-highlight-purple');
            });
            
            // Neue Highlights setzen
            explorerState.rowHighlights.forEach((color, rowIndex) => {
                const tr = document.querySelector(`#explorerTableBody tr[data-original-index="${rowIndex}"]`);
                if (tr) {
                    tr.classList.add(`row-highlight-${color}`);
                }
            });
        }
        
        // ==================== Zellen-Auswahl Funktionen ====================
        
        // Zellen-Auswahl visuell aktualisieren
        function updateCellSelectionUI() {
            // Alle Auswahl-Markierungen entfernen
            document.querySelectorAll('#explorerTableBody td.cell-selected').forEach(td => {
                td.classList.remove('cell-selected', 'cell-selection-anchor');
            });
            
            // Ausgew√§hlte Zellen markieren
            explorerState.selectedCells.forEach(cellKey => {
                const [rowIndex, colIndex] = cellKey.split('-').map(Number);
                const td = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                if (td) {
                    td.classList.add('cell-selected');
                }
            });
            
            // Anker-Zelle hervorheben
            if (explorerState.selectionAnchor) {
                const anchorTd = document.querySelector(
                    `#explorerTableBody td[data-row="${explorerState.selectionAnchor.row}"][data-col="${explorerState.selectionAnchor.col}"]`
                );
                if (anchorTd) {
                    anchorTd.classList.add('cell-selection-anchor');
                }
            }
        }
        
        // Zellen-Auswahl leeren
        function clearCellSelection() {
            explorerState.selectedCells.clear();
            explorerState.selectionAnchor = null;
            explorerState.isSelecting = false;
            updateCellSelectionUI();
        }
        
        // Zelle zur Auswahl hinzuf√ºgen/entfernen
        function toggleCellSelection(rowIndex, colIndex, addToSelection = false) {
            const cellKey = `${rowIndex}-${colIndex}`;
            
            if (!addToSelection) {
                // Ohne Modifier: Alte Auswahl leeren
                explorerState.selectedCells.clear();
            }
            
            if (explorerState.selectedCells.has(cellKey)) {
                explorerState.selectedCells.delete(cellKey);
            } else {
                explorerState.selectedCells.add(cellKey);
            }
            
            explorerState.selectionAnchor = { row: rowIndex, col: colIndex };
            updateCellSelectionUI();
        }
        
        // Bereich von Zellen ausw√§hlen (Shift-Klick)
        function selectCellRange(toRow, toCol) {
            if (!explorerState.selectionAnchor) {
                explorerState.selectionAnchor = { row: toRow, col: toCol };
            }
            
            const fromRow = explorerState.selectionAnchor.row;
            const fromCol = explorerState.selectionAnchor.col;
            
            const minRow = Math.min(fromRow, toRow);
            const maxRow = Math.max(fromRow, toRow);
            const minCol = Math.min(fromCol, toCol);
            const maxCol = Math.max(fromCol, toCol);
            
            // Alte Auswahl leeren und neuen Bereich ausw√§hlen
            explorerState.selectedCells.clear();
            
            // Nur sichtbare Spalten ber√ºcksichtigen
            const displayColumns = explorerState.columnOrder.length > 0 
                ? explorerState.columnOrder.filter(col => explorerState.visibleColumns.includes(col))
                : explorerState.visibleColumns;
            
            // Alle Zeilen im Bereich finden
            for (let r = minRow; r <= maxRow; r++) {
                for (let c = minCol; c <= maxCol; c++) {
                    // Nur ausw√§hlen wenn die Spalte sichtbar ist
                    if (displayColumns.includes(c)) {
                        explorerState.selectedCells.add(`${r}-${c}`);
                    }
                }
            }
            
            updateCellSelectionUI();
        }
        
        // Kontextmen√º f√ºr Zellen-Auswahl
        function showCellContextMenu(e, rowIndex, colIndex) {
            e.preventDefault();
            e.stopPropagation();
            
            // Altes Men√º entfernen
            const oldMenu = document.querySelector('.context-menu');
            if (oldMenu) oldMenu.remove();
            
            const cellKey = `${rowIndex}-${colIndex}`;
            
            // Wenn die angeklickte Zelle nicht in der Auswahl ist, diese zur Auswahl machen
            if (!explorerState.selectedCells.has(cellKey)) {
                explorerState.selectedCells.clear();
                explorerState.selectedCells.add(cellKey);
                explorerState.selectionAnchor = { row: rowIndex, col: colIndex };
                updateCellSelectionUI();
            }
            
            const selectedCount = explorerState.selectedCells.size;
            const cellLabel = selectedCount === 1 ? 'Zelle' : `${selectedCount} Zellen`;
            
            let menuHtml = '<div class="context-menu">';
            menuHtml += `<div class="context-menu-item" style="font-weight: 600; color: var(--text-muted); cursor: default;">üìã ${cellLabel} ausgew√§hlt</div>`;
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="delete-content">üóëÔ∏è Inhalt l√∂schen</div>`;
            menuHtml += `<div class="context-menu-item" data-action="copy-content">üìã Kopieren</div>`;
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="clear-selection">‚ùå Auswahl aufheben</div>`;
            menuHtml += '</div>';
            
            const menu = document.createElement('div');
            menu.innerHTML = menuHtml;
            document.body.appendChild(menu.firstElementChild);
            
            const menuEl = document.querySelector('.context-menu');
            
            // Positionierung
            let x = e.clientX;
            let y = e.clientY;
            
            // Sicherstellen, dass das Men√º im Viewport bleibt
            const menuRect = menuEl.getBoundingClientRect();
            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 5;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 5;
            }
            
            menuEl.style.left = x + 'px';
            menuEl.style.top = y + 'px';
            
            // Event-Handler: Inhalt l√∂schen
            menuEl.querySelector('[data-action="delete-content"]').addEventListener('click', () => {
                deleteSelectedCellsContent();
                menuEl.remove();
            });
            
            // Event-Handler: Kopieren
            menuEl.querySelector('[data-action="copy-content"]').addEventListener('click', () => {
                copySelectedCellsContent();
                menuEl.remove();
            });
            
            // Event-Handler: Auswahl aufheben
            menuEl.querySelector('[data-action="clear-selection"]').addEventListener('click', () => {
                clearCellSelection();
                menuEl.remove();
            });
            
            // Men√º bei Klick au√üerhalb schlie√üen
            const closeHandler = (event) => {
                if (!menuEl.contains(event.target)) {
                    menuEl.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            setTimeout(() => document.addEventListener('click', closeHandler), 10);
        }
        
        // Ausgew√§hlte Zelleninhalte l√∂schen
        function deleteSelectedCellsContent() {
            if (explorerState.selectedCells.size === 0) return;
            
            const undoActions = [];
            
            explorerState.selectedCells.forEach(cellKey => {
                const [rowIndex, colIndex] = cellKey.split('-').map(Number);
                const td = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                
                if (td) {
                    const oldValue = explorerState.data[rowIndex][colIndex];
                    const originalValue = td.dataset.original;
                    
                    // Undo-Aktion speichern
                    undoActions.push({
                        rowIndex,
                        colIndex,
                        oldValue: String(oldValue ?? ''),
                        newValue: '',
                        originalValue
                    });
                    
                    // Daten aktualisieren
                    explorerState.data[rowIndex][colIndex] = '';
                    explorerState.editedCells.set(cellKey, '');
                    
                    // UI aktualisieren
                    td.textContent = '';
                    td.dataset.lastValue = '';
                    td.classList.add('edited');
                }
            });
            
            // Alle √Ñnderungen als eine Undo-Aktion speichern
            if (undoActions.length > 0) {
                pushExplorerUndo({
                    type: 'multi',
                    actions: undoActions
                });
            }
            
            // Status aktualisieren
            updateExplorerEditStatus();
            
            // Auswahl leeren
            clearCellSelection();
            
            // Info anzeigen
            showFloatingStatus(`${undoActions.length} Zelle(n) gel√∂scht`);
        }
        
        // Ausgew√§hlte Zelleninhalte kopieren
        function copySelectedCellsContent() {
            if (explorerState.selectedCells.size === 0) return;
            
            // Zellen nach Position sortieren
            const cells = Array.from(explorerState.selectedCells).map(key => {
                const [row, col] = key.split('-').map(Number);
                return { row, col, value: explorerState.data[row][col] ?? '' };
            }).sort((a, b) => a.row - b.row || a.col - b.col);
            
            // Nach Zeilen gruppieren
            const rows = new Map();
            cells.forEach(cell => {
                if (!rows.has(cell.row)) {
                    rows.set(cell.row, []);
                }
                rows.get(cell.row).push(String(cell.value));
            });
            
            // Als Tab-getrennten Text formatieren
            const text = Array.from(rows.values())
                .map(rowCells => rowCells.join('\t'))
                .join('\n');
            
            navigator.clipboard.writeText(text).then(() => {
                showFloatingStatus(`${explorerState.selectedCells.size} Zelle(n) kopiert`);
            }).catch(err => {
                console.error('Kopieren fehlgeschlagen:', err);
                showFloatingStatus('Kopieren fehlgeschlagen', true);
            });
        }
        
        // Floating Status Nachricht anzeigen
        function showFloatingStatus(message, isError = false) {
            // Alte Nachricht entfernen
            const oldStatus = document.querySelector('.floating-status');
            if (oldStatus) oldStatus.remove();
            
            const status = document.createElement('div');
            status.className = 'floating-status';
            status.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: ${isError ? '#F44336' : 'var(--primary)'};
                color: white;
                padding: 10px 20px;
                border-radius: 6px;
                z-index: 10001;
                font-size: 13px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: fadeInUp 0.3s ease;
            `;
            status.textContent = message;
            document.body.appendChild(status);
            
            setTimeout(() => {
                status.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => status.remove(), 300);
            }, 2000);
        }

        function openDataExplorer() {
            elements.dataExplorerModal.classList.remove('hidden');
            document.body.classList.add('modal-open');
        }
        
        function closeDataExplorer() {
            elements.dataExplorerModal.classList.add('hidden');
            document.body.classList.remove('modal-open');
        }
        
        // Explorer-Vorschau zeigen (zeigt genau das was exportiert wird)
        function showExplorerPreview() {
            if (!explorerState.filteredData || explorerState.filteredData.length === 0) {
                return;
            }
            
            const modal = document.getElementById('explorerPreviewModal');
            const tableContainer = document.getElementById('previewTableContainer');
            
            // Gleiche Daten wie beim Export verwenden
            const exportData = explorerState.filteredData.map(item => item.row);
            const visibleColumns = explorerState.visibleColumns;
            
            // Info aktualisieren
            document.getElementById('previewFileName').textContent = explorerState.fileName || 'Unbekannt';
            document.getElementById('previewSheetName').textContent = explorerState.selectedSheet || 'Sheet1';
            document.getElementById('previewRowCount').textContent = exportData.length;
            document.getElementById('previewColCount').textContent = visibleColumns.length;
            document.getElementById('previewEditCount').textContent = explorerState.editedCells.size;
            
            // Header erstellen (nur sichtbare Spalten)
            let headerHtml = '<tr><th style="width: 50px; text-align: center; position: sticky; left: 0; background: var(--bg-medium); z-index: 2;">#</th>';
            visibleColumns.forEach(colIdx => {
                const colLetter = String.fromCharCode(65 + colIdx);
                const header = explorerState.headers[colIdx] || '-';
                headerHtml += `<th style="min-width: 120px;"><small style="color: var(--text-muted);">${colLetter}</small><br>${escapeHtml(header)}</th>`;
            });
            headerHtml += '</tr>';
            
            // Zeilen erstellen (mit bearbeiteten Werten - genau wie beim Export)
            let rowsHtml = '';
            explorerState.filteredData.forEach((item, displayIdx) => {
                const originalIndex = item.originalIndex;
                const row = item.row;
                
                // Pr√ºfe ob diese Zeile bearbeitete Zellen hat
                let hasEdits = false;
                for (const colIdx of visibleColumns) {
                    if (explorerState.editedCells.has(`${originalIndex}-${colIdx}`)) {
                        hasEdits = true;
                        break;
                    }
                }
                
                const rowStyle = hasEdits ? 'background: rgba(255, 193, 7, 0.05);' : '';
                rowsHtml += `<tr style="${rowStyle}">`;
                rowsHtml += `<td style="text-align: center; font-weight: bold; color: var(--text-muted); position: sticky; left: 0; background: var(--bg-dark); z-index: 1;">${displayIdx + 1}</td>`;
                
                visibleColumns.forEach(colIdx => {
                    const cellKey = `${originalIndex}-${colIdx}`;
                    const isEdited = explorerState.editedCells.has(cellKey);
                    
                    // Hole den Wert direkt aus der Zeile (enth√§lt bereits Bearbeitungen)
                    const cellValue = row[colIdx] !== undefined ? String(row[colIdx]) : '';
                    
                    const cellStyle = isEdited 
                        ? 'background: rgba(255, 193, 7, 0.3); border: 2px solid #FFC107;' 
                        : '';
                    
                    rowsHtml += `<td style="${cellStyle}">${escapeHtml(cellValue)}</td>`;
                });
                
                rowsHtml += '</tr>';
            });
            
            tableContainer.innerHTML = `
                <table class="results-table" style="width: max-content; min-width: 100%;">
                    <thead style="position: sticky; top: 0; z-index: 3;">${headerHtml}</thead>
                    <tbody>${rowsHtml}</tbody>
                </table>
            `;
            
            // Modal anzeigen
            modal.classList.remove('hidden');
        }
        
        function closeExplorerPreview() {
            document.getElementById('explorerPreviewModal').classList.add('hidden');
        }
        
        async function loadExplorerFile() {
            // Pr√ºfe auf ungespeicherte √Ñnderungen
            if (hasUnsavedChanges()) {
                const totalChanges = countAllChanges();
                const confirmed = await showConfirmDialog(
                    'Ungespeicherte √Ñnderungen',
                    `Sie haben ${totalChanges} ungespeicherte √Ñnderung(en).\n\n` +
                    `M√∂chten Sie trotzdem eine neue Datei √∂ffnen?\n\n` +
                    `‚ö†Ô∏è Alle √Ñnderungen gehen verloren!`,
                    'Neue Datei √∂ffnen',
                    'Abbrechen'
                );
                if (!confirmed) return;
            }
            
            const filePath = await window.electronAPI.openFileDialog({
                title: 'Excel-Datei √∂ffnen',
                filters: [{ name: 'Excel', extensions: ['xlsx', 'xls'] }],
                defaultPath: getWorkingDirectoryPath()
            });
            if (!filePath) return;
            
            const result = await window.electronAPI.readExcelFile(filePath);
            if (!result.success) {
                elements.explorerStatus.textContent = `Fehler: ${result.error}`;
                return;
            }
            
            // Cache leeren bei neuer Datei
            explorerState.sheetDataCache.clear();
            explorerState.editedCells.clear();
            explorerState.rowHighlights.clear();
            
            explorerState.filePath = filePath;
            explorerState.fileName = result.fileName;
            explorerState.sheets = result.sheets;
            
            // Element frisch abfragen (kann durch setLanguage ersetzt worden sein)
            const explorerFileNameEl = document.getElementById('explorerFileName');
            if (explorerFileNameEl) explorerFileNameEl.textContent = result.fileName;
            elements.explorerSheetSelect.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
            
            await loadExplorerSheet(result.sheets[0]);
        }
        
        async function loadExplorerSheet(sheetName) {
            if (!explorerState.filePath || !sheetName) return;
            
            // VOR dem Wechsel: Aktuelles Sheet im Cache speichern wenn es √Ñnderungen gibt
            if (explorerState.selectedSheet && explorerState.data.length > 0) {
                saveCurrentSheetToCache();
            }
            
            // Loading-Status anzeigen
            elements.explorerStatus.textContent = 'Lade Daten...';
            
            // Pr√ºfe ob dieses Sheet bereits im Cache ist
            const cachedSheet = explorerState.sheetDataCache.get(sheetName);
            
            if (cachedSheet) {
                // Aus Cache laden
                explorerState.selectedSheet = sheetName;
                explorerState.headers = cachedSheet.headers;
                explorerState.data = cachedSheet.data.map(row => [...row]); // Deep copy
                explorerState.originalData = cachedSheet.originalData.map(row => [...row]);
                explorerState.editedCells = new Map(cachedSheet.editedCells);
                explorerState.rowHighlights = new Map(cachedSheet.rowHighlights);
                explorerState.visibleColumns = [...cachedSheet.visibleColumns];
                explorerState.columnOrder = [...(cachedSheet.columnOrder || [])];
                
                // UI-State zur√ºcksetzen
                explorerState.filteredData = explorerState.data.map((row, index) => ({ originalIndex: index, row: row }));
                explorerState.currentPage = 1;
                explorerState.searchTerm = '';
                explorerState.sortColumn = null;
                explorerState.sortDirection = null;
                elements.explorerSearch.value = '';
                
                const editCount = explorerState.editedCells.size;
                if (editCount > 0) {
                    elements.explorerStatus.textContent = `Aus Cache geladen (${editCount} √Ñnderungen)`;
                } else {
                    elements.explorerStatus.textContent = '';
                }
                
                renderExplorerTable();
                updateColumnToggles();
                updateExplorerEditStatus();
                return;
            }
            
            // Von Datei laden
            const result = await window.electronAPI.readExcelSheet(explorerState.filePath, sheetName);
            if (!result.success) {
                elements.explorerStatus.textContent = `Fehler: ${result.error}`;
                return;
            }
            
            explorerState.selectedSheet = sheetName;
            explorerState.headers = result.headers;
            explorerState.data = result.data.slice(1);
            // Kopie der Originaldaten speichern (deep copy)
            explorerState.originalData = explorerState.data.map(row => [...row]);
            // Alle Spalten standardm√§√üig sichtbar machen
            explorerState.visibleColumns = explorerState.headers.map((_, i) => i);
            explorerState.columnOrder = []; // Reset column order
            // filteredData mit originalIndex initialisieren
            explorerState.filteredData = explorerState.data.map((row, index) => ({ originalIndex: index, row: row }));
            explorerState.currentPage = 1; // Pagination zur√ºcksetzen
            explorerState.searchTerm = ''; // Suche zur√ºcksetzen
            explorerState.sortColumn = null; // Sortierung zur√ºcksetzen
            explorerState.sortDirection = null;
            explorerState.editedCells.clear(); // Bearbeitungen zur√ºcksetzen
            explorerState.rowHighlights.clear(); // Highlights zur√ºcksetzen
            elements.explorerSearch.value = '';
            
            // Pr√ºfe ob es gespeicherte Bearbeitungen gibt (Auto-Save Recovery)
            if (window._pendingExplorerRestore && 
                window._pendingExplorerRestore.filePath === explorerState.filePath &&
                window._pendingExplorerRestore.selectedSheet === sheetName) {
                
                const restore = window._pendingExplorerRestore;
                let restoredCount = 0;
                
                restore.editedCells.forEach(([key, value]) => {
                    const [rowStr, colStr] = key.split('-');
                    const rowIndex = parseInt(rowStr);
                    const colIndex = parseInt(colStr);
                    
                    if (rowIndex < explorerState.data.length && colIndex < explorerState.headers.length) {
                        explorerState.editedCells.set(key, value);
                        explorerState.data[rowIndex][colIndex] = value;
                        restoredCount++;
                    }
                });
                
                if (restoredCount > 0) {
                    showUndoRedoFeedback(`${restoredCount} Bearbeitungen wiederhergestellt`);
                }
                
                delete window._pendingExplorerRestore;
            }
            
            // Status-Meldung f√ºr gro√üe Dateien
            if (explorerState.data.length > 1000) {
                elements.explorerStatus.textContent = `${explorerState.data.length} Zeilen geladen (Pagination aktiv)`;
            } else {
                elements.explorerStatus.textContent = '';
            }
            
            renderExplorerTable();
            updateColumnToggles();
        }
        
        // Speichert das aktuelle Sheet im Cache
        function saveCurrentSheetToCache() {
            if (!explorerState.selectedSheet) return;
            
            explorerState.sheetDataCache.set(explorerState.selectedSheet, {
                headers: [...explorerState.headers],
                data: explorerState.data.map(row => [...row]),
                originalData: explorerState.originalData.map(row => [...row]),
                editedCells: new Map(explorerState.editedCells),
                rowHighlights: new Map(explorerState.rowHighlights),
                visibleColumns: [...explorerState.visibleColumns],
                columnOrder: [...explorerState.columnOrder]
            });
        }
        
        // Pr√ºft ob es ungespeicherte √Ñnderungen in irgendeinem Sheet gibt
        function hasUnsavedChanges() {
            // Aktuelles Sheet pr√ºfen
            if (explorerState.editedCells.size > 0) return true;
            
            // Cache pr√ºfen
            for (const [sheetName, cached] of explorerState.sheetDataCache) {
                if (cached.editedCells.size > 0) return true;
            }
            
            return false;
        }
        
        // Z√§hlt alle √Ñnderungen √ºber alle Sheets
        function countAllChanges() {
            let total = explorerState.editedCells.size;
            
            for (const [sheetName, cached] of explorerState.sheetDataCache) {
                if (sheetName !== explorerState.selectedSheet) {
                    total += cached.editedCells.size;
                }
            }
            
            return total;
        }
        
        function filterExplorerData() {
            // Erstelle Array mit originalem Index f√ºr jede Zeile
            let filtered = explorerState.data.map((row, index) => ({ originalIndex: index, row: row }));
            
            // Volltextsuche mit Platzhalter-Unterst√ºtzung (* und ?)
            if (explorerState.searchTerm) {
                const term = explorerState.searchTerm;
                const hasWildcards = term.includes('*') || term.includes('?');
                
                if (hasWildcards) {
                    // Platzhalter-Suche: * = beliebig viele Zeichen, ? = ein Zeichen
                    const regex = wildcardToRegex(term);
                    filtered = filtered.filter(item => 
                        item.row.some(cell => cell && regex.test(String(cell)))
                    );
                } else {
                    // Normale Suche (case-insensitive, enth√§lt)
                    const lowerTerm = term.toLowerCase();
                    filtered = filtered.filter(item => 
                        item.row.some(cell => cell && String(cell).toLowerCase().includes(lowerTerm))
                    );
                }
            }
            
            // Spaltenfilter
            explorerState.filters.forEach(filter => {
                if (!filter.column || !filter.value) return;
                const colIndex = parseInt(filter.column);
                const value = filter.value.toLowerCase();
                
                filtered = filtered.filter(item => {
                    const cellValue = String(item.row[colIndex] || '').toLowerCase();
                    switch (filter.operator) {
                        case 'contains': return cellValue.includes(value);
                        case 'equals': return cellValue === value;
                        case 'startsWith': return cellValue.startsWith(value);
                        case 'endsWith': return cellValue.endsWith(value);
                        default: return true;
                    }
                });
            });
            
            explorerState.filteredData = filtered;
            explorerState.currentPage = 1; // Bei Filter√§nderung zur√ºck zur ersten Seite
            
            // Sortierung anwenden, wenn eine gesetzt ist
            if (explorerState.sortColumn !== null && explorerState.sortDirection !== null) {
                applyExplorerSort();
            }
            
            renderExplorerTable();
        }
        
        /**
         * Sortiert die Explorer-Daten nach einer Spalte
         */
        function sortExplorerByColumn(colIndex, sortType = 'auto') {
            // Toggle Sortierrichtung bei 'auto'
            if (sortType === 'auto') {
                if (explorerState.sortColumn === colIndex) {
                    if (explorerState.sortDirection === 'asc') {
                        explorerState.sortDirection = 'desc';
                    } else if (explorerState.sortDirection === 'desc') {
                        // Dritter Klick: Sortierung aufheben
                        explorerState.sortColumn = null;
                        explorerState.sortDirection = null;
                        explorerState.sortType = 'auto';
                        filterExplorerData(); // Neu filtern ohne Sortierung
                        return;
                    }
                } else {
                    explorerState.sortColumn = colIndex;
                    explorerState.sortDirection = 'asc';
                }
                explorerState.sortType = 'auto';
            } else {
                // Expliziter Sortiertyp vom Kontextmen√º
                explorerState.sortColumn = colIndex;
                explorerState.sortType = sortType;
                // Direction aus dem sortType ableiten
                explorerState.sortDirection = sortType.endsWith('-asc') ? 'asc' : 'desc';
            }
            
            applyExplorerSort();
            renderExplorerTable();
        }
        
        /**
         * Wendet die aktuelle Sortierung auf filteredData an
         */
        function applyExplorerSort() {
            if (explorerState.sortColumn === null) return;
            
            const colIndex = explorerState.sortColumn;
            const direction = explorerState.sortDirection;
            const sortType = explorerState.sortType || 'auto';
            
            explorerState.filteredData.sort((a, b) => {
                const valA = a.row[colIndex];
                const valB = b.row[colIndex];
                
                // Null-Werte ans Ende
                if (valA == null && valB == null) return 0;
                if (valA == null) return 1;
                if (valB == null) return -1;
                
                let comparison = 0;
                
                if (sortType === 'alpha-asc' || sortType === 'alpha-desc') {
                    // Alphabetische Sortierung
                    const strA = String(valA).toLowerCase();
                    const strB = String(valB).toLowerCase();
                    comparison = strA.localeCompare(strB, 'de');
                } else if (sortType === 'num-asc' || sortType === 'num-desc') {
                    // Numerische Sortierung
                    const numA = parseNumericValue(valA);
                    const numB = parseNumericValue(valB);
                    if (isNaN(numA) && isNaN(numB)) comparison = 0;
                    else if (isNaN(numA)) comparison = 1;
                    else if (isNaN(numB)) comparison = -1;
                    else comparison = numA - numB;
                } else if (sortType === 'date-asc' || sortType === 'date-desc') {
                    // Datums-Sortierung
                    const dateA = parseDateValue(valA);
                    const dateB = parseDateValue(valB);
                    if (!dateA && !dateB) comparison = 0;
                    else if (!dateA) comparison = 1;
                    else if (!dateB) comparison = -1;
                    else comparison = dateA.getTime() - dateB.getTime();
                } else {
                    // Auto: Numerisch wenn m√∂glich, sonst alphabetisch
                    const numA = parseFloat(valA);
                    const numB = parseFloat(valB);
                    
                    if (!isNaN(numA) && !isNaN(numB)) {
                        comparison = numA - numB;
                    } else {
                        const strA = String(valA).toLowerCase();
                        const strB = String(valB).toLowerCase();
                        if (strA < strB) comparison = -1;
                        else if (strA > strB) comparison = 1;
                        else comparison = 0;
                    }
                }
                
                return direction === 'asc' ? comparison : -comparison;
            });
        }
        
        /**
         * Parst einen Wert als Zahl (ber√ºcksichtigt deutsche Zahlenformate)
         */
        function parseNumericValue(value) {
            if (typeof value === 'number') return value;
            if (value == null) return NaN;
            const str = String(value).trim();
            // Deutsche Zahlen: 1.234,56 ‚Üí 1234.56
            const normalized = str.replace(/\./g, '').replace(',', '.');
            return parseFloat(normalized);
        }
        
        /**
         * Parst einen Wert als Datum (ber√ºcksichtigt deutsche Datumsformate)
         */
        function parseDateValue(value) {
            if (value instanceof Date) return value;
            if (value == null) return null;
            const str = String(value).trim();
            
            // Deutsches Format: DD.MM.YYYY oder DD.MM.YYYY HH:MM
            const germanMatch = str.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})(?:\s+(\d{1,2}):(\d{2}))?$/);
            if (germanMatch) {
                const [, day, month, year, hour, min] = germanMatch;
                return new Date(parseInt(year), parseInt(month) - 1, parseInt(day), 
                    parseInt(hour || 0), parseInt(min || 0));
            }
            
            // ISO-Format: YYYY-MM-DD
            const isoMatch = str.match(/^(\d{4})-(\d{2})-(\d{2})/);
            if (isoMatch) {
                return new Date(str);
            }
            
            // Fallback
            const parsed = new Date(str);
            return isNaN(parsed.getTime()) ? null : parsed;
        }
        
        // ==================== Column Context Menu ====================
        let contextMenuColumn = null;
        
        function showColumnContextMenu(e, colIndex) {
            e.preventDefault();
            
            const menu = document.getElementById('columnContextMenu');
            const columnName = explorerState.headers[colIndex] || `Spalte ${colIndex + 1}`;
            
            document.getElementById('contextMenuColumnName').textContent = columnName;
            contextMenuColumn = colIndex;
            
            // Positionierung
            let x = e.clientX;
            let y = e.clientY;
            
            // Sicherstellen, dass das Men√º im Viewport bleibt
            menu.style.display = 'block';
            const menuRect = menu.getBoundingClientRect();
            
            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }
            
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
        }
        
        function hideColumnContextMenu() {
            const menu = document.getElementById('columnContextMenu');
            if (menu) menu.style.display = 'none';
            contextMenuColumn = null;
        }
        
        function handleContextMenuAction(action) {
            if (contextMenuColumn === null) return;
            
            switch (action) {
                case 'sort-alpha-asc':
                    sortExplorerByColumn(contextMenuColumn, 'alpha-asc');
                    break;
                case 'sort-alpha-desc':
                    sortExplorerByColumn(contextMenuColumn, 'alpha-desc');
                    break;
                case 'sort-num-asc':
                    sortExplorerByColumn(contextMenuColumn, 'num-asc');
                    break;
                case 'sort-num-desc':
                    sortExplorerByColumn(contextMenuColumn, 'num-desc');
                    break;
                case 'sort-date-asc':
                    sortExplorerByColumn(contextMenuColumn, 'date-asc');
                    break;
                case 'sort-date-desc':
                    sortExplorerByColumn(contextMenuColumn, 'date-desc');
                    break;
                case 'hide-column':
                    toggleExplorerColumn(contextMenuColumn, false);
                    break;
            }
            
            hideColumnContextMenu();
        }
        
        // Event-Listener f√ºr Kontextmen√º
        document.addEventListener('DOMContentLoaded', () => {
            // Kontextmen√º-Items
            document.querySelectorAll('#columnContextMenu .context-menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    handleContextMenuAction(item.dataset.action);
                });
            });
            
            // Klick au√üerhalb schlie√üt Men√º
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#columnContextMenu')) {
                    hideColumnContextMenu();
                }
            });
            
            // Escape schlie√üt Men√º
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hideColumnContextMenu();
                }
            });
        });
        
        /**
         * Verschiebt eine Spalte per Drag & Drop
         */
        function moveExplorerColumn(fromColIndex, toColIndex) {
            // Initialisiere columnOrder wenn n√∂tig
            if (explorerState.columnOrder.length === 0) {
                explorerState.columnOrder = [...explorerState.visibleColumns];
            }
            
            // Finde die Positionen in columnOrder
            const fromPos = explorerState.columnOrder.indexOf(fromColIndex);
            const toPos = explorerState.columnOrder.indexOf(toColIndex);
            
            if (fromPos === -1 || toPos === -1) return;
            
            // Entferne die Spalte von der alten Position
            explorerState.columnOrder.splice(fromPos, 1);
            
            // F√ºge sie an der neuen Position ein
            explorerState.columnOrder.splice(toPos, 0, fromColIndex);
            
            // Tabelle neu rendern
            renderExplorerTable();
        }
        
        /**
         * Setzt die Spaltenreihenfolge zur√ºck
         */
        function resetExplorerColumnOrder() {
            explorerState.columnOrder = [];
            renderExplorerTable();
        }
        
        function renderExplorerTable() {
            const btnPreview = document.getElementById('btnExplorerPreview');
            
            if (!explorerState.headers.length) {
                elements.explorerTableBody.innerHTML = '<tr><td style="text-align: center; padding: 40px; color: var(--text-muted);">üìÇ Bitte eine Excel-Datei laden</td></tr>';
                elements.explorerResultCount.textContent = t('noDataLoaded');
                document.getElementById('explorerPagination').style.display = 'none';
                if (btnPreview) btnPreview.disabled = true;
                return;
            }
            
            // Preview-Button aktivieren, wenn Daten vorhanden sind
            if (btnPreview) btnPreview.disabled = false;
            
            // Pagination berechnen
            const totalRows = explorerState.filteredData.length;
            const totalPages = Math.max(1, Math.ceil(totalRows / explorerState.pageSize));
            
            // Sicherstellen, dass currentPage g√ºltig ist
            if (explorerState.currentPage > totalPages) {
                explorerState.currentPage = totalPages;
            }
            if (explorerState.currentPage < 1) {
                explorerState.currentPage = 1;
            }
            
            const startIndex = (explorerState.currentPage - 1) * explorerState.pageSize;
            const endIndex = Math.min(startIndex + explorerState.pageSize, totalRows);
            const pageData = explorerState.filteredData.slice(startIndex, endIndex);
            
            // Header mit Sortierung und Drag & Drop
            // Verwende columnOrder wenn gesetzt, sonst visibleColumns
            const displayColumns = explorerState.columnOrder.length > 0 
                ? explorerState.columnOrder.filter(col => explorerState.visibleColumns.includes(col))
                : explorerState.visibleColumns;
            
            // Pr√ºfe ob alle sichtbaren Zeilen ausgew√§hlt sind
            const allVisibleSelected = pageData.length > 0 && pageData.every(item => explorerState.selectedRows.has(item.originalIndex));
            
            let headerHtml = '<tr>';
            // Checkbox-Spalte f√ºr Zeilenauswahl
            headerHtml += `<th style="width: 40px; text-align: center; padding: 8px;">
                <input type="checkbox" id="selectAllRows" ${allVisibleSelected ? 'checked' : ''} 
                    title="Alle sichtbaren Zeilen ausw√§hlen" style="cursor: pointer; width: 16px; height: 16px;">
            </th>`;
            displayColumns.forEach(colIndex => {
                const headerText = escapeHtml(explorerState.headers[colIndex] || `Spalte ${colIndex + 1}`);
                let sortIcon = '';
                if (explorerState.sortColumn === colIndex) {
                    sortIcon = explorerState.sortDirection === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
                }
                headerHtml += `<th class="sortable-header" data-col="${colIndex}" draggable="true" title="Klicken zum Sortieren, Ziehen zum Verschieben">${headerText}${sortIcon}</th>`;
            });
            headerHtml += '</tr>';
            elements.explorerTableHead.innerHTML = headerHtml;
            
            // Select-All Checkbox Event-Listener
            const selectAllCheckbox = document.getElementById('selectAllRows');
            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', function() {
                    pageData.forEach(item => {
                        if (this.checked) {
                            explorerState.selectedRows.add(item.originalIndex);
                        } else {
                            explorerState.selectedRows.delete(item.originalIndex);
                        }
                    });
                    updateRowSelectionUI();
                    updateRowMoveToolbar();
                });
            }
            
            // Sortier- und Drag-Event-Listener
            document.querySelectorAll('#explorerTableHead .sortable-header').forEach(th => {
                // Klick zum Sortieren
                th.addEventListener('click', (e) => {
                    // Nur sortieren wenn nicht gerade gedraggt wurde
                    if (!th.classList.contains('was-dragged')) {
                        const colIndex = parseInt(th.dataset.col);
                        sortExplorerByColumn(colIndex);
                    }
                    th.classList.remove('was-dragged');
                });
                
                // Rechtsklick f√ºr Kontextmen√º
                th.addEventListener('contextmenu', (e) => {
                    const colIndex = parseInt(th.dataset.col);
                    showColumnContextMenu(e, colIndex);
                });
                
                // Drag Start
                th.addEventListener('dragstart', (e) => {
                    explorerState.draggedColumn = parseInt(th.dataset.col);
                    th.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', th.dataset.col);
                });
                
                // Drag Over
                th.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    if (parseInt(th.dataset.col) !== explorerState.draggedColumn) {
                        th.classList.add('drag-over');
                    }
                });
                
                // Drag Leave
                th.addEventListener('dragleave', () => {
                    th.classList.remove('drag-over');
                });
                
                // Drag End
                th.addEventListener('dragend', () => {
                    th.classList.remove('dragging');
                    document.querySelectorAll('.sortable-header').forEach(h => h.classList.remove('drag-over'));
                });
                
                // Drop
                th.addEventListener('drop', (e) => {
                    e.preventDefault();
                    th.classList.remove('drag-over');
                    
                    const fromCol = explorerState.draggedColumn;
                    const toCol = parseInt(th.dataset.col);
                    
                    if (fromCol !== toCol && fromCol !== null) {
                        // Markiere dass gedraggt wurde (verhindert Sortierung beim Klick)
                        th.classList.add('was-dragged');
                        
                        // Aktualisiere die Spaltenreihenfolge
                        moveExplorerColumn(fromCol, toCol);
                    }
                    
                    explorerState.draggedColumn = null;
                });
            });
            
            // Body - nur die aktuelle Seite rendern (mit editierbaren Zellen)
            let bodyHtml = '';
            pageData.forEach(item => {
                const originalIndex = item.originalIndex;
                const row = item.row;
                const isSelected = explorerState.selectedRows.has(originalIndex);
                const selectedClass = isSelected ? ' class="row-selected"' : '';
                bodyHtml += `<tr data-original-index="${originalIndex}"${selectedClass}>`;
                // Checkbox-Zelle f√ºr Zeilenauswahl
                bodyHtml += `<td class="row-checkbox-cell ${isSelected ? 'selected' : ''}">
                    <input type="checkbox" class="row-select-checkbox" data-row-index="${originalIndex}" 
                        ${isSelected ? 'checked' : ''}>
                </td>`;
                displayColumns.forEach(colIndex => {
                    const cellValue = String(row[colIndex] ?? '');
                    const cellKey = `${originalIndex}-${colIndex}`;
                    const isEdited = explorerState.editedCells.has(cellKey);
                    const editedClass = isEdited ? ' class="edited"' : '';
                    // Hole den echten Original-Wert aus originalData
                    const originalRow = explorerState.originalData[originalIndex];
                    const originalValue = originalRow ? String(originalRow[colIndex] ?? '') : cellValue;
                    bodyHtml += `<td contenteditable="true" data-row="${originalIndex}" data-col="${colIndex}" data-original="${escapeHtml(originalValue)}"${editedClass}>${escapeHtml(cellValue)}</td>`;
                });
                bodyHtml += '</tr>';
            });
            elements.explorerTableBody.innerHTML = bodyHtml || '<tr><td colspan="100" style="text-align: center; padding: 20px;">Keine Daten gefunden</td></tr>';
            
            // Zeilen-Highlights anwenden
            applyRowHighlights();
            
            // Event-Listener f√ºr Zeilen-Checkboxen
            document.querySelectorAll('.row-select-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const rowIndex = parseInt(this.dataset.rowIndex);
                    if (this.checked) {
                        explorerState.selectedRows.add(rowIndex);
                        this.closest('tr').classList.add('row-selected');
                        this.parentElement.classList.add('selected');
                    } else {
                        explorerState.selectedRows.delete(rowIndex);
                        this.closest('tr').classList.remove('row-selected');
                        this.parentElement.classList.remove('selected');
                    }
                    updateRowMoveToolbar();
                    // Update Select-All Checkbox
                    const selectAllCheckbox = document.getElementById('selectAllRows');
                    if (selectAllCheckbox) {
                        const allChecked = pageData.every(item => explorerState.selectedRows.has(item.originalIndex));
                        selectAllCheckbox.checked = allChecked && pageData.length > 0;
                    }
                });
            });
            
            // Rechtsklick-Kontextmen√º f√ºr Zeilen (nur Checkbox-Spalte)
            document.querySelectorAll('#explorerTableBody tr .row-checkbox-cell').forEach(cell => {
                cell.addEventListener('contextmenu', (e) => {
                    const tr = cell.closest('tr');
                    const rowIndex = parseInt(tr.dataset.originalIndex);
                    if (!isNaN(rowIndex)) {
                        showRowContextMenu(e, rowIndex);
                    }
                });
            });
            
            // Event-Listener f√ºr editierbare Zellen
            document.querySelectorAll('#explorerTableBody td[contenteditable]').forEach(td => {
                // Speichere den letzten bekannten Wert f√ºr Undo
                td.dataset.lastValue = td.textContent;
                
                td.addEventListener('input', function() {
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    const original = this.dataset.original;
                    const current = this.textContent;
                    const cellKey = `${rowIndex}-${colIndex}`;
                    
                    if (original !== current) {
                        // √Ñnderung speichern
                        explorerState.editedCells.set(cellKey, current);
                        explorerState.data[rowIndex][colIndex] = current;
                        this.classList.add('edited');
                    } else {
                        // Zur√ºck zum Original
                        explorerState.editedCells.delete(cellKey);
                        this.classList.remove('edited');
                    }
                    
                    // Status aktualisieren
                    updateExplorerEditStatus();
                });
                
                // Blur: Undo-Aktion speichern
                td.addEventListener('blur', function() {
                    this.parentElement.classList.remove('editing-row');
                    
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    const original = this.dataset.original;
                    const lastValue = this.dataset.lastValue;
                    const current = this.textContent;
                    
                    // Nur Undo speichern wenn sich der Wert ge√§ndert hat
                    if (lastValue !== current) {
                        pushExplorerUndo({
                            rowIndex,
                            colIndex,
                            oldValue: lastValue,
                            newValue: current,
                            originalValue: original
                        });
                        this.dataset.lastValue = current;
                    }
                });
                
                // Fokus-Verhalten
                td.addEventListener('focus', function() {
                    this.parentElement.classList.add('editing-row');
                });
                
                // Enter-Taste: Zur n√§chsten Zeile springen
                td.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        const nextRow = this.parentElement.nextElementSibling;
                        if (nextRow) {
                            const colIndex = parseInt(this.dataset.col);
                            const nextCell = nextRow.querySelector(`td[data-col="${colIndex}"]`);
                            if (nextCell) nextCell.focus();
                        }
                    } else if (e.key === 'Escape') {
                        // Escape: √Ñnderung verwerfen
                        this.textContent = this.dataset.original;
                        const rowIndex = parseInt(this.dataset.row);
                        const colIndex = parseInt(this.dataset.col);
                        const cellKey = `${rowIndex}-${colIndex}`;
                        explorerState.editedCells.delete(cellKey);
                        explorerState.data[rowIndex][colIndex] = this.dataset.original;
                        this.classList.remove('edited');
                        this.dataset.lastValue = this.dataset.original;
                        this.blur();
                        updateExplorerEditStatus();
                    } else if (e.key === 'Delete' || e.key === 'Backspace') {
                        // Delete/Backspace bei Zellen-Auswahl: Alle l√∂schen
                        if (explorerState.selectedCells.size > 1 && !document.activeElement.isContentEditable) {
                            e.preventDefault();
                            deleteSelectedCellsContent();
                        }
                    }
                });
                
                // Mausklick f√ºr Zellen-Auswahl
                td.addEventListener('mousedown', function(e) {
                    // Nur linke Maustaste und nicht bei Content-Bearbeitung
                    if (e.button !== 0) return;
                    
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    
                    if (e.shiftKey && explorerState.selectionAnchor) {
                        // Shift+Klick: Bereich ausw√§hlen
                        e.preventDefault();
                        selectCellRange(rowIndex, colIndex);
                    } else if (e.ctrlKey || e.metaKey) {
                        // Ctrl/Cmd+Klick: Zur Auswahl hinzuf√ºgen/entfernen
                        e.preventDefault();
                        toggleCellSelection(rowIndex, colIndex, true);
                    } else {
                        // Normaler Klick: Auswahl-Anker setzen (f√ºr sp√§tere Shift-Auswahl)
                        // Nicht die Auswahl leeren wenn die Zelle bereits ausgew√§hlt ist
                        if (!explorerState.selectedCells.has(`${rowIndex}-${colIndex}`)) {
                            explorerState.selectedCells.clear();
                        }
                        explorerState.selectionAnchor = { row: rowIndex, col: colIndex };
                        explorerState.isSelecting = true;
                    }
                });
                
                // Maus-Drag f√ºr Bereichsauswahl
                td.addEventListener('mouseenter', function(e) {
                    if (explorerState.isSelecting && e.buttons === 1) {
                        const rowIndex = parseInt(this.dataset.row);
                        const colIndex = parseInt(this.dataset.col);
                        selectCellRange(rowIndex, colIndex);
                    }
                });
                
                // Rechtsklick f√ºr Zellen-Kontextmen√º
                td.addEventListener('contextmenu', function(e) {
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    showCellContextMenu(e, rowIndex, colIndex);
                });
            });
            
            // Maus-Release: Auswahl beenden
            document.addEventListener('mouseup', function() {
                explorerState.isSelecting = false;
            });
            
            // Ergebnis-Info mit Pagination
            if (totalRows > 0) {
                const editedCount = explorerState.editedCells.size;
                const editedInfo = editedCount > 0 ? ` (${editedCount} bearbeitet)` : '';
                elements.explorerResultCount.textContent = `Zeige ${startIndex + 1}-${endIndex} von ${totalRows} Zeilen (gesamt: ${explorerState.data.length})${editedInfo}`;
            } else {
                elements.explorerResultCount.textContent = `0 von ${explorerState.data.length} Zeilen`;
            }
            
            // Pagination UI aktualisieren
            updateExplorerPagination(totalPages);
            
            // Row Move Toolbar aktualisieren
            updateRowMoveToolbar();
        }
        
        // Aktualisiert die Row Move Toolbar basierend auf der Auswahl
        function updateRowMoveToolbar() {
            const toolbar = document.getElementById('rowMoveToolbar');
            const countSpan = document.getElementById('selectedRowCount');
            const selectedCount = explorerState.selectedRows.size;
            
            if (toolbar && countSpan) {
                countSpan.textContent = selectedCount;
                toolbar.style.display = selectedCount > 0 ? 'flex' : 'none';
            }
        }
        
        // Aktualisiert die visuelle Auswahl der Zeilen
        function updateRowSelectionUI() {
            document.querySelectorAll('.row-select-checkbox').forEach(checkbox => {
                const rowIndex = parseInt(checkbox.dataset.rowIndex);
                const isSelected = explorerState.selectedRows.has(rowIndex);
                checkbox.checked = isSelected;
                const tr = checkbox.closest('tr');
                const td = checkbox.parentElement;
                if (tr) {
                    if (isSelected) {
                        tr.classList.add('row-selected');
                        td.classList.add('selected');
                    } else {
                        tr.classList.remove('row-selected');
                        td.classList.remove('selected');
                    }
                }
            });
        }
        
        // F√ºhrt das Verschieben der ausgew√§hlten Zeilen aus
        async function executeRowMove() {
            const selectedCount = explorerState.selectedRows.size;
            if (selectedCount === 0) {
                showNotification('Keine Zeilen ausgew√§hlt', 'warning');
                return;
            }
            
            const movePosition = document.getElementById('movePosition').value; // 'before' oder 'after'
            const targetRowInput = document.getElementById('moveTargetRow');
            const targetRow = parseInt(targetRowInput.value);
            
            if (isNaN(targetRow) || targetRow < 1 || targetRow > explorerState.data.length) {
                showNotification(`Ung√ºltige Zielzeile. Bitte eine Zahl zwischen 1 und ${explorerState.data.length} eingeben.`, 'warning');
                return;
            }
            
            // Zielindex (0-basiert)
            let targetIndex = targetRow - 1;
            
            // Sortiere die ausgew√§hlten Indizes
            const selectedIndices = Array.from(explorerState.selectedRows).sort((a, b) => a - b);
            
            // Pr√ºfe ob Zielzeile in der Auswahl enthalten ist
            if (explorerState.selectedRows.has(targetIndex)) {
                showNotification('Die Zielzeile kann nicht in der Auswahl enthalten sein.', 'warning');
                return;
            }
            
            // Speichere den aktuellen Zustand f√ºr Undo
            const previousData = JSON.parse(JSON.stringify(explorerState.data));
            const previousOriginalData = JSON.parse(JSON.stringify(explorerState.originalData));
            
            // Extrahiere die ausgew√§hlten Zeilen (von hinten nach vorne um Indizes nicht zu verschieben)
            const rowsToMove = [];
            const sortedDescending = [...selectedIndices].sort((a, b) => b - a);
            sortedDescending.forEach(idx => {
                rowsToMove.unshift({
                    data: explorerState.data[idx],
                    original: explorerState.originalData[idx]
                });
            });
            
            // Entferne die ausgew√§hlten Zeilen (von hinten nach vorne)
            sortedDescending.forEach(idx => {
                explorerState.data.splice(idx, 1);
                explorerState.originalData.splice(idx, 1);
            });
            
            // Berechne den neuen Zielindex nach dem Entfernen
            let newTargetIndex = targetIndex;
            selectedIndices.forEach(idx => {
                if (idx < targetIndex) {
                    newTargetIndex--;
                }
            });
            
            // F√ºge nach oder vor dem Ziel ein
            if (movePosition === 'after') {
                newTargetIndex++;
            }
            
            // F√ºge die Zeilen an der neuen Position ein
            rowsToMove.forEach((row, i) => {
                explorerState.data.splice(newTargetIndex + i, 0, row.data);
                explorerState.originalData.splice(newTargetIndex + i, 0, row.original);
            });
            
            // Speichere Undo-Aktion
            pushExplorerUndo({
                type: 'moveRows',
                previousData: previousData,
                previousOriginalData: previousOriginalData,
                movedIndices: selectedIndices,
                targetRow: targetRow,
                movePosition: movePosition
            });
            
            // Auswahl zur√ºcksetzen
            explorerState.selectedRows.clear();
            
            // FilteredData neu erstellen
            explorerState.filteredData = explorerState.data.map((row, idx) => ({
                row: row,
                originalIndex: idx
            }));
            
            // Suchfilter erneut anwenden wenn aktiv
            const searchTerm = elements.explorerSearch?.value?.trim().toLowerCase();
            if (searchTerm) {
                explorerState.filteredData = explorerState.filteredData.filter(item => 
                    item.row.some(cell => String(cell ?? '').toLowerCase().includes(searchTerm))
                );
            }
            
            // Markiere als ge√§ndert
            explorerState.hasUnsavedChanges = true;
            
            // Tabelle neu rendern
            renderExplorerTable();
            
            showNotification(`${selectedCount} Zeile(n) ${movePosition === 'before' ? 'vor' : 'nach'} Zeile ${targetRow} verschoben`, 'success');
            
            // Eingabefeld leeren
            targetRowInput.value = '';
        }
        
        // L√∂scht die Zeilenauswahl
        function clearRowSelection() {
            explorerState.selectedRows.clear();
            updateRowSelectionUI();
            updateRowMoveToolbar();
            
            // Select-All Checkbox zur√ºcksetzen
            const selectAllCheckbox = document.getElementById('selectAllRows');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
            }
        }

        function updateExplorerEditStatus() {
            const editedCount = explorerState.editedCells.size;
            const resultCount = elements.explorerResultCount.textContent;
            // Aktualisiere die Anzeige wenn sich die Anzahl ge√§nderter Zellen √§ndert
            if (editedCount > 0) {
                elements.explorerStatus.textContent = `${editedCount} Zelle(n) bearbeitet`;
                elements.explorerStatus.style.color = 'var(--warning-color)';
            } else {
                elements.explorerStatus.textContent = '';
            }
        }
        
        function updateExplorerPagination(totalPages) {
            const paginationEl = document.getElementById('explorerPagination');
            const pageInfoEl = document.getElementById('explorerPageInfo');
            const firstBtn = document.getElementById('btnExplorerFirstPage');
            const prevBtn = document.getElementById('btnExplorerPrevPage');
            const nextBtn = document.getElementById('btnExplorerNextPage');
            const lastBtn = document.getElementById('btnExplorerLastPage');
            
            // Pagination nur anzeigen wenn mehr als eine Seite
            if (explorerState.filteredData.length > explorerState.pageSize) {
                paginationEl.style.display = 'flex';
                pageInfoEl.textContent = `Seite ${explorerState.currentPage} von ${totalPages}`;
                
                // Buttons aktivieren/deaktivieren
                firstBtn.disabled = explorerState.currentPage === 1;
                prevBtn.disabled = explorerState.currentPage === 1;
                nextBtn.disabled = explorerState.currentPage === totalPages;
                lastBtn.disabled = explorerState.currentPage === totalPages;
            } else {
                paginationEl.style.display = 'none';
            }
        }
        
        function explorerGoToPage(page) {
            const totalPages = Math.ceil(explorerState.filteredData.length / explorerState.pageSize);
            explorerState.currentPage = Math.max(1, Math.min(page, totalPages));
            renderExplorerTable();
            
            // Zum Tabellenanfang scrollen
            document.getElementById('explorerTableContainer').scrollTop = 0;
        }
        
        function explorerChangePageSize(newSize) {
            explorerState.pageSize = parseInt(newSize);
            explorerState.currentPage = 1; // Zur√ºck zur ersten Seite
            renderExplorerTable();
        }
        
        function toggleColumnPanel() {
            const panel = document.getElementById('columnTogglePanel');
            panel.style.display = panel.style.display === 'none' ? 'flex' : 'none';
        }
        
        function updateColumnToggles() {
            const container = document.getElementById('columnToggles');
            container.innerHTML = explorerState.headers.map((header, i) => `
                <div class="column-toggle ${explorerState.visibleColumns.includes(i) ? '' : 'hidden-col'}">
                    <input type="checkbox" id="colToggle_${i}" ${explorerState.visibleColumns.includes(i) ? 'checked' : ''} 
                           onchange="toggleExplorerColumn(${i}, this.checked)">
                    <label for="colToggle_${i}">${escapeHtml(header || `Spalte ${i + 1}`)}</label>
                </div>
            `).join('');
        }
        
        window.toggleExplorerColumn = function(colIndex, visible) {
            if (visible) {
                if (!explorerState.visibleColumns.includes(colIndex)) {
                    explorerState.visibleColumns.push(colIndex);
                    explorerState.visibleColumns.sort((a, b) => a - b);
                }
            } else {
                explorerState.visibleColumns = explorerState.visibleColumns.filter(i => i !== colIndex);
            }
            renderExplorerTable();
            updateColumnToggles();
        };
        
        function showAllExplorerColumns() {
            explorerState.visibleColumns = explorerState.headers.map((_, i) => i);
            renderExplorerTable();
            updateColumnToggles();
        }
        
        function hideAllExplorerColumns() {
            explorerState.visibleColumns = [];
            renderExplorerTable();
            updateColumnToggles();
        }
        
        function addExplorerFilter() {
            const template = document.getElementById('explorerFilterTemplate');
            const clone = template.content.cloneNode(true);
            const row = clone.querySelector('.explorer-filter-row');
            
            // Spalten-Dropdown bef√ºllen
            const colSelect = row.querySelector('.filter-column');
            colSelect.innerHTML = `<option value="">${t('selectColumn')}</option>` + 
                explorerState.headers.map((h, i) => `<option value="${i}">${escapeHtml(h || `Spalte ${i + 1}`)}</option>`).join('');
            
            // Event-Listener
            row.querySelector('.remove-filter').onclick = () => {
                row.remove();
                updateFiltersFromDOM();
            };
            row.querySelector('.filter-column').onchange = updateFiltersFromDOM;
            row.querySelector('.filter-operator').onchange = updateFiltersFromDOM;
            row.querySelector('.filter-value').oninput = updateFiltersFromDOM;
            
            document.getElementById('explorerFilters').appendChild(row);
            document.getElementById('btnClearExplorerFilters').disabled = false;
        }
        
        function updateFiltersFromDOM() {
            const rows = document.querySelectorAll('.explorer-filter-row');
            explorerState.filters = Array.from(rows).map(row => ({
                column: row.querySelector('.filter-column').value,
                operator: row.querySelector('.filter-operator').value,
                value: row.querySelector('.filter-value').value
            })).filter(f => f.column && f.value);
            filterExplorerData();
        }
        
        function clearExplorerFilters() {
            document.getElementById('explorerFilters').innerHTML = '';
            explorerState.filters = [];
            document.getElementById('btnClearExplorerFilters').disabled = true;
            filterExplorerData();
        }
        
        async function exportExplorerData() {
            if (!explorerState.filePath) {
                elements.explorerStatus.textContent = 'Keine Datei geladen';
                return;
            }
            
            // Aktuelles Sheet im Cache speichern
            saveCurrentSheetToCache();
            
            // Sheet-Auswahl-Dialog anzeigen
            const selectedSheets = await showSheetSelectionDialog('export');
            if (!selectedSheets || selectedSheets.length === 0) return;
            
            // Dateiname ohne doppelte .xlsx Endung
            let baseName = explorerState.fileName || 'Daten';
            baseName = baseName.replace(/\.xlsx$/i, '');
            
            const savePath = await window.electronAPI.saveFileDialog({
                title: 'Export speichern',
                defaultPath: getWorkingDirectoryPath() ? (getWorkingDirectoryPath() + `/Export_${baseName}.xlsx`) : `Export_${baseName}.xlsx`,
                filters: [{ name: 'Excel', extensions: ['xlsx'] }]
            });
            
            if (savePath) {
                elements.explorerStatus.textContent = 'Exportiere...';
                
                // Sammle Daten f√ºr alle ausgew√§hlten Sheets
                const sheetsToExport = [];
                
                for (const sheetName of selectedSheets) {
                    let sheetData;
                    
                    if (sheetName === explorerState.selectedSheet) {
                        // Aktuelles Sheet: Daten aus explorerState
                        sheetData = {
                            sheetName: sheetName,
                            headers: explorerState.headers,
                            data: explorerState.filteredData.map(item => item.row),
                            visibleColumns: explorerState.visibleColumns,
                            hasChanges: explorerState.editedCells.size > 0
                        };
                    } else if (explorerState.sheetDataCache.has(sheetName)) {
                        // Sheet aus Cache
                        const cached = explorerState.sheetDataCache.get(sheetName);
                        sheetData = {
                            sheetName: sheetName,
                            headers: cached.headers,
                            data: cached.data,
                            visibleColumns: cached.visibleColumns,
                            hasChanges: cached.editedCells.size > 0
                        };
                    } else {
                        // Sheet muss von Datei geladen werden (unver√§ndert)
                        sheetData = {
                            sheetName: sheetName,
                            fromFile: true
                        };
                    }
                    
                    sheetsToExport.push(sheetData);
                }
                
                // Export √ºber IPC
                const result = await window.electronAPI.exportMultipleSheets({
                    sourcePath: explorerState.filePath,
                    targetPath: savePath,
                    sheets: sheetsToExport
                });
                
                if (result.success) {
                    elements.explorerStatus.textContent = `‚úì ${selectedSheets.length} Arbeitsblatt/bl√§tter exportiert: ${savePath}`;
                } else {
                    elements.explorerStatus.textContent = `Fehler: ${result.error}`;
                }
            }
        }
        
        // Dialog zur Auswahl der Arbeitsbl√§tter
        function showSheetSelectionDialog(mode = 'export') {
            return new Promise((resolve) => {
                // Pr√ºfe ob bereits ein Dialog existiert
                const existingDialog = document.querySelector('.sheet-selection-overlay');
                if (existingDialog) existingDialog.remove();
                
                const title = mode === 'export' ? 'Arbeitsbl√§tter exportieren' : 'Arbeitsbl√§tter ausw√§hlen';
                const confirmText = mode === 'export' ? 'Exportieren' : 'OK';
                
                const overlay = document.createElement('div');
                overlay.className = 'sheet-selection-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.6);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10002;
                `;
                
                const dialog = document.createElement('div');
                dialog.className = 'sheet-selection-dialog';
                dialog.style.cssText = `
                    background: var(--bg-medium);
                    border: 1px solid var(--border);
                    border-radius: 8px;
                    padding: 20px;
                    min-width: 350px;
                    max-width: 500px;
                    max-height: 80vh;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                `;
                
                // Sheet-Liste erstellen
                let sheetListHtml = '';
                explorerState.sheets.forEach((sheetName, index) => {
                    const isCurrentSheet = sheetName === explorerState.selectedSheet;
                    const isCached = explorerState.sheetDataCache.has(sheetName);
                    const hasChanges = isCurrentSheet 
                        ? explorerState.editedCells.size > 0 
                        : (isCached && explorerState.sheetDataCache.get(sheetName).editedCells.size > 0);
                    
                    const changesBadge = hasChanges ? '<span style="color: var(--warning); margin-left: 8px; font-size: 11px;">‚óè √Ñnderungen</span>' : '';
                    const currentBadge = isCurrentSheet ? '<span style="color: var(--primary); margin-left: 8px; font-size: 11px;">(aktuell)</span>' : '';
                    
                    sheetListHtml += `
                        <label style="display: flex; align-items: center; padding: 10px 12px; background: var(--bg-light); border-radius: 4px; cursor: pointer; user-select: none;">
                            <input type="checkbox" class="sheet-checkbox" value="${escapeHtml(sheetName)}" 
                                ${isCurrentSheet ? 'checked' : ''} 
                                style="width: 18px; height: 18px; margin-right: 12px; cursor: pointer;">
                            <span style="flex: 1;">${escapeHtml(sheetName)}</span>
                            ${currentBadge}${changesBadge}
                        </label>
                    `;
                });
                
                dialog.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: var(--text);">üìë ${title}</h3>
                    <p style="margin: 0 0 15px 0; color: var(--text-secondary); font-size: 13px;">
                        W√§hlen Sie die Arbeitsbl√§tter aus, die exportiert werden sollen:
                    </p>
                    <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                        <button class="btn btn-sm btn-secondary" id="selectAllSheets">Alle ausw√§hlen</button>
                        <button class="btn btn-sm btn-secondary" id="selectNoneSheets">Keine ausw√§hlen</button>
                    </div>
                    <div style="overflow-y: auto; max-height: 300px; display: flex; flex-direction: column; gap: 6px; padding-right: 5px;">
                        ${sheetListHtml}
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border);">
                        <button class="btn btn-secondary" id="sheetDialogCancel">Abbrechen</button>
                        <button class="btn btn-primary" id="sheetDialogConfirm">${confirmText}</button>
                    </div>
                `;
                
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
                
                // Event handlers
                const confirmBtn = dialog.querySelector('#sheetDialogConfirm');
                const cancelBtn = dialog.querySelector('#sheetDialogCancel');
                const selectAllBtn = dialog.querySelector('#selectAllSheets');
                const selectNoneBtn = dialog.querySelector('#selectNoneSheets');
                const checkboxes = dialog.querySelectorAll('.sheet-checkbox');
                
                selectAllBtn.onclick = () => {
                    checkboxes.forEach(cb => cb.checked = true);
                };
                
                selectNoneBtn.onclick = () => {
                    checkboxes.forEach(cb => cb.checked = false);
                };
                
                confirmBtn.onclick = () => {
                    const selected = Array.from(checkboxes)
                        .filter(cb => cb.checked)
                        .map(cb => cb.value);
                    overlay.remove();
                    resolve(selected);
                };
                
                cancelBtn.onclick = () => {
                    overlay.remove();
                    resolve(null);
                };
                
                // ESC zum Abbrechen
                const escHandler = (e) => {
                    if (e.key === 'Escape') {
                        overlay.remove();
                        document.removeEventListener('keydown', escHandler);
                        resolve(null);
                    }
                };
                document.addEventListener('keydown', escHandler);
            });
        }
        
        // Speichert √Ñnderungen direkt in die Originaldatei
        async function saveExplorerData() {
            if (!explorerState.filePath) {
                elements.explorerStatus.textContent = 'Keine Datei geladen';
                return;
            }
            
            // Aktuelles Sheet im Cache speichern
            saveCurrentSheetToCache();
            
            // Pr√ºfe ob es √ºberhaupt √Ñnderungen gibt
            const totalChanges = countAllChanges();
            if (totalChanges === 0) {
                elements.explorerStatus.textContent = 'Keine √Ñnderungen zum Speichern';
                return;
            }
            
            // Best√§tigungsdialog
            const confirmed = await showConfirmDialog(
                '√Ñnderungen speichern',
                `M√∂chten Sie ${totalChanges} √Ñnderung(en) in die Originaldatei speichern?\n\n` +
                `Datei: ${explorerState.fileName}\n\n` +
                `‚ö†Ô∏è Die Originaldatei wird √ºberschrieben!`,
                'Speichern',
                'Abbrechen'
            );
            
            if (!confirmed) return;
            
            elements.explorerStatus.textContent = 'Speichere √Ñnderungen...';
            
            try {
                // Alle Sheets mit √Ñnderungen sammeln
                const sheetsToSave = [];
                
                // Aktuelles Sheet
                if (explorerState.editedCells.size > 0) {
                    sheetsToSave.push({
                        sheetName: explorerState.selectedSheet,
                        headers: explorerState.headers,
                        data: explorerState.data
                    });
                }
                
                // Sheets aus dem Cache
                for (const [sheetName, cached] of explorerState.sheetDataCache) {
                    if (sheetName !== explorerState.selectedSheet && cached.editedCells.size > 0) {
                        sheetsToSave.push({
                            sheetName: sheetName,
                            headers: cached.headers,
                            data: cached.data
                        });
                    }
                }
                
                // Speichern √ºber IPC
                const result = await window.electronAPI.saveExcelFile({
                    filePath: explorerState.filePath,
                    sheets: sheetsToSave
                });
                
                if (result.success) {
                    // Nach erfolgreichem Speichern: editedCells leeren
                    explorerState.editedCells.clear();
                    explorerState.originalData = explorerState.data.map(row => [...row]);
                    
                    // Cache aktualisieren - editedCells leeren
                    for (const [sheetName, cached] of explorerState.sheetDataCache) {
                        cached.editedCells.clear();
                        cached.originalData = cached.data.map(row => [...row]);
                    }
                    
                    // UI aktualisieren
                    renderExplorerTable();
                    updateExplorerEditStatus();
                    
                    elements.explorerStatus.textContent = `‚úì ${totalChanges} √Ñnderung(en) in ${explorerState.fileName} gespeichert`;
                    showNotification(`${totalChanges} √Ñnderung(en) gespeichert`, 'success');
                } else {
                    elements.explorerStatus.textContent = `Fehler: ${result.error}`;
                    showNotification(`Speichern fehlgeschlagen: ${result.error}`, 'error');
                }
            } catch (error) {
                elements.explorerStatus.textContent = `Fehler: ${error.message}`;
                showNotification(`Speichern fehlgeschlagen: ${error.message}`, 'error');
            }
        }
        
        // Best√§tigungsdialog anzeigen
        function showConfirmDialog(title, message, confirmText = 'OK', cancelText = 'Abbrechen') {
            return new Promise((resolve) => {
                // Pr√ºfe ob bereits ein Dialog existiert
                const existingDialog = document.querySelector('.confirm-dialog-overlay');
                if (existingDialog) existingDialog.remove();
                
                const overlay = document.createElement('div');
                overlay.className = 'confirm-dialog-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.6);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10002;
                `;
                
                const dialog = document.createElement('div');
                dialog.className = 'confirm-dialog';
                dialog.style.cssText = `
                    background: var(--bg-medium);
                    border: 1px solid var(--border);
                    border-radius: 8px;
                    padding: 20px;
                    max-width: 400px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                `;
                
                dialog.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: var(--text);">${title}</h3>
                    <p style="margin: 0 0 20px 0; color: var(--text-secondary); white-space: pre-line;">${message}</p>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="btn btn-secondary" id="confirmDialogCancel">${cancelText}</button>
                        <button class="btn btn-success" id="confirmDialogConfirm">${confirmText}</button>
                    </div>
                `;
                
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
                
                // Event handlers
                const confirmBtn = dialog.querySelector('#confirmDialogConfirm');
                const cancelBtn = dialog.querySelector('#confirmDialogCancel');
                
                confirmBtn.onclick = () => {
                    overlay.remove();
                    resolve(true);
                };
                
                cancelBtn.onclick = () => {
                    overlay.remove();
                    resolve(false);
                };
                
                // ESC zum Abbrechen
                const escHandler = (e) => {
                    if (e.key === 'Escape') {
                        overlay.remove();
                        document.removeEventListener('keydown', escHandler);
                        resolve(false);
                    }
                };
                document.addEventListener('keydown', escHandler);
            });
        }
        
        // ==================== New Month Modal Functions ====================
        function openNewMonthModal() {
            if (!state.template.filePath && !state.template.data) {
                showStatus(elements.transferStatus, 'Bitte erst ein Template laden', 'error');
                return;
            }
            
            // Element direkt aus DOM holen (kann durch Sprachumschaltung ersetzt worden sein)
            const templateNameEl = document.getElementById('newMonthTemplateName');
            if (templateNameEl) {
                templateNameEl.textContent = state.template.name || '-';
            }
            
            // Vorschlag f√ºr neuen Dateinamen: Template-Name als Basis verwenden
            let baseName = state.template.name || 'Vertragsliste.xlsx';
            // Entferne .xlsx/.xls Endung falls vorhanden
            baseName = baseName.replace(/\.(xlsx|xls)$/i, '');
            // F√ºge aktuellen Monat hinzu
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            elements.newMonthFilename.value = `${baseName}_${year}-${month}.xlsx`;
            
            elements.newMonthModal.classList.remove('hidden');
        }
        
        function closeNewMonthModal() {
            elements.newMonthModal.classList.add('hidden');
        }
        
        async function confirmNewMonth() {
            const filename = elements.newMonthFilename.value.trim();
            if (!filename) {
                showStatus(elements.transferStatus, 'Bitte einen Dateinamen eingeben', 'error');
                return;
            }
            
            const finalFilename = filename.endsWith('.xlsx') ? filename : filename + '.xlsx';
            
            if (state.template.filePath) {
                const savePath = await window.electronAPI.saveFileDialog({
                    title: 'Neue Monatsdatei speichern',
                    defaultPath: getWorkingDirectoryPath() ? (getWorkingDirectoryPath() + '/' + finalFilename) : finalFilename,
                    filters: [{ name: 'Excel', extensions: ['xlsx'] }]
                });
                
                if (savePath) {
                    // Verwende copyExcelFile (wie in preload.js definiert)
                    const result = await window.electronAPI.copyExcelFile({
                        sourcePath: state.template.filePath,
                        targetPath: savePath
                    });
                    
                    if (result.success) {
                        closeNewMonthModal();
                        
                        // Neue Datei als Datei 2 laden
                        const readResult = await window.electronAPI.readExcelFile(savePath);
                        if (readResult.success) {
                            state.file2.name = readResult.fileName;
                            state.file2.filePath = savePath;
                            state.file2.sheets = readResult.sheets;
                            state.file2.workbook = { SheetNames: readResult.sheets };
                            
                            elements.selectSheet2.innerHTML = readResult.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
                            elements.selectSheet2.disabled = false;
                            elements.file2Info.textContent = `‚úì ${readResult.fileName}`;
                            elements.file2Info.classList.add('loaded');
                            
                            await loadSheet2Electron(readResult.sheets[0]);
                            
                            showStatus(elements.transferStatus, `‚úì Neue Monatsdatei erstellt: ${readResult.fileName}`, 'success');
                        }
                    } else {
                        showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                    }
                }
            }
        }
        
        // ==================== Flag/Comment Column Visibility ====================
        function isFlagEnabled() {
            return document.getElementById('enableFlagColumn')?.checked ?? true;
        }
        
        function isCommentEnabled() {
            return document.getElementById('enableCommentColumn')?.checked ?? true;
        }
        
        // Automatische Spaltenberechnung:
        // - Flag ist immer Spalte 1 (wenn aktiviert)
        // - Kommentar ist nach Flag (Spalte 1 oder 2)
        // - Daten beginnen nach Flag und Kommentar
        function getFlagColumn() {
            // Flag ist immer Spalte 1 (A)
            return 1;
        }
        
        function getCommentColumn() {
            // Kommentar kommt nach Flag:
            // - Wenn Flag aktiviert: Spalte 2 (B)
            // - Wenn Flag deaktiviert: Spalte 1 (A)
            return isFlagEnabled() ? 2 : 1;
        }
        
        function getDataStartColumn() {
            // Daten beginnen nach Flag und Kommentar:
            // - Beide aktiviert: Spalte 3 (C)
            // - Nur eines aktiviert: Spalte 2 (B)
            // - Beide deaktiviert: Spalte 1 (A)
            let startCol = 1;
            if (isFlagEnabled()) startCol++;
            if (isCommentEnabled()) startCol++;
            return startCol;
        }
        
        // Aktualisiert die Anzeige der automatischen Spaltenberechnung
        function updateColumnDisplays() {
            const flagEnabled = isFlagEnabled();
            const commentEnabled = isCommentEnabled();
            
            const flagDisplay = document.getElementById('flagColumnDisplay');
            const commentDisplay = document.getElementById('commentColumnDisplay');
            const startDisplay = document.getElementById('targetStartColumnDisplay');
            
            if (flagDisplay) {
                flagDisplay.textContent = flagEnabled ? '‚Üí Spalte A' : '(deaktiviert)';
                flagDisplay.style.color = flagEnabled ? 'var(--excel-green)' : 'var(--text-muted)';
            }
            
            if (commentDisplay) {
                if (commentEnabled) {
                    const col = getCommentColumn();
                    commentDisplay.textContent = `‚Üí Spalte ${String.fromCharCode(64 + col)}`;
                    commentDisplay.style.color = 'var(--excel-green)';
                } else {
                    commentDisplay.textContent = '(deaktiviert)';
                    commentDisplay.style.color = 'var(--text-muted)';
                }
            }
            
            if (startDisplay) {
                const startCol = getDataStartColumn();
                startDisplay.textContent = `Spalte ${String.fromCharCode(64 + startCol)} (automatisch berechnet)`;
            }
        }
        
        function getFlagValues() {
            const input = document.getElementById('flagValues')?.value || 'A,D,C,leer';
            return input.split(',').map(v => v.trim()).filter(v => v);
        }
        
        function getCommentPlaceholder() {
            return document.getElementById('commentPlaceholder')?.value || 'Freier Text...';
        }
        
        function updateFlagDropdownOptions() {
            const values = getFlagValues();
            
            // Standard-Labels f√ºr bekannte Flags
            const flagLabels = {
                'A': 'A (Add)',
                'D': 'D (Delete)',
                'C': 'C (Change)',
                'leer': 'Leerzeile'
            };
            
            // Optionen HTML generieren
            const optionsHtml = values.map(v => {
                const label = flagLabels[v] || v;
                return `<option value="${escapeHtml(v)}">${escapeHtml(label)}</option>`;
            }).join('');
            
            // Beide Flag-Dropdowns aktualisieren
            if (elements.transferFlag) {
                elements.transferFlag.innerHTML = optionsHtml;
            }
            if (elements.newRowFlag) {
                elements.newRowFlag.innerHTML = optionsHtml;
            }
        }
        
        function updateCommentPlaceholders() {
            const placeholder = getCommentPlaceholder();
            if (elements.transferComment) {
                elements.transferComment.placeholder = placeholder;
            }
            if (elements.newRowComment) {
                elements.newRowComment.placeholder = placeholder;
            }
        }
        
        function updateFlagCommentVisibility() {
            const flagEnabled = isFlagEnabled();
            const commentEnabled = isCommentEnabled();
            
            // Transfer Panel
            const transferFlagField = elements.transferFlag?.closest('.transfer-field');
            const transferCommentField = elements.transferComment?.closest('.transfer-field');
            
            if (transferFlagField) {
                transferFlagField.style.display = flagEnabled ? '' : 'none';
            }
            if (transferCommentField) {
                transferCommentField.style.display = commentEnabled ? '' : 'none';
            }
            
            // New Row Panel
            const newRowFlagField = elements.newRowFlag?.closest('.transfer-field');
            const newRowCommentField = elements.newRowComment?.closest('.transfer-field');
            
            if (newRowFlagField) {
                newRowFlagField.style.display = flagEnabled ? '' : 'none';
            }
            if (newRowCommentField) {
                newRowCommentField.style.display = commentEnabled ? '' : 'none';
            }
            
            // Modal Config Sections
            const flagConfig = document.getElementById('flagColumnConfig');
            const commentConfig = document.getElementById('commentColumnConfig');
            
            if (flagConfig) {
                flagConfig.style.display = flagEnabled ? '' : 'none';
            }
            if (commentConfig) {
                commentConfig.style.display = commentEnabled ? '' : 'none';
            }
            
            // Update Labels mit Spaltennummer
            const flagColumn = getFlagColumn();
            const commentColumn = getCommentColumn();
            const colLetters = ['', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            
            if (transferFlagField) {
                const label = transferFlagField.querySelector('label');
                if (label) label.textContent = `Spalte ${colLetters[flagColumn]} - Flag:`;
            }
            if (transferCommentField) {
                const label = transferCommentField.querySelector('label');
                if (label) label.textContent = `Spalte ${colLetters[commentColumn]} - Kommentar:`;
            }
            if (newRowFlagField) {
                const label = newRowFlagField.querySelector('label');
                if (label) label.textContent = `Flag (Spalte ${colLetters[flagColumn]}):`;
            }
            if (newRowCommentField) {
                const label = newRowCommentField.querySelector('label');
                if (label) label.textContent = `Kommentar (Spalte ${colLetters[commentColumn]}):`;
            }
        }
        
        // ==================== Initialize App ====================
        async function initApp() {
            // Initialize theme and language first
            setTheme(currentTheme);
            setLanguage(currentLanguage);
            document.getElementById('selectLanguage').value = currentLanguage;
            document.getElementById('selectTheme').value = currentTheme;
            document.getElementById('selectLanguage').onchange = (e) => setLanguage(e.target.value);
            document.getElementById('selectTheme').onchange = (e) => setTheme(e.target.value);
            
            // Flag/Comment Column Options
            const flagCheckbox = document.getElementById('enableFlagColumn');
            const commentCheckbox = document.getElementById('enableCommentColumn');
            const flagValuesInput = document.getElementById('flagValues');
            const commentPlaceholderInput = document.getElementById('commentPlaceholder');
            
            // Load saved preferences
            const savedFlagEnabled = localStorage.getItem('excelSyncEnableFlag');
            const savedCommentEnabled = localStorage.getItem('excelSyncEnableComment');
            const savedFlagValues = localStorage.getItem('excelSyncFlagValues');
            const savedCommentPlaceholder = localStorage.getItem('excelSyncCommentPlaceholder');
            
            if (savedFlagEnabled !== null) {
                flagCheckbox.checked = savedFlagEnabled === 'true';
            }
            if (savedCommentEnabled !== null) {
                commentCheckbox.checked = savedCommentEnabled === 'true';
            }
            if (savedFlagValues) {
                flagValuesInput.value = savedFlagValues;
            }
            if (savedCommentPlaceholder) {
                commentPlaceholderInput.value = savedCommentPlaceholder;
            }
            
            // Apply initial settings
            updateFlagDropdownOptions();
            updateCommentPlaceholders();
            updateFlagCommentVisibility();
            updateColumnDisplays();
            
            flagCheckbox.onchange = () => {
                localStorage.setItem('excelSyncEnableFlag', flagCheckbox.checked);
                updateFlagCommentVisibility();
                updateColumnDisplays();
                renderMappingList();
            };
            
            commentCheckbox.onchange = () => {
                localStorage.setItem('excelSyncEnableComment', commentCheckbox.checked);
                updateFlagCommentVisibility();
                updateColumnDisplays();
                renderMappingList();
            };
            
            flagValuesInput.onchange = () => {
                localStorage.setItem('excelSyncFlagValues', flagValuesInput.value);
                updateFlagDropdownOptions();
            };
            
            commentPlaceholderInput.onchange = () => {
                localStorage.setItem('excelSyncCommentPlaceholder', commentPlaceholderInput.value);
                updateCommentPlaceholders();
            };
            
            // Globaler Keyboard-Handler f√ºr Undo/Redo
            document.addEventListener('keydown', (e) => {
                // Strg+Z (Windows/Linux) oder Cmd+Z (Mac)
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    
                    // Pr√ºfe welches Modal aktiv ist
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (explorerOpen) {
                        if (undoExplorer()) {
                            showUndoRedoFeedback('R√ºckg√§ngig');
                        }
                    } else {
                        if (undoSearch()) {
                            showUndoRedoFeedback('R√ºckg√§ngig');
                        }
                    }
                }
                
                // Strg+Y oder Strg+Shift+Z (Redo)
                if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (explorerOpen) {
                        if (redoExplorer()) {
                            showUndoRedoFeedback('Wiederherstellen');
                        }
                    } else {
                        if (redoSearch()) {
                            showUndoRedoFeedback('Wiederherstellen');
                        }
                    }
                }
                
                // Strg+F ‚Üí Fokus auf Suchfeld
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (explorerOpen) {
                        e.preventDefault();
                        elements.explorerSearch.focus();
                        elements.explorerSearch.select();
                    } else if (!document.querySelector('.modal-backdrop:not(.hidden)')) {
                        // Nur wenn kein Modal offen ist
                        e.preventDefault();
                        elements.searchInput.focus();
                        elements.searchInput.select();
                    }
                }
                
                // Strg+S ‚Üí Warteschlange exportieren
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (explorerOpen) {
                        // Im Explorer: Exportieren
                        if (explorerState.data.length > 0) {
                            exportExplorerData();
                        }
                    } else if (state.transferQueue.length > 0) {
                        // Warteschlange exportieren
                        transferQueueToExcel();
                    }
                }
                
                // Strg+Enter ‚Üí Direkt √ºbertragen
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (!explorerOpen && state.selectedRows.length > 0) {
                        transferSelectedDirect();
                    }
                }
                
                // F5 ‚Üí Suche wiederholen / Daten neu laden
                if (e.key === 'F5') {
                    e.preventDefault();
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (explorerOpen && explorerState.selectedSheet) {
                        loadExplorerSheet(explorerState.selectedSheet);
                        showUndoRedoFeedback('Neu geladen');
                    } else if (elements.searchInput.value) {
                        search();
                        showUndoRedoFeedback('Suche aktualisiert');
                    }
                }
                
                // Escape ‚Üí Modal schlie√üen
                if (e.key === 'Escape') {
                    // Pr√ºfe welche Modals offen sind und schlie√üe das oberste
                    if (!elements.dataExplorerModal.classList.contains('hidden')) {
                        closeDataExplorer();
                    } else if (!document.getElementById('helpModal').classList.contains('hidden')) {
                        document.getElementById('helpModal').classList.add('hidden');
                        document.body.classList.remove('modal-open');
                    } else if (!document.getElementById('mappingModal').classList.contains('hidden')) {
                        closeMappingModal();
                    } else if (!document.getElementById('newMonthModal').classList.contains('hidden')) {
                        closeNewMonthModal();
                    } else if (!document.getElementById('licenseModal').classList.contains('hidden')) {
                        document.getElementById('licenseModal').classList.add('hidden');
                        document.body.classList.remove('modal-open');
                    } else if (!elements.newRowPanel.classList.contains('hidden')) {
                        closeNewRowPanel();
                    }
                }
            });
            
            try { await initDB(); } catch (e) { console.warn('IndexedDB nicht verf√ºgbar'); }
            loadConfig(); updateMappingPreview(); checkReadyState();
            
            // Auto-Save starten und Recovery pr√ºfen
            startAutoSave();
            setTimeout(() => checkAutoSaveRecovery(), 500); // Kurze Verz√∂gerung f√ºr UI-Initialisierung
            
            // Pr√ºfung beim Schlie√üen der App
            window.electronAPI.onBeforeClose(() => {
                if (state.transferQueue.length > 0) {
                    const msg = `Es befinden sich noch ${state.transferQueue.length} Eintr√§ge in der Warteschlange.\n\nWirklich schlie√üen? Ungespeicherte Daten gehen verloren!`;
                    if (confirm(msg)) {
                        window.electronAPI.confirmClose(true);
                    } else {
                        window.electronAPI.confirmClose(false);
                    }
                } else {
                    window.electronAPI.confirmClose(true);
                }
            });
            
            // Search Event Listeners - WICHTIG!
            elements.searchInput.addEventListener('keydown', (e) => {
                const dropdown = document.getElementById('searchHistoryDropdown');
                const isDropdownOpen = dropdown && dropdown.classList.contains('show');
                
                if (e.key === 'Enter') {
                    e.preventDefault();
                    hideSearchHistoryDropdown();
                    search();
                } else if (e.key === 'ArrowDown') {
                    if (!isDropdownOpen) {
                        showSearchHistoryDropdown();
                    }
                    navigateSearchHistory('down');
                    e.preventDefault();
                } else if (e.key === 'ArrowUp') {
                    navigateSearchHistory('up');
                    e.preventDefault();
                } else if (e.key === 'Escape') {
                    hideSearchHistoryDropdown();
                }
            });
            
            elements.searchInput.addEventListener('focus', () => {
                showSearchHistoryDropdown();
            });
            
            elements.searchInput.addEventListener('input', () => {
                renderSearchHistoryDropdown(elements.searchInput.value);
                const dropdown = document.getElementById('searchHistoryDropdown');
                const history = getSearchHistory();
                const filterText = elements.searchInput.value;
                const filtered = filterText 
                    ? history.filter(item => item.term.toLowerCase().includes(filterText.toLowerCase()))
                    : history;
                if (filtered.length > 0) {
                    dropdown.classList.add('show');
                }
            });
            
            // Dropdown schlie√üen bei Klick au√üerhalb
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-wrapper')) {
                    hideSearchHistoryDropdown();
                }
            });
            
            elements.btnSearch.onclick = search;
            
            elements.btnNewRow.onclick = openNewRowPanel;
            elements.btnCloseNewRow.onclick = closeNewRowPanel;
            elements.btnAddNewRowToQueue.onclick = addNewRowToQueue;
            elements.btnTransferNewRowDirect.onclick = transferNewRowDirect;
            document.getElementById('btnAddEmptyRow').onclick = addEmptyRowToQueue;
            elements.btnAddToQueue.onclick = addToQueue;
            elements.btnTransferDirect.onclick = transferSelectedDirect;
            elements.btnSelectAll.onclick = () => selectAllRows(true);
            elements.btnDeselectAll.onclick = () => selectAllRows(false);
            elements.btnClearQueue.onclick = clearQueue;
            elements.btnConfigMapping.onclick = openMappingModal;
            document.getElementById('btnCloseMappingModal').onclick = closeMappingModal;
            document.getElementById('btnCancelMapping').onclick = closeMappingModal;
            document.getElementById('btnSaveMapping').onclick = saveMapping;
            document.getElementById('btnAddMapping').onclick = addMappingColumn;
            
            // Data Explorer Event Listeners
            elements.btnDataExplorer.onclick = openDataExplorer;
            document.getElementById('btnCloseExplorerX').onclick = closeDataExplorer;
            document.getElementById('btnCloseExplorerFooter').onclick = closeDataExplorer;
            elements.btnExplorerOpenFile.onclick = loadExplorerFile;
            elements.explorerSheetSelect.onchange = (e) => loadExplorerSheet(e.target.value);
            elements.explorerSearch.onkeydown = (e) => { 
                if (e.key === 'Enter') {
                    explorerState.searchTerm = e.target.value; 
                    filterExplorerData(); 
                }
            };
            document.getElementById('btnExplorerSearch').onclick = () => {
                explorerState.searchTerm = elements.explorerSearch.value;
                filterExplorerData();
            };
            document.getElementById('btnToggleColumns').onclick = toggleColumnPanel;
            document.getElementById('btnShowAllColumns').onclick = showAllExplorerColumns;
            document.getElementById('btnHideAllColumns').onclick = hideAllExplorerColumns;
            document.getElementById('btnAddExplorerFilter').onclick = addExplorerFilter;
            document.getElementById('btnClearExplorerFilters').onclick = clearExplorerFilters;
            elements.btnExplorerExport.onclick = exportExplorerData;
            elements.btnExplorerSave.onclick = saveExplorerData;
            
            // Explorer-Vorschau Event Listeners
            document.getElementById('btnExplorerPreview').onclick = showExplorerPreview;
            document.getElementById('btnClosePreviewX').onclick = closeExplorerPreview;
            document.getElementById('btnClosePreview').onclick = closeExplorerPreview;
            
            // Row Move Toolbar Event Listeners
            document.getElementById('btnExecuteMove').onclick = executeRowMove;
            document.getElementById('btnClearRowSelection').onclick = clearRowSelection;
            
            // Pagination Event Listeners (Data Explorer)
            document.getElementById('btnExplorerFirstPage').onclick = () => explorerGoToPage(1);
            document.getElementById('btnExplorerPrevPage').onclick = () => explorerGoToPage(explorerState.currentPage - 1);
            document.getElementById('btnExplorerNextPage').onclick = () => explorerGoToPage(explorerState.currentPage + 1);
            document.getElementById('btnExplorerLastPage').onclick = () => explorerGoToPage(Math.ceil(explorerState.filteredData.length / explorerState.pageSize));
            document.getElementById('explorerPageSize').onchange = (e) => explorerChangePageSize(e.target.value);
            
            // Pagination Event Listeners (Suchergebnisse)
            document.getElementById('btnSearchFirstPage').onclick = () => searchGoToPage(1);
            document.getElementById('btnSearchPrevPage').onclick = () => searchGoToPage(state.searchPagination.currentPage - 1);
            document.getElementById('btnSearchNextPage').onclick = () => searchGoToPage(state.searchPagination.currentPage + 1);
            document.getElementById('btnSearchLastPage').onclick = () => searchGoToPage(Math.ceil(state.searchResults.length / state.searchPagination.pageSize));
            document.getElementById('searchPageSize').onchange = (e) => searchChangePageSize(e.target.value);
            
            // New Month Modal Event Listeners
            elements.btnNewMonth.onclick = openNewMonthModal;
            document.getElementById('btnCloseNewMonthModal').onclick = closeNewMonthModal;
            document.getElementById('btnCancelNewMonth').onclick = closeNewMonthModal;
            document.getElementById('btnConfirmNewMonth').onclick = confirmNewMonth;
            
            // Create Template Modal Event Listeners
            document.getElementById('btnCloseCreateTemplateModal').onclick = closeCreateTemplateModal;
            document.getElementById('btnCancelCreateTemplate').onclick = closeCreateTemplateModal;
            document.getElementById('btnConfirmCreateTemplate').onclick = confirmCreateTemplate;
            document.getElementById('btnSelectAllSheets').onclick = () => {
                document.querySelectorAll('.template-sheet-checkbox').forEach(cb => cb.checked = true);
            };
            document.getElementById('btnDeselectAllSheets').onclick = () => {
                document.querySelectorAll('.template-sheet-checkbox').forEach(cb => cb.checked = false);
            };
            
            // Help Modal Event Listeners
            elements.btnHelp.onclick = () => elements.helpModal.classList.remove('hidden');
            document.getElementById('btnCloseHelpModal').onclick = () => elements.helpModal.classList.add('hidden');
            document.getElementById('btnCloseHelp').onclick = () => elements.helpModal.classList.add('hidden');
            
            // License Modal Event Listeners
            document.getElementById('btnLicense').onclick = () => document.getElementById('licenseModal').classList.remove('hidden');
            document.getElementById('btnCloseLicenseModal').onclick = () => document.getElementById('licenseModal').classList.add('hidden');
            document.getElementById('btnCloseLicense').onclick = () => document.getElementById('licenseModal').classList.add('hidden');
            
            // Sidebar Toggle
            document.getElementById('sidebarToggle').onclick = () => {
                document.getElementById('sidebar').classList.toggle('collapsed');
            };
            
            // Keyboard shortcuts
            document.onkeydown = (e) => {
                if (e.key === 'F1') {
                    e.preventDefault();
                    elements.helpModal.classList.toggle('hidden');
                }
                if (e.key === 'Escape') {
                    elements.helpModal.classList.add('hidden');
                    elements.mappingModal.classList.add('hidden');
                    elements.newMonthModal.classList.add('hidden');
                    elements.createTemplateModal.classList.add('hidden');
                    document.getElementById('licenseModal').classList.add('hidden');
                    closeDataExplorer();
                }
            };
            
            // Electron-Modus: Verwende Electron-API f√ºr Dateioperationen
            elements.btnLoadFile1.onclick = loadFile1Electron;
            elements.btnLoadFile2.onclick = loadFile2Electron;
            elements.btnLoadTemplate.onclick = loadTemplateElectron;
            elements.btnCreateTemplate.onclick = createTemplateFromSourceElectron;
            elements.selectSheet1.onchange = (e) => loadSheet1Electron(e.target.value);
            elements.selectSheet2.onchange = (e) => loadSheet2Electron(e.target.value);
            elements.btnImportConfig.onclick = loadConfigFromAppDirOrDialog;
            elements.btnExportConfig.onclick = exportConfig;
            elements.btnExportPS.onclick = showDiffPreview;  // Zeigt zuerst Vorschau, dann Export via Modal
            elements.btnPreviewTransfer.onclick = showDiffPreview;
            
            // Arbeitsordner Event Handler
            elements.btnSelectWorkingDir.onclick = selectWorkingDirectory;
            elements.btnClearWorkingDir.onclick = clearWorkingDirectory;
            
            // Arbeitsordner aus localStorage laden
            loadWorkingDirectoryFromStorage();
            
            // Diff-Vorschau Modal Event Handler
            document.getElementById('btnCloseDiffModal').onclick = closeDiffPreview;
            document.getElementById('btnCancelDiff').onclick = closeDiffPreview;
            document.getElementById('btnConfirmTransfer').onclick = confirmTransferFromDiff;
            
            // Automatisch config.json aus Programmordner oder Arbeitsordner laden beim Start
            console.log('[Config] Suche automatisch nach config.json...');
            console.log('[Config] Arbeitsordner:', state.workingDirectory || '(nicht gesetzt)');
            try {
                const autoResult = await window.electronAPI.loadConfigFromAppDir(state.workingDirectory);
                console.log('[Config] loadConfigFromAppDir Ergebnis:', autoResult);
                
                if (autoResult.success && autoResult.config) {
                    await applyLoadedConfig(autoResult.config);
                    console.log('[Config] config.json automatisch geladen:', autoResult.path);
                    showStatus(elements.transferStatus, `‚úì config.json geladen: ${autoResult.path}`, 'success');
                } else {
                    console.log('[Config] Keine config.json gefunden.');
                    if (autoResult.searchedPaths) {
                        console.log('[Config] Gesuchte Pfade:', autoResult.searchedPaths);
                    }
                }
            } catch (e) {
                console.error('[Config] Fehler beim automatischen Laden:', e);
            }
        }

        initApp();
    </script>
</body>
</html>
