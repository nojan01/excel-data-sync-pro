<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self';">
    <title>Excel Data Sync Pro</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='bg' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%232e8b57'/%3E%3Cstop offset='100%25' stop-color='%231e7145'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' rx='12' fill='url(%23bg)'/%3E%3Crect x='18' y='20' width='16' height='60' rx='3' fill='white'/%3E%3Crect x='42' y='32' width='16' height='48' rx='3' fill='white'/%3E%3Crect x='66' y='44' width='16' height='36' rx='3' fill='white'/%3E%3Ccircle cx='78' cy='22' r='12' fill='rgba(255,255,255,0.3)'/%3E%3Cpath d='M72 25 A7 7 0 1 1 81 18' fill='none' stroke='white' stroke-width='2.5' stroke-linecap='round'/%3E%3Cpolygon points='83 14 83 22 77 18' fill='white'/%3E%3C/svg%3E">
    <!-- Electron-Modus: Excel wird via Node.js xlsx-populate geladen (erh√§lt Formatierung) -->
    <style>
        :root {
            --primary: #217346;
            --primary-dark: #0d5c35;
            --primary-light: #2e8b57;
            --bg-dark: #1e1e1e;
            --bg-medium: #252526;
            --bg-light: #2d2d30;
            --bg-lighter: #3c3c3c;
            --text: #e0e0e0;
            --text-muted: #888;
            --border: #404040;
            --success: #4caf50;
            --warning: #ff9800;
            --error: #f44336;
            --info: #2196f3;
        }
        
        /* Generische hidden-Klasse */
        .hidden {
            display: none !important;
        }
        
        /* Gr√ºne Checkboxen */
        .green-checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--primary);
        }
        
        /* Light Theme */
        body.light-theme {
            --bg-dark: #f5f5f5;
            --bg-medium: #ffffff;
            --bg-light: #e8e8e8;
            --bg-lighter: #d0d0d0;
            --text: #1e1e1e;
            --text-muted: #666666;
            --border: #cccccc;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header */
        .header {
            background: var(--bg-medium);
            border-bottom: 1px solid var(--border);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            font-weight: 600;
            color: var(--primary-light);
        }
        
        .logo-icon {
            width: 32px;
            height: 32px;
            background: var(--primary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
        }
        
        .header-actions {
            margin-left: auto;
            display: flex;
            gap: 10px;
        }
        
        /* Buttons */
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            background: var(--bg-lighter, #3c3c3c);
            color: var(--text, #e0e0e0);
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--primary-light);
        }
        
        .btn-warning {
            background: var(--warning);
            color: #1e1e1e;
        }
        
        .btn-warning:hover {
            background: #ffa726;
        }
        
        .btn-info {
            background: #9c27b0;
            color: white;
        }
        
        .btn-info:hover {
            background: #ab47bc;
        }
        
        .btn-unsaved {
            animation: pulse-save 1.5s infinite;
            box-shadow: 0 0 10px rgba(66, 165, 245, 0.5);
        }
        
        @keyframes pulse-save {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .btn-secondary {
            background: var(--bg-lighter);
            color: var(--text);
            border: 1px solid var(--border);
        }
        
        .btn-secondary:hover {
            background: var(--border);
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        .btn-success:hover {
            background: #66bb6a;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Main Layout */
        .main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }
        
        /* Sidebar - Konfiguration */
        .sidebar {
            width: 320px;
            background: var(--bg-medium);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: width 0.3s ease, min-width 0.3s ease;
        }
        
        .sidebar.collapsed {
            width: 48px;
            min-width: 48px;
        }
        
        .sidebar.collapsed .sidebar-content {
            display: none;
        }
        
        .sidebar.collapsed .sidebar-header-text {
            display: none;
        }
        
        .sidebar.collapsed .sidebar-toggle {
            transform: rotate(180deg);
        }
        
        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
            min-height: 52px;
        }
        
        .sidebar-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            overflow: hidden;
        }
        
        .sidebar-toggle {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 6px;
            border-radius: 4px;
            transition: background 0.2s, transform 0.3s;
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .sidebar-toggle:hover {
            background: var(--bg-lighter);
            color: var(--text-primary);
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .config-section {
            margin-bottom: 20px;
        }
        
        .config-section-title {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-muted);
            margin-bottom: 10px;
            letter-spacing: 0.5px;
        }
        
        .config-group {
            background: var(--bg-light);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }
        
        .config-label {
            font-size: 13px;
            color: var(--text-muted);
            margin-bottom: 6px;
            display: block;
        }
        
        .config-select, .config-input {
            width: 100%;
            padding: 8px 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 14px;
        }
        
        .config-select:focus, .config-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .file-info {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 6px;
            word-break: break-all;
        }
        
        .file-info.loaded {
            color: var(--success);
        }
        
        /* Content Area */
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Search Section */
        .search-section {
            padding: 20px;
            background: var(--bg-medium);
            border-bottom: 1px solid var(--border);
        }
        
        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .search-input {
            flex: 1;
            padding: 14px 18px;
            background: var(--bg-dark);
            border: 2px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 17px;
            min-height: 48px;
            min-width: 500px;
        }
        
        .search-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .search-input::placeholder {
            color: var(--text-muted);
        }
        
        /* Such-Historie Dropdown */
        .search-wrapper {
            position: relative;
            flex: 1;
        }
        
        .search-history-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-medium);
            border: 1px solid var(--border);
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            display: none;
        }
        
        .search-history-dropdown.show {
            display: block;
        }
        
        .search-history-item {
            padding: 10px 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
            transition: background 0.15s;
        }
        
        .search-history-item:last-child {
            border-bottom: none;
        }
        
        .search-history-item:hover {
            background: var(--bg-light);
        }
        
        .search-history-item.selected {
            background: var(--bg-lighter);
        }
        
        .search-history-text {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .search-history-count {
            font-size: 11px;
            color: var(--text-muted);
            margin-left: 10px;
        }
        
        .search-history-delete {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 2px 6px;
            margin-left: 8px;
            border-radius: 3px;
            font-size: 14px;
        }
        
        .search-history-delete:hover {
            color: var(--error);
            background: rgba(244, 67, 54, 0.1);
        }
        
        .search-history-header {
            padding: 8px 14px;
            font-size: 11px;
            text-transform: uppercase;
            color: var(--text-muted);
            background: var(--bg-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .search-history-clear {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 11px;
        }
        
        .search-history-clear:hover {
            color: var(--error);
        }
        
        .search-results-info {
            font-size: 14px;
            color: var(--text-muted);
        }
        
        .search-results-info strong {
            color: var(--primary-light);
        }
        
        /* Results Table */
        .results-section {
            flex: 1 1 0;
            min-height: 0;
            max-height: 30vh;
            overflow: hidden;
            padding: 10px 20px;
            display: flex;
            flex-direction: column;
        }
        
        .results-table-container {
            flex: 1 1 0;
            min-height: 80px;
            overflow: auto;
            background: var(--bg-medium);
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        .results-table {
            width: max-content;
            min-width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        
        .results-table th,
        .results-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
        }
        
        .results-table th {
            background: var(--bg-light);
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        /* Sortierbare Header */
        .sortable-header {
            cursor: grab;
            user-select: none;
            transition: background 0.15s, opacity 0.15s;
        }
        
        .sortable-header:hover {
            background: var(--bg-lighter);
        }
        
        .sortable-header.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .sortable-header.drag-over {
            background: var(--primary);
            color: white;
        }
        
        /* Nicht verschiebbare Header (merged cells) */
        .sortable-header.not-draggable {
            cursor: not-allowed !important;
            background: repeating-linear-gradient(
                45deg,
                transparent,
                transparent 3px,
                rgba(128, 128, 128, 0.1) 3px,
                rgba(128, 128, 128, 0.1) 6px
            );
        }
        
        .sortable-header.not-draggable:hover {
            background: repeating-linear-gradient(
                45deg,
                var(--bg-lighter),
                var(--bg-lighter) 3px,
                rgba(128, 128, 128, 0.15) 3px,
                rgba(128, 128, 128, 0.15) 6px
            );
        }
        
        /* Zellen-Auswahl */
        .cell-selected {
            background: rgba(33, 150, 243, 0.3) !important;
            outline: 2px solid var(--primary) !important;
            outline-offset: -2px;
        }
        
        .cell-selection-anchor {
            background: rgba(33, 150, 243, 0.4) !important;
        }
        
        /* Zeilen-Highlighting - auf td anwenden f√ºr h√∂here Spezifit√§t */
        .row-highlight-green td { background: rgba(76, 175, 80, 0.2) !important; }
        .row-highlight-yellow td { background: rgba(255, 235, 59, 0.25) !important; }
        .row-highlight-orange td { background: rgba(255, 152, 0, 0.25) !important; }
        .row-highlight-red td { background: rgba(244, 67, 54, 0.2) !important; }
        .row-highlight-blue td { background: rgba(33, 150, 243, 0.2) !important; }
        .row-highlight-purple td { background: rgba(156, 39, 176, 0.2) !important; }
        
        /* Kontextmen√º */
        .context-menu {
            position: fixed;
            background: var(--bg-medium);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 4px 0;
            min-width: 180px;
            z-index: 10000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
        }
        
        .context-menu-item:hover {
            background: var(--bg-light);
        }
        
        .context-menu-divider {
            height: 1px;
            background: var(--border);
            margin: 4px 0;
        }
        
        .color-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        /* Diff/Preview Tabelle */
        .diff-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }
        
        .diff-table th,
        .diff-table td {
            padding: 8px 10px;
            text-align: left;
            border: 1px solid var(--border);
            white-space: nowrap;
        }
        
        .diff-table th {
            background: var(--bg-light);
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        .diff-row-add {
            background: rgba(76, 175, 80, 0.15);
        }
        
        .diff-row-delete {
            background: rgba(244, 67, 54, 0.15);
        }
        
        .diff-row-change {
            background: rgba(255, 152, 0, 0.15);
        }
        
        .diff-row-empty {
            background: var(--bg-light);
            font-style: italic;
            color: var(--text-muted);
        }
        
        .diff-flag {
            font-weight: 700;
            text-align: center;
            min-width: 30px;
        }
        
        .diff-flag-A { color: #4CAF50; }
        .diff-flag-D { color: #F44336; }
        .diff-flag-C { color: #FF9800; }
        
        .results-table tr:hover {
            background: var(--bg-light);
        }
        
        .results-table tr.selected {
            background: rgba(33, 115, 70, 0.3);
        }
        
        .results-table td[contenteditable="true"] {
            cursor: text;
            min-width: 50px;
        }
        
        .results-table td[contenteditable="true"]:focus {
            outline: 2px solid var(--primary);
            outline-offset: -2px;
            background: var(--bg-darker);
        }
        
        .results-table td.edited {
            background: rgba(255, 193, 7, 0.2);
            border-left: 3px solid var(--warning);
        }
        
        /* Data Validation Dropdown Styles */
        .results-table td.has-dropdown {
            padding: 0;
            position: relative;
        }
        
        .results-table td.has-dropdown::after {
            content: '‚ñº';
            position: absolute;
            right: 4px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 8px;
            color: var(--text-muted);
            pointer-events: none;
            opacity: 0.6;
        }
        
        .cell-dropdown {
            width: 100%;
            height: 100%;
            min-height: 32px;
            padding: 6px 20px 6px 8px;
            border: none;
            background: transparent;
            color: var(--text);
            font-size: inherit;
            font-family: inherit;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }
        
        .cell-dropdown:focus {
            outline: 2px solid var(--primary);
            outline-offset: -2px;
            background: var(--bg-light);
        }
        
        .cell-dropdown option {
            background: var(--bg-medium);
            color: var(--text);
            padding: 8px;
        }
        
        .results-table td.has-dropdown.edited {
            background: rgba(255, 193, 7, 0.2);
            border-left: 3px solid var(--warning);
        }
        
        .results-table td.has-dropdown.edited::after {
            color: var(--warning);
        }

        /* Formula Icon Styles */
        .results-table td.has-formula {
            position: relative;
        }
        
        .formula-icon {
            position: absolute;
            top: 2px;
            right: 3px;
            font-size: 10px;
            font-style: italic;
            font-weight: bold;
            color: #4fc3f7;
            opacity: 0.9;
            pointer-events: none;
            background: var(--bg-secondary);
            padding: 1px 3px;
            border-radius: 3px;
            line-height: 1;
            z-index: 1;
            border: 1px solid rgba(79, 195, 247, 0.5);
        }
        
        body.light-theme .formula-icon {
            color: #0288d1;
            background: #e3f2fd;
            border-color: rgba(2, 136, 209, 0.3);
        }
        
        .results-table td.has-formula.has-dropdown .formula-icon {
            right: 18px; /* Platz f√ºr Dropdown-Pfeil lassen */
        }
        
        .results-table td.has-formula:hover .formula-icon {
            opacity: 1;
            background: #4fc3f7;
            color: #1a1a1a;
            border-color: #4fc3f7;
        }
        
        body.light-theme .results-table td.has-formula:hover .formula-icon {
            background: #0288d1;
            color: white;
            border-color: #0288d1;
        }

        /* Hyperlink Styles */
        .results-table td.has-hyperlink {
            position: relative;
        }
        
        .results-table td.has-hyperlink .cell-content {
            color: #2196f3;
            text-decoration: underline;
            cursor: pointer;
        }
        
        body.light-theme .results-table td.has-hyperlink .cell-content {
            color: #1565c0;
        }
        
        .results-table td.has-hyperlink .cell-content:hover {
            color: #64b5f6;
        }
        
        .hyperlink-icon {
            position: absolute;
            top: 2px;
            left: 3px;
            font-size: 10px;
            color: #2196f3;
            opacity: 0.7;
            pointer-events: none;
            z-index: 1;
        }
        
        .results-table td.has-hyperlink:hover .hyperlink-icon {
            opacity: 1;
        }
        
        .results-table td.has-formula.has-hyperlink .hyperlink-icon {
            left: auto;
            right: 18px; /* Neben dem Formula-Icon */
        }

        /* Rich Text Styles */
        .results-table td.has-rich-text {
            position: relative;
        }
        
        .results-table td.has-rich-text .cell-content {
            display: inline; /* Inline damit Spans nebeneinander bleiben */
        }

        /* Sheet Management Styles */
        .sheet-list-item {
            display: flex;
            align-items: center;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background-color 0.15s;
        }
        
        .sheet-list-item:last-child {
            border-bottom: none;
        }
        
        .sheet-list-item:hover {
            background-color: var(--bg-hover);
        }
        
        .sheet-list-item.selected {
            background-color: var(--primary);
            color: white;
        }
        
        .sheet-list-item .sheet-index {
            width: 30px;
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .sheet-list-item.selected .sheet-index {
            color: rgba(255,255,255,0.7);
        }
        
        .sheet-list-item .sheet-name {
            flex: 1;
            font-weight: 500;
        }
        
        .sheet-list-item .sheet-active-badge {
            font-size: 10px;
            padding: 2px 6px;
            background: var(--success);
            color: white;
            border-radius: 10px;
            margin-left: 8px;
        }

        /* Merged Cells Styles */
        .results-table td.merged-cell {
            position: relative;
        }
        
        .results-table td.merged-cell-master {
            border: 2px solid var(--primary);
            z-index: 1;
        }
        
        .results-table td.merged-cell-hidden {
            display: none;
        }
        
        .merged-icon {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 9px;
            color: var(--primary);
            opacity: 0.6;
            pointer-events: none;
        }
        
        .results-table td.merged-cell-master:hover .merged-icon {
            opacity: 1;
        }

        /* Find & Replace Highlights */
        .results-table td.find-match {
            background: rgba(255, 235, 59, 0.4) !important;
            box-shadow: inset 0 0 0 2px rgba(255, 193, 7, 0.6);
        }
        
        .results-table td.find-current {
            background: rgba(255, 152, 0, 0.5) !important;
            box-shadow: inset 0 0 0 2px var(--warning);
            animation: findPulse 1s ease infinite;
        }
        
        @keyframes findPulse {
            0%, 100% { box-shadow: inset 0 0 0 2px var(--warning); }
            50% { box-shadow: inset 0 0 0 3px var(--warning), 0 0 8px rgba(255, 152, 0, 0.4); }
        }
        
        .results-table td[contenteditable]:focus {
            outline: 2px solid var(--primary);
            outline-offset: -2px;
            background: rgba(0, 123, 255, 0.1);
        }
        
        .results-table tr.editing-row {
            background: rgba(0, 123, 255, 0.05);
        }
        
        /* Row Selection Styles */
        .results-table tr.row-selected {
            background: rgba(33, 115, 70, 0.1) !important;
        }
        
        .results-table tr.row-selected:hover {
            background: rgba(33, 115, 70, 0.15) !important;
        }
        
        .row-select-checkbox {
            cursor: pointer;
            accent-color: var(--primary);
            width: 16px;
            height: 16px;
        }
        
        .row-checkbox-cell {
            text-align: center;
            padding: 8px;
            background: var(--bg-medium) !important;
            border-right: 1px solid var(--border);
        }
        
        .row-checkbox-cell.selected {
            background: rgba(33, 115, 70, 0.3) !important;
        }
        
        .row-select {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .highlight {
            background: var(--warning);
            color: black;
            padding: 1px 2px;
            border-radius: 2px;
        }
        
        /* New Row Panel */
        .new-row-panel {
            background: var(--bg-medium);
            border: 2px solid var(--success);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .new-row-panel.hidden {
            display: none;
        }
        
        .new-row-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .new-row-title {
            font-weight: 600;
            font-size: 16px;
            color: var(--success);
        }
        
        .new-row-form {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
            padding: 15px;
            background: var(--bg-dark);
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        
        .new-row-field {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .new-row-field label {
            font-size: 12px;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .new-row-field input {
            padding: 8px 10px;
            background: var(--bg-lighter);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 13px;
        }
        
        .new-row-field input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .new-row-actions {
            display: flex;
            gap: 15px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }
        
        /* Transfer Panel */
        .transfer-panel {
            background: var(--bg-medium);
            border-top: 1px solid var(--border);
            padding: 20px;
        }
        
        .transfer-panel.hidden {
            display: none;
        }
        
        .transfer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }
        
        .transfer-title {
            font-weight: 600;
            font-size: 16px;
        }
        
        .transfer-form {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        
        .transfer-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .transfer-field label {
            font-size: 13px;
            color: var(--text-muted);
        }
        
        .transfer-field select,
        .transfer-field input {
            padding: 10px 12px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 14px;
            min-width: 150px;
        }
        
        .transfer-field select:focus,
        .transfer-field input:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .transfer-field input[type="text"] {
            min-width: 250px;
        }
        
        /* Status Messages */
        .status {
            padding: 10px 15px;
            border-radius: 4px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid var(--success);
            color: var(--success);
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid var(--error);
            color: var(--error);
        }
        
        .status.info {
            background: rgba(33, 150, 243, 0.2);
            border: 1px solid var(--info);
            color: var(--info);
        }
        
        /* Empty State */
        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            color: var(--text-muted);
            padding: 20px 40px;
            text-align: center;
        }
        
        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }
        
        .empty-state-title {
            font-size: 20px;
            margin-bottom: 10px;
            color: var(--text);
        }
        
        .empty-state-text {
            max-width: 400px;
            line-height: 1.6;
        }
        
        /* Column Mapping Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            overflow: hidden;
        }
        
        .modal-overlay.hidden {
            display: none;
        }
        
        .modal {
            background: var(--bg-medium);
            border-radius: 8px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            resize: both;
            overflow: hidden;
            min-width: 400px;
            min-height: 300px;
            position: relative;
        }
        
        .modal.modal-large {
            resize: both;
            overflow: hidden;
        }
        
        /* Sichtbares Resize-Handle f√ºr Modals */
        .modal.modal-large::after {
            content: '';
            position: absolute;
            right: 0;
            bottom: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            background: linear-gradient(135deg, transparent 50%, var(--border) 50%, var(--border) 60%, transparent 60%, transparent 70%, var(--border) 70%, var(--border) 80%, transparent 80%);
            border-radius: 0 0 8px 0;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        
        .modal.modal-large:hover::after {
            opacity: 1;
            background: linear-gradient(135deg, transparent 50%, var(--primary) 50%, var(--primary) 60%, transparent 60%, transparent 70%, var(--primary) 70%, var(--primary) 80%, transparent 80%);
        }
        
        .modal.modal-fullscreen::after {
            display: none;
        }
        
        /* Vollbild-Modus f√ºr Modals */
        .modal.modal-fullscreen {
            width: 100vw !important;
            max-width: 100vw !important;
            height: 100vh !important;
            max-height: 100vh !important;
            min-width: 100vw !important;
            min-height: 100vh !important;
            border-radius: 0;
            resize: none;
        }
        
        .modal-fullscreen-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            margin-right: 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .modal-fullscreen-btn:hover {
            color: var(--text);
            background: var(--bg-dark);
        }
        
        /* Verhindert Scroll-Durchgang bei offenen Modals */
        body.modal-open {
            overflow: hidden;
        }
        
        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        
        .modal-close:hover {
            color: var(--text);
        }
        
        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }
        
        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        /* Mapping List Styles */
        .mapping-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .mapping-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-light);
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        
        .mapping-item select {
            flex: 1;
            padding: 8px 10px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text);
            font-size: 14px;
            min-width: 150px;
        }
        
        .mapping-item select:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .mapping-arrow {
            color: var(--primary-light);
            font-size: 18px;
            font-weight: bold;
            padding: 0 5px;
        }
        
        .mapping-target {
            color: var(--text-muted);
            font-size: 13px;
            min-width: 150px;
        }
        
        .mapping-remove {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .mapping-remove:hover {
            background: var(--error);
            border-color: var(--error);
            color: white;
        }
        
        /* Column Visibility Control */
        .column-toggle-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 8px;
            padding: 15px;
            background: var(--bg-light);
            border-radius: 6px;
            margin-bottom: 10px;
            min-height: 80px;
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid var(--border);
        }
        
        .column-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .column-toggle:hover {
            border-color: var(--primary);
        }
        
        .column-toggle.hidden-col {
            opacity: 0.5;
            background: var(--bg-lighter);
        }
        
        .column-toggle input {
            cursor: pointer;
        }
        
        .column-toggle label {
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }
        
        /* Transfer History */
        .history-section {
            margin-top: 20px;
        }
        
        .history-list {
            max-height: 200px;
            overflow-y: auto;
            background: var(--bg-light);
            border-radius: 6px;
            padding: 10px;
        }
        
        .history-item {
            font-size: 12px;
            padding: 6px 8px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }
        
        .history-item:last-child {
            border-bottom: none;
        }
        
        .history-time {
            color: var(--text-muted);
            font-size: 11px;
            white-space: nowrap;
        }
        
        /* Notification Animations */
        @keyframes slideInRight {
            from { opacity: 0; transform: translateX(100px); }
            to { opacity: 1; transform: translateX(0); }
        }
        @keyframes slideOutRight {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(100px); }
        }
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
            20% { opacity: 1; transform: translateX(-50%) translateY(0); }
            80% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="logo">
            <div class="logo-icon" style="font-size: 16px; line-height: 1.2;">üìä</div>
            <span>Excel Data Sync Pro</span>
        </div>
        <div class="header-actions">
            <button class="btn btn-primary" id="btnImportConfig" title="Gemeinsame config.json aus Programmordner laden">
                üìÇ config.json laden
            </button>
            <button class="btn btn-primary" id="btnExportConfig" title="Konfiguration als config.json speichern">
                üíæ config.json speichern
            </button>
            <button class="btn btn-secondary" id="btnHelp" title="Hilfe (F1)">
                ‚ùì Hilfe
            </button>
        </div>
    </header>
    
    <main class="main">
        <!-- Sidebar - Konfiguration -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-header-left">
                    <span>‚öôÔ∏è</span>
                    <span class="sidebar-header-text">Konfiguration</span>
                </div>
                <button class="sidebar-toggle" id="sidebarToggle" title="Sidebar ein-/ausklappen">‚óÄ</button>
            </div>
            <div class="sidebar-content">
                <!-- Arbeitsordner -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="workingDirectory">üìÅ Arbeitsordner</div>
                    <div class="config-group">
                        <button class="btn btn-primary" id="btnSelectWorkingDir" style="width: 100%; margin-bottom: 10px;" data-i18n="selectWorkingDir">
                            üìÇ Ordner ausw√§hlen
                        </button>
                        <div class="file-info" id="workingDirInfo" data-i18n="noWorkingDirSet" style="word-break: break-all;">Kein Ordner gew√§hlt</div>
                        <button class="btn btn-secondary" id="btnClearWorkingDir" style="width: 100%; margin-top: 8px; display: none;" data-i18n="clearWorkingDir">
                            ‚úñÔ∏è Arbeitsordner l√∂schen
                        </button>
                    </div>
                </div>
                
                <!-- Datei 1 - Quelle -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="file1Source">üìÑ Datei 1 (Quelle)</div>
                    <div class="config-group">
                        <button class="btn btn-primary" id="btnLoadFile1" style="width: 100%; margin-bottom: 10px;" data-i18n="loadSourceFile">
                            üìÇ Quelldatei laden
                        </button>
                        <div class="file-info" id="file1Info" data-i18n="noFileLoaded">Keine Datei geladen</div>
                        
                        <label class="config-label" style="margin-top: 12px;" data-i18n="worksheet">Arbeitsblatt:</label>
                        <select class="config-select" id="selectSheet1" disabled>
                            <option value="" data-i18n="loadFileFirst">-- Erst Datei laden --</option>
                        </select>
                    </div>
                </div>
                
                <!-- Datei 2 - Ziel -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="file2Target">üìÑ Datei 2 (Ziel)</div>
                    <div class="config-group">
                        <button class="btn btn-primary" id="btnLoadFile2" style="width: 100%; margin-bottom: 10px;" data-i18n="loadTargetFile">
                            üìÇ Zieldatei laden
                        </button>
                        <div class="file-info" id="file2Info" data-i18n="noFileLoaded">Keine Datei geladen</div>
                        
                        <label class="config-label" style="margin-top: 12px;" data-i18n="worksheet">Arbeitsblatt:</label>
                        <select class="config-select" id="selectSheet2" disabled>
                            <option value="" data-i18n="loadFileFirst">-- Erst Datei laden --</option>
                        </select>
                    </div>
                </div>
                
                <!-- Spalten-Mapping -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="columnMapping">üîó Spalten-Zuordnung</div>
                    <div class="config-group">
                        <button class="btn btn-primary" id="btnConfigMapping" style="width: 100%;" data-i18n="configureColumns">
                            ‚öôÔ∏è Spalten konfigurieren
                        </button>
                        <div class="file-info" id="mappingInfo" data-i18n="loadBothFiles">Laden Sie beide Dateien</div>
                        <div id="mappingPreview" style="margin-top: 10px; font-size: 12px; color: var(--text-muted);"></div>
                    </div>
                </div>
                
                <!-- Template f√ºr neuen Monat -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="monthTemplate">üìÑ Monats-Template</div>
                    <div class="config-group">
                        <button class="btn btn-success" id="btnNewMonth" disabled style="width: 100%; margin-bottom: 10px;" title="Erstellt neue Monatsdatei aus Template" data-i18n="newMonthFile">
                            üìÖ Neue Monatsdatei
                        </button>
                        <button class="btn btn-primary" id="btnLoadTemplate" style="width: 100%; margin-bottom: 10px;" data-i18n="loadTemplate">
                            üìÇ Template laden
                        </button>
                        <button class="btn btn-secondary" id="btnCreateTemplate" style="width: 100%; margin-bottom: 10px;" data-i18n="createTemplateFromSource" title="Erstellt ein leeres Template aus einer Quelldatei mit allen Formatierungen">
                            üîß Template aus Quelldatei
                        </button>
                        <div class="file-info" id="templateInfo" data-i18n="noTemplateLoaded">Kein Template geladen</div>
                        <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;" data-i18n="templateHint">
                            Leere Excel-Vorlage f√ºr "üìÖ Neue Monatsdatei"
                        </div>
                    </div>
                </div>
                
                <!-- Transfer History -->
                <div class="config-section history-section">
                    <div class="config-section-title" data-i18n="lastTransfers">üìã Letzte √úbertragungen</div>
                    <div class="history-list" id="historyList">
                        <div style="color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px;" data-i18n="noTransfersYet">
                            Noch keine √úbertragungen
                        </div>
                    </div>
                </div>
                
                <!-- Einstellungen: Sprache & Theme (unten) -->
                <div class="config-section">
                    <div class="config-section-title" data-i18n="settings">‚öôÔ∏è Einstellungen</div>
                    <div class="config-group" style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 100px;">
                            <label class="config-label" data-i18n="language">Sprache</label>
                            <select class="config-select" id="selectLanguage" style="width: 100%;">
                                <option value="de">üá©üá™ Deutsch</option>
                                <option value="en">üá¨üáß English</option>
                            </select>
                        </div>
                        <div style="flex: 1; min-width: 100px;">
                            <label class="config-label" data-i18n="theme">Design</label>
                            <select class="config-select" id="selectTheme" style="width: 100%;">
                                <option value="dark" data-i18n="themeDark">üåô Dunkel</option>
                                <option value="light" data-i18n="themeLight">‚òÄÔ∏è Hell</option>
                            </select>
                        </div>
                    </div>
                    <div style="margin-top: 15px;">
                        <button class="btn btn-secondary" id="btnLicense" style="width: 100%;">
                            üìú <span data-i18n="license">Lizenz</span>
                        </button>
                    </div>
                    <div style="margin-top: 10px;">
                        <button class="btn btn-secondary" id="btnSecurityLogs" style="width: 100%;">
                            üìã <span data-i18n="logsButton">Protokolle</span>
                        </button>
                    </div>

                </div>
            </div>
        </aside>
        
        <!-- Content -->
        <div class="content">
            <!-- Search Section -->
            <div class="search-section">
                <div class="search-box">
                    <div class="search-wrapper">
                        <input type="text" class="search-input" id="searchInput" 
                               placeholder="Suche... (* ? f√ºr Platzhalter, AND/OR f√ºr Verkn√ºpfung)" disabled autocomplete="off">
                        <div class="search-history-dropdown" id="searchHistoryDropdown"></div>
                    </div>
                    <button class="btn btn-primary" id="btnSearch" disabled>
                        üîç Suchen
                    </button>
                    <button class="btn btn-primary" id="btnNewRow" disabled title="Neue Zeile manuell erstellen">
                        ‚ûï Neue Zeile
                    </button>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <div class="search-results-info" id="searchResultsInfo"></div>
                    
                    <!-- Search Results Pagination -->
                    <div id="searchPagination" style="display: none; align-items: center; gap: 8px;">
                        <button class="btn btn-secondary btn-sm" id="btnSearchFirstPage" title="Erste Seite">‚èÆ</button>
                        <button class="btn btn-secondary btn-sm" id="btnSearchPrevPage" title="Vorherige Seite">‚óÄ</button>
                        <span id="searchPageInfo" style="color: var(--text-muted); font-size: 13px; min-width: 120px; text-align: center;">Seite 1 von 1</span>
                        <button class="btn btn-secondary btn-sm" id="btnSearchNextPage" title="N√§chste Seite">‚ñ∂</button>
                        <button class="btn btn-secondary btn-sm" id="btnSearchLastPage" title="Letzte Seite">‚è≠</button>
                        <select id="searchPageSize" style="padding: 4px 8px; border-radius: 4px; background: var(--bg-light); border: 1px solid var(--border); color: var(--text-primary);">
                            <option value="50">50 / Seite</option>
                            <option value="100" selected>100 / Seite</option>
                            <option value="250">250 / Seite</option>
                            <option value="500">500 / Seite</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- New Row Panel (editierbare Vorlage) -->
            <div class="new-row-panel hidden" id="newRowPanel">
                <div class="new-row-header">
                    <div class="new-row-title">‚úèÔ∏è Neue Zeile erstellen</div>
                    <button class="btn btn-secondary btn-sm" id="btnCloseNewRow">‚úï Schlie√üen</button>
                </div>
                <div class="new-row-form" id="newRowForm">
                    <!-- Wird dynamisch mit den konfigurierten Spalten gef√ºllt -->
                </div>
                <div class="new-row-actions">
                    <div class="transfer-field">
                        <label>Flag:</label>
                        <select id="newRowFlag">
                            <option value="A">A (Add)</option>
                            <option value="D">D (Delete)</option>
                            <option value="C">C (Change)</option>
                            <option value="leer">Leerzeile</option>
                        </select>
                    </div>
                    <div class="transfer-field">
                        <label>Kommentar:</label>
                        <input type="text" id="newRowComment" placeholder="Freier Text...">
                    </div>
                    <button class="btn btn-primary" id="btnAddNewRowToQueue">
                        ‚ûï Zur Warteschlange
                    </button>
                    <button class="btn btn-primary" id="btnTransferNewRowDirect">
                        ‚û°Ô∏è Direkt √ºbertragen
                    </button>
                    <button class="btn btn-secondary" id="btnAddEmptyRow" title="Leere Zeile einf√ºgen (unabh√§ngig von Flag-Spalte)">
                        ‚¨ú Leerzeile
                    </button>
                </div>
                <div id="newRowStatus"></div>
            </div>
            
            <!-- Results -->
            <div class="results-section" id="resultsSection">
                <div class="empty-state" id="emptyState">
                    <div class="empty-state-icon">üìä</div>
                    <div class="empty-state-title">Bereit zum Starten</div>
                    <div class="empty-state-text">
                        1. Laden Sie die Quelldatei (Datei 1)<br>
                        2. Laden Sie die Zieldatei (Datei 2)<br>
                        3. Konfigurieren Sie die Spalten-Zuordnung<br>
                        4. Suchen Sie nach Zeilen und √ºbertragen Sie diese
                    </div>
                </div>
                
                <div class="results-table-container" id="resultsTableContainer" style="display: none;">
                    <table class="results-table" id="resultsTable">
                        <thead id="resultsTableHead"></thead>
                        <tbody id="resultsTableBody"></tbody>
                    </table>
                </div>
            </div>
            
            <!-- Transfer Panel -->
            <div class="transfer-panel hidden" id="transferPanel">
                <div class="transfer-header">
                    <div class="transfer-title">üì§ Zeile(n) zur √úbertragung vorbereiten (<span id="selectedCount">1</span> ausgew√§hlt)</div>
                </div>
                <div class="transfer-form">
                    <div class="transfer-field">
                        <label>Spalte 1 - Flag:</label>
                        <select id="transferFlag">
                            <option value="A">A (Add)</option>
                            <option value="D">D (Delete)</option>
                            <option value="C">C (Change)</option>
                            <option value="leer">Leerzeile</option>
                        </select>
                    </div>
                    <div class="transfer-field">
                        <label>Spalte 2 - Kommentar:</label>
                        <input type="text" id="transferComment" placeholder="Freier Text...">
                    </div>
                    <button class="btn btn-primary" id="btnAddToQueue">
                        ‚ûï Markierte zur Warteschlange
                    </button>
                    <button class="btn btn-primary" id="btnTransferDirect">
                        ‚û°Ô∏è Markierte direkt √ºbertragen
                    </button>
                    <button class="btn btn-primary" id="btnSelectAll" style="margin-left: auto; min-width: 160px;">
                        ‚úì Alle ausw√§hlen
                    </button>
                    <button class="btn btn-primary" id="btnDeselectAll" style="min-width: 160px;">
                        ‚úó Alles abw√§hlen
                    </button>
                </div>
                <div id="transferStatus"></div>
            </div>
            
            <!-- Queue Panel -->
            <div class="transfer-panel" id="queuePanel" style="border-top: 2px solid var(--primary);">
                <div class="transfer-header">
                    <div class="transfer-title">üìã Warteschlange (<span id="queueCount">0</span> Zeilen)</div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-primary" id="btnClearQueue" disabled>
                            üóëÔ∏è Leeren
                        </button>
                        <button class="btn btn-secondary" id="btnPreviewTransfer" disabled title="Vorschau der √Ñnderungen anzeigen">
                            üëÅÔ∏è Vorschau
                        </button>
                        <button class="btn btn-primary" id="btnExportPS" disabled title="Exportiert Warteschlange als JSON zur Zieldatei" style="border: 2px solid white; box-shadow: 0 0 4px rgba(255,255,255,0.5);">
                            üì§ Export zur Zieldatei
                        </button>
                        <button class="btn btn-primary" id="btnDataExplorer" disabled title="Datenexplorer - Zieldatei anzeigen und exportieren">
                            Datenexplorer
                        </button>
                    </div>
                </div>
                <div class="queue-list" id="queueList">
                    <div class="queue-empty">Keine Zeilen in der Warteschlange</div>
                </div>
            </div>
        </div>
    </main>
    
    <!-- Footer -->
    <footer style="background: var(--bg-medium); border-top: 1px solid var(--border); padding: 8px 20px; text-align: center; color: var(--text-muted); font-size: 12px;">
        ¬© Norbert Jander 2025 ¬∑ v1.0.15
    </footer>
    
    <!-- Mapping Modal -->
    <div class="modal-overlay hidden" id="mappingModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">üîó Spalten-Zuordnung konfigurieren</div>
                <button class="modal-close" id="btnCloseMappingModal">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: var(--text-muted);">
                    W√§hlen Sie, welche Spalten aus Datei 1 in welche Spalten von Datei 2 kopiert werden sollen.
                </p>
                
                <div class="config-group">
                    <label class="config-label">Start-Spalte in Datei 2 (f√ºr Quelldaten):</label>
                    <div id="targetStartColumnDisplay" style="padding: 8px 12px; background: var(--bg-light); border-radius: 6px; font-weight: bold; color: var(--excel-green);">
                        Spalte C (automatisch berechnet)
                    </div>
                    <div style="font-size: 12px; color: var(--text-muted); margin-top: 6px;">
                        üìå Die Start-Spalte wird automatisch berechnet: Flag + Kommentar Spalten werden vorangestellt.
                    </div>
                </div>
                
                <div class="config-group">
                    <label class="config-label">Duplikat-Pr√ºfung (Spalte aus Datei 1):</label>
                    <select class="config-select" id="duplicateCheckColumn"></select>
                    <div style="font-size: 12px; color: var(--text-muted); margin-top: 6px;">
                        Diese Spalte wird gepr√ºft, ob der Wert bereits in Datei 2 existiert.
                    </div>
                </div>
                
                <div class="config-section-title" style="margin-top: 20px;">Zu kopierende Spalten aus Datei 1:</div>
                <div class="mapping-list" id="mappingList"></div>
                
                <button class="btn btn-primary" id="btnAddMapping" style="margin-top: 10px;">
                    ‚ûï Spalte hinzuf√ºgen
                </button>
                
                <!-- Extra-Spalten Konfiguration -->
                <div class="config-section-title" style="margin-top: 25px; padding-top: 15px; border-top: 1px solid var(--border);">
                    üìù Extra-Spalten (optional)
                </div>
                <p style="margin-bottom: 15px; color: var(--text-muted); font-size: 13px;">
                    Zus√§tzliche Spalten f√ºr Flag-Markierungen und Kommentare. Diese werden separat von den Quelldaten in die Zieldatei geschrieben.
                </p>
                
                <!-- Flag-Spalte -->
                <div class="extra-column-config" style="background: var(--bg-light); padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <input type="checkbox" id="enableFlagColumn" class="green-checkbox">
                        <label style="font-weight: bold; cursor: pointer;" for="enableFlagColumn">üè∑Ô∏è Flag-Spalte</label>
                        <span id="flagColumnDisplay" style="color: var(--text-muted); font-size: 12px; margin-left: auto;">‚Üí Spalte A</span>
                    </div>
                    <div id="flagColumnConfig" style="display: flex; flex-wrap: wrap; gap: 10px; padding-left: 26px;">
                        <div style="flex: 1; min-width: 200px;">
                            <label class="config-label" style="font-size: 12px;">Verf√ºgbare Werte (kommagetrennt):</label>
                            <input type="text" class="search-input" id="flagValues" value="A,D,C,leer" style="font-size: 13px; padding: 6px 10px;" placeholder="z.B. A,D,C,leer">
                        </div>
                    </div>
                </div>
                
                <!-- Kommentar-Spalte -->
                <div class="extra-column-config" style="background: var(--bg-light); padding: 12px; border-radius: 6px;">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                        <input type="checkbox" id="enableCommentColumn" class="green-checkbox">
                        <label style="font-weight: bold; cursor: pointer;" for="enableCommentColumn">üí¨ Kommentar-Spalte</label>
                        <span id="commentColumnDisplay" style="color: var(--text-muted); font-size: 12px; margin-left: auto;">‚Üí Spalte B</span>
                    </div>
                    <div id="commentColumnConfig" style="display: flex; flex-wrap: wrap; gap: 10px; padding-left: 26px;">
                        <div style="flex: 1; min-width: 200px;">
                            <label class="config-label" style="font-size: 12px;">Platzhalter-Text:</label>
                            <input type="text" class="search-input" id="commentPlaceholder" value="Freier Text..." style="font-size: 13px; padding: 6px 10px;" placeholder="Platzhalter f√ºr Eingabefeld">
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="btnCancelMapping">Abbrechen</button>
                <button class="btn btn-primary" id="btnSaveMapping">üíæ Speichern</button>
            </div>
        </div>
    </div>
    
    <!-- Create Template Modal -->
    <div class="modal-overlay hidden" id="createTemplateModal">
        <div class="modal" style="max-width: 550px; resize: none;">
            <div class="modal-header">
                <div class="modal-title" data-i18n="createTemplateTitle">üîß Template aus Quelldatei erstellen</div>
                <button class="modal-close" id="btnCloseCreateTemplateModal">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; color: var(--text-muted);" data-i18n="createTemplateDesc">
                    Erstellt ein leeres Template mit allen Formatierungen und bedingten Formatierungen aus der Quelldatei.
                </p>
                <div style="margin-bottom: 15px; padding: 10px; background: var(--bg-dark); border-radius: 6px;">
                    <strong data-i18n="sourceFileLabel">Quelldatei:</strong> <span id="createTemplateSourceName" style="color: var(--text-muted);">-</span>
                </div>
                
                <!-- Extra-Spalten im Template -->
                <div style="margin-bottom: 15px; padding: 12px; background: var(--bg-dark); border-radius: 6px; border: 1px solid var(--border);">
                    <label class="config-label" style="margin-bottom: 10px; display: block;" data-i18n="extraColumnsInTemplate">Extra-Spalten im Template erstellen:</label>
                    <div style="display: flex; gap: 20px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="templateFlagColumn" class="green-checkbox" style="margin-right: 8px;">
                            <span>üè∑Ô∏è <span data-i18n="flagColumn">Flag-Spalte (A)</span></span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="templateCommentColumn" class="green-checkbox" style="margin-right: 8px;">
                            <span>üí¨ <span data-i18n="commentColumn">Kommentar-Spalte (B)</span></span>
                        </label>
                    </div>
                    <p style="font-size: 10px; color: var(--text-muted); margin-top: 8px;" data-i18n="extraColumnsHint">
                        Aktivieren, wenn in "Spalten konfigurieren" die entsprechenden Optionen genutzt werden.
                    </p>
                </div>
                
                <label class="config-label" data-i18n="selectSheets">Arbeitsbl√§tter ausw√§hlen:</label>
                <div id="createTemplateSheetList" style="max-height: 200px; overflow-y: auto; border: 1px solid var(--border); border-radius: 6px; padding: 10px; margin-bottom: 15px; background: var(--bg-dark);">
                    <div style="color: var(--text-muted); text-align: center;" data-i18n="loadSourceFirst">Laden Sie zuerst eine Quelldatei</div>
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="btn btn-secondary" id="btnSelectAllSheets" style="flex: 1;" data-i18n="selectAll">‚úì Alle ausw√§hlen</button>
                    <button class="btn btn-secondary" id="btnDeselectAllSheets" style="flex: 1;" data-i18n="deselectAll">‚úó Alle abw√§hlen</button>
                </div>
                <p style="font-size: 11px; color: var(--text-muted);" data-i18n="templateInfoText">
                    üí° Die Header-Zeile wird behalten, alle Datenzeilen werden gel√∂scht. CF-Regeln werden auf ganze Spalten erweitert.
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="btnCancelCreateTemplate" data-i18n="cancel">Abbrechen</button>
                <button class="btn btn-primary" id="btnConfirmCreateTemplate" data-i18n="createAndSave">üîß Template erstellen & speichern</button>
            </div>
        </div>
    </div>
    
    <!-- New Month Modal -->
    <div class="modal-overlay hidden" id="newMonthModal">
        <div class="modal" style="max-width: 450px; width: 90%; resize: none;">
            <div class="modal-header">
                <div class="modal-title">üìÖ Neue Monatsdatei erstellen</div>
                <button class="modal-close" id="btnCloseNewMonthModal">&times;</button>
            </div>
            <div class="modal-body" style="overflow: hidden;">
                <p style="margin-bottom: 15px; color: var(--text-muted);">
                    Erstellt eine Kopie der Template-Datei unter neuem Namen und setzt sie als Datei 2.
                </p>
                <label class="config-label">Neuer Dateiname:</label>
                <input type="text" class="search-input" id="newMonthFilename" style="width: 100%; min-width: 0; box-sizing: border-box; margin-bottom: 15px;" placeholder="z.B. Vertragsliste_2025-01.xlsx">
                <p style="font-size: 12px; color: var(--text-muted);">
                    üí° Template: <strong id="newMonthTemplateName">-</strong>
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="btnCancelNewMonth">Abbrechen</button>
                <button class="btn btn-primary" id="btnConfirmNewMonth">üìÖ Erstellen & Laden</button>
            </div>
        </div>
    </div>
    
    <!-- Help Modal -->
    <div class="modal-overlay hidden" id="helpModal">
        <div class="modal" style="max-width: 800px;">
            <div class="modal-header">
                <div class="modal-title">‚ùì Hilfe - Excel Data Sync Pro</div>
                <button class="modal-close" id="btnCloseHelpModal">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <h3 style="margin-bottom: 10px;">üöÄ Schnellstart</h3>
                <ol style="line-height: 2; padding-left: 20px; margin-bottom: 20px;">
                    <li><strong>Quelldatei laden:</strong> Klicken Sie auf "üìÇ Quelldatei laden" und w√§hlen Sie die Excel-Datei, aus der Zeilen kopiert werden sollen.</li>
                    <li><strong>Zieldatei laden:</strong> Laden Sie die Excel-Datei, in die die Zeilen eingef√ºgt werden sollen.</li>
                    <li><strong>Spalten konfigurieren:</strong> Legen Sie fest, welche Spalten kopiert werden sollen.</li>
                    <li><strong>Suchen & √úbertragen:</strong> Suchen Sie nach Zeilen und √ºbertragen Sie diese zur Zieldatei.</li>
                </ol>
                
                <h3 style="margin-bottom: 10px;">üìÇ Dateien laden</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    <strong>Quelldatei (Datei 1):</strong> Die Excel-Datei, aus der Sie Daten kopieren m√∂chten.<br>
                    <strong>Zieldatei (Datei 2):</strong> Die Excel-Datei, in die die Daten eingef√ºgt werden.<br>
                    Nach dem Laden k√∂nnen Sie das gew√ºnschte Arbeitsblatt ausw√§hlen.
                </p>
                
                <h3 style="margin-bottom: 10px;">üîó Spalten-Zuordnung</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    Klicken Sie auf "‚öôÔ∏è Spalten konfigurieren" um festzulegen:<br>
                    ‚Ä¢ <strong>Start-Spalte:</strong> Ab welcher Spalte die Daten in Datei 2 eingef√ºgt werden (Spalte 1+2 = Flag & Kommentar)<br>
                    ‚Ä¢ <strong>Duplikat-Pr√ºfung:</strong> Welche Spalte zur Erkennung von Duplikaten verwendet wird<br>
                    ‚Ä¢ <strong>Zu kopierende Spalten:</strong> Welche Spalten aus Datei 1 √ºbertragen werden
                </p>
                
                <h3 style="margin-bottom: 10px;">üîç Suche</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Geben Sie einen Suchbegriff ein und dr√ºcken Sie Enter oder klicken Sie auf "üîç Suchen".<br>
                    Die Suche durchsucht alle Spalten der Quelldatei. Die letzten 15 Suchen werden gespeichert.
                </p>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 20px; margin-bottom: 10px;">
                    <code style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">*</code>
                    <span>Beliebig viele Zeichen (z.B. <code>ABC*</code>, <code>*123*</code>)</span>
                    <code style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">?</code>
                    <span>Genau ein Zeichen (z.B. <code>A?C</code> findet ABC, ADC, ...)</span>
                </div>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Erweiterte Suche mit AND/OR:</strong>
                </p>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 20px; margin-bottom: 20px;">
                    <code style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">A AND B</code>
                    <span>Findet Zeilen die sowohl A als auch B enthalten</span>
                    <code style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">A OR B</code>
                    <span>Findet Zeilen die A oder B (oder beides) enthalten</span>
                    <code style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Projekt AND 2025</code>
                    <span>Beispiel: Projekt-Eintr√§ge aus 2025</span>
                </div>
                
                <h3 style="margin-bottom: 10px;">‚úèÔ∏è Suchergebnisse bearbeiten</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    Die Zellen in den Suchergebnissen sind <strong>direkt editierbar</strong>!<br>
                    Klicken Sie in eine Zelle und √§ndern Sie den Wert. Bearbeitete Zellen werden gelb markiert.<br>
                    Die √Ñnderungen werden beim √úbertragen zur Zieldatei √ºbernommen.
                </p>
                
                <h3 style="margin-bottom: 10px;">üì§ √úbertragung</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    <strong>Flag:</strong> A (Add), D (Delete), C (Change) oder Leerzeile<br>
                    <strong>Kommentar:</strong> Optionaler Text f√ºr Spalte 2<br>
                    <strong>Zur Warteschlange:</strong> Sammelt mehrere Zeilen f√ºr gemeinsame √úbertragung<br>
                    <strong>Direkt √ºbertragen:</strong> F√ºgt die Zeilen sofort zur Warteschlange und √ºbertr√§gt
                </p>
                
                <h3 style="margin-bottom: 10px;">üìã Warteschlange</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;
                ">
                    Die Warteschlange zeigt alle zur √úbertragung vorgemerkten Zeilen.<br>
                    <strong>üëÅÔ∏è Vorschau:</strong> Zeigt eine Diff-Ansicht mit allen √Ñnderungen vor der √úbertragung<br>
                    <strong>‚úÖ Direkt √ºbertragen:</strong> Schreibt alle Zeilen direkt in die Excel-Zieldatei<br>
                    <strong>üóëÔ∏è Leeren:</strong> Entfernt alle Zeilen aus der Warteschlange
                </p>
                
                <h3 style="margin-bottom: 10px;">‚ûï Neue Zeile manuell erstellen</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    Mit "‚ûï Neue Zeile" k√∂nnen Sie Zeilen manuell eingeben, ohne sie in der Quelldatei suchen zu m√ºssen.<br>
                    Ideal f√ºr Leerzeilen oder Daten, die nicht in der Quelldatei vorhanden sind.
                </p>
                
                <h3 style="margin-bottom: 10px;">üìä Datenexplorer</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Der Datenexplorer ist ein leistungsstarkes Werkzeug zum √ñffnen, Durchsuchen, Bearbeiten und Filtern von Excel-Dateien.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üìÇ Datei √∂ffnen</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    ‚Ä¢ Klicken Sie auf "üìä Datenexplorer" und dann "üìÇ Datei √∂ffnen"<br>
                    ‚Ä¢ W√§hlen Sie das gew√ºnschte Arbeitsblatt aus dem Dropdown
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üîç Suche & Filter</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Volltextsuche:</strong> Durchsucht alle Spalten mit Platzhalter-Unterst√ºtzung (* und ?)<br>
                    <strong>Spaltenfilter:</strong> Klicken Sie auf "+ Filter hinzuf√ºgen" f√ºr gezielte Filterung:<br>
                </p>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 15px; margin: 0 0 10px 15px; font-size: 13px;">
                    <code>enth√§lt / enth√§lt nicht</code><span>Teilstring-Suche</span>
                    <code>gleich / ungleich</code><span>Exakte √úbereinstimmung</span>
                    <code>beginnt mit / endet mit</code><span>Position im Text</span>
                    <code>ist leer / ist nicht leer</code><span>Leere Zellen finden</span>
                    <code>&gt; / &lt; / &gt;= / &lt;=</code><span>Numerische Vergleiche</span>
                </div>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üìã Spalten verwalten</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Spalten ein-/ausblenden:</strong> √úber "Spalten" ‚Üí Checkboxen aktivieren/deaktivieren<br>
                    <strong>Sortierung:</strong> Rechtsklick auf Spalten√ºberschrift √∂ffnet Kontextmen√º mit Sortieroptionen:<br>
                </p>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 15px; margin: 0 0 10px 15px; font-size: 13px;">
                    <code>A‚ÜíZ / Z‚ÜíA</code><span>Alphabetische Sortierung</span>
                    <code>0‚Üí9 / 9‚Üí0</code><span>Numerische Sortierung</span>
                    <code>Datum ‚Üë / Datum ‚Üì</code><span>Datumsortierung (deutsches Format)</span>
                </div>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Drag & Drop:</strong> Spalten per Drag & Drop neu anordnen
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">‚úèÔ∏è Zellen bearbeiten</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Alle Zellen sind <strong>direkt editierbar</strong>! Klicken Sie in eine Zelle und √§ndern Sie den Wert.<br>
                    Bearbeitete Zellen werden <span style="background: rgba(255, 193, 7, 0.3); padding: 2px 6px; border-radius: 3px;">gelb markiert</span>.<br>
                    <strong>Strg+Z / Strg+Y:</strong> √Ñnderungen r√ºckg√§ngig machen / wiederherstellen
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">ÔøΩ Multi-Zellen-Auswahl</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Klick:</strong> Einzelne Zelle ausw√§hlen<br>
                    <strong>Shift+Klick:</strong> Bereich von Zellen ausw√§hlen (von letzter Auswahl bis Klickposition)<br>
                    <strong>Strg+Klick:</strong> Einzelne Zellen zur Auswahl hinzuf√ºgen/entfernen<br>
                    <strong>Maus ziehen:</strong> Rechteckigen Bereich ausw√§hlen<br>
                    <strong>Rechtsklick auf Auswahl:</strong> Kontextmen√º mit Optionen:
                </p>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 15px; margin: 0 0 10px 15px; font-size: 13px;">
                    <code>üóëÔ∏è Inhalte l√∂schen</code><span>L√∂scht alle ausgew√§hlten Zellinhalte</span>
                    <code>üìã Kopieren</code><span>Kopiert Zellinhalte in die Zwischenablage</span>
                    <code>‚ùå Auswahl aufheben</code><span>Hebt die aktuelle Auswahl auf</span>
                </div>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üé® Zeilen markieren</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Rechtsklick auf Zeile:</strong> √ñffnet Kontextmen√º zur farbigen Markierung<br>
                    Verf√ºgbare Farben: üü¢ Gr√ºn, üü° Gelb, üü† Orange, üî¥ Rot, üîµ Blau, üü£ Lila<br>
                    Markierungen helfen beim visuellen Organisieren und bleiben beim Filtern erhalten.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üëÅÔ∏è Vorschau</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Klicken Sie auf "üëÅÔ∏è Vorschau" um das gesamte Datenblatt mit allen √Ñnderungen zu sehen,<br>
                    bevor Sie exportieren. Bearbeitete Zellen werden hervorgehoben.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">‚ûï Zeilen & Spalten hinzuf√ºgen/l√∂schen</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>Zeilen-Operationen (Rechtsklick auf Zeile):</strong><br>
                    ‚Ä¢ ‚¨ÜÔ∏è Zeile dar√ºber einf√ºgen<br>
                    ‚Ä¢ ‚¨áÔ∏è Zeile darunter einf√ºgen<br>
                    ‚Ä¢ üóëÔ∏è Zeile l√∂schen (mit Best√§tigungsdialog)<br><br>
                    <strong>Spalten-Operationen (Rechtsklick auf Spalten√ºberschrift):</strong><br>
                    ‚Ä¢ ‚¨ÖÔ∏è Spalte links einf√ºgen (mit Namenseingabe)<br>
                    ‚Ä¢ ‚û°Ô∏è Spalte rechts einf√ºgen (mit Namenseingabe)<br>
                    ‚Ä¢ üóëÔ∏è Spalte l√∂schen (mit Warnung √ºber Datenverlust)<br>
                    ‚Ä¢ üëÅÔ∏è Spalte ausblenden
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üîÑ Crash-Recovery</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Der Datenexplorer speichert automatisch alle 30 Sekunden Ihre √Ñnderungen im Hintergrund.<br>
                    Bei einem Absturz oder Stromausfall k√∂nnen Sie beim n√§chsten √ñffnen w√§hlen, ob die letzte Sitzung wiederhergestellt werden soll.<br>
                    Recovery-Daten werden nach 24 Stunden automatisch gel√∂scht.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">‚ö†Ô∏è Warnung bei ungespeicherten √Ñnderungen</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Beim Schlie√üen des Datenexplorers mit ungespeicherten √Ñnderungen erscheint eine Warnung.<br>
                    Sie k√∂nnen w√§hlen, ob Sie trotzdem schlie√üen oder zur√ºckkehren m√∂chten.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üì§ Speichern & Export</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong>üíæ Speichern / Exportieren:</strong> Speichert √Ñnderungen in die Datei<br>
                    ‚Ä¢ √úberschreibt Originaldatei oder speichert als neue Datei<br>
                    ‚Ä¢ Zeigt Best√§tigungsdialog mit Anzahl der √Ñnderungen<br>
                    ‚Ä¢ Alle Formatierungen der Originaldatei bleiben erhalten<br>
                    ‚Ä¢ Auswahl welche Arbeitsbl√§tter mit exportiert werden sollen
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üìã Arbeitsbl√§tter wechseln</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    W√§hlen Sie ein anderes Arbeitsblatt aus dem Dropdown. Alle Ihre √Ñnderungen werden automatisch zwischengespeichert und bleiben beim Wechsel zwischen Sheets erhalten.
                </p>
                
                <h3 style="margin-bottom: 10px;">üìÑ Template-Funktionen</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Templates dienen als Vorlagen f√ºr neue Monatsdateien. Alle Formatierungen werden √ºbernommen.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üìÇ Template laden</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    L√§dt eine bestehende Excel-Datei als Template f√ºr neue Monatsdateien.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üìÖ Neue Monatsdatei erstellen</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    Erstellt eine Kopie des Templates mit neuem Namen (z.B. f√ºr einen neuen Monat).<br>
                    Die neue Datei wird automatisch als Zieldatei (Datei 2) geladen.
                </p>
                
                <h4 style="margin: 15px 0 8px 0; color: var(--primary);">üîß Template aus Quelldatei erstellen</h4>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    Erstellt ein leeres Template aus einer bestehenden Datei:<br>
                    ‚Ä¢ W√§hlen Sie welche Arbeitsbl√§tter √ºbernommen werden sollen<br>
                    ‚Ä¢ Alle Formatierungen, bedingte Formatierungen und Formeln bleiben erhalten<br>
                    ‚Ä¢ Die Datenzeilen werden entfernt, nur √úberschriften bleiben
                </p>
                
                <h3 style="margin-bottom: 10px;">üìÅ Arbeitsordner</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    Legen Sie einen Arbeitsordner fest, der als Standard-Verzeichnis f√ºr alle Datei-Dialoge verwendet wird.<br>
                    Die config.json wird zuerst im Arbeitsordner gesucht, dann im Programmordner.
                </p>
                
                <h3 style="margin-bottom: 10px;">üíæ Konfiguration</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 15px;">
                    <strong>config.json laden:</strong> L√§dt eine gespeicherte Konfiguration (Spalten-Zuordnung, Dateipfade)<br>
                    <strong>config.json speichern:</strong> Speichert die aktuelle Konfiguration f√ºr sp√§teren Zugriff<br>
                    üí° Ideal f√ºr Teams: Eine config.json auf dem Netzlaufwerk f√ºr alle Nutzer!
                </p>
                
                <h3 style="margin-bottom: 10px;">‚å®Ô∏è Tastenk√ºrzel</h3>
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 8px 20px; margin-bottom: 20px;">
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Strg+F</kbd>
                    <span>Fokus auf Suchfeld setzen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Strg+S</kbd>
                    <span>Warteschlange exportieren / Daten speichern</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Strg+Enter</kbd>
                    <span>Ausgew√§hlte Zeilen direkt √ºbertragen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Strg+Z</kbd>
                    <span>Letzte Bearbeitung r√ºckg√§ngig machen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Strg+Y</kbd>
                    <span>R√ºckg√§ngig gemachte Bearbeitung wiederherstellen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">F5</kbd>
                    <span>Suche aktualisieren / Daten neu laden</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">F1</kbd>
                    <span>Diese Hilfe √∂ffnen/schlie√üen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Enter</kbd>
                    <span>Suche starten (im Suchfeld) / N√§chste Zeile (in Tabelle)</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Esc</kbd>
                    <span>Dialog schlie√üen / Bearbeitung abbrechen</span>
                    <kbd style="background: var(--bg-lighter); padding: 4px 8px; border-radius: 4px;">Tab</kbd>
                    <span>Zur n√§chsten Zelle in den Suchergebnissen</span>
                </div>
                
                <h3 style="margin-bottom: 10px;">‚ö†Ô∏è Wichtige Hinweise</h3>
                <p style="color: var(--text-muted); line-height: 1.6;">
                    ‚Ä¢ Die Zieldatei (Datei 2) muss in Excel <strong>geschlossen</strong> sein, bevor Sie √ºbertragen<br>
                    ‚Ä¢ Duplikate werden automatisch erkannt und als Warnung angezeigt<br>
                    ‚Ä¢ √Ñnderungen werden direkt in die Excel-Datei geschrieben (kein separater Export n√∂tig)<br>
                    ‚Ä¢ Die Sidebar kann mit dem ‚óÄ Button eingeklappt werden
                </p>
                
                <h3 style="margin-bottom: 10px;">üìã Excel-Funktionen: Was wird unterst√ºtzt?</h3>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong style="color: var(--success);">‚úÖ Vollst√§ndig unterst√ºtzt:</strong><br>
                    ‚Ä¢ Zellwerte, Formatierungen (Schrift, Farben, Ausrichtung)<br>
                    ‚Ä¢ Formeln, Hyperlinks, Rich Text<br>
                    ‚Ä¢ Verbundene Zellen (Merged Cells)<br>
                    ‚Ä¢ Dropdown-Listen (Data Validation)<br>
                    ‚Ä¢ Passwortgesch√ºtzte Dateien<br>
                    ‚Ä¢ Ausgeblendete Zeilen und Spalten<br>
                    ‚Ä¢ AutoFilter (bleibt beim Speichern erhalten)
                </p>
                <p style="color: var(--text-muted); line-height: 1.6; margin-bottom: 10px;">
                    <strong style="color: var(--warning);">‚ö†Ô∏è Bedingte Formatierung:</strong><br>
                    Bedingte Formatierung kann in der App <strong>nicht angezeigt oder bearbeitet</strong> werden.<br>
                    Sie bleibt jedoch beim Laden und Speichern <strong>vollst√§ndig erhalten</strong>.
                </p>
                <p style="color: var(--text-muted); line-height: 1.6;">
                    <strong style="color: var(--error);">‚ùå Pivot-Tabellen:</strong><br>
                    Pivot-Tabellen werden <strong>nicht unterst√ºtzt</strong> und k√∂nnen beim Speichern besch√§digt werden.<br>
                    Bei Dateien mit Pivot-Tabellen erscheint eine Warnung vor dem Speichern.
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="btnCloseHelp">Schlie√üen</button>
            </div>
        </div>
    </div>
    
    <!-- License Modal -->
    <div class="modal-overlay hidden" id="licenseModal">
        <div class="modal" style="max-width: 900px;">
            <div class="modal-header">
                <div class="modal-title">üìú <span data-i18n="licenseTitle">Lizenzinformationen</span></div>
                <button class="modal-close" id="btnCloseLicenseModal">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <!-- Excel Data Sync Pro License -->
                <h3 style="margin-bottom: 10px;">üõ°Ô∏è Excel Data Sync Pro Lizenz</h3>
                <div style="background: var(--bg-lighter); padding: 15px; border-radius: 6px; margin-bottom: 20px; font-family: monospace; font-size: 12px; line-height: 1.6;">
                    <strong>MIT License</strong><br><br>
                    Copyright (c) 2025 Norbert Jander<br><br>
                    Permission is hereby granted, free of charge, to any person obtaining a copy
                    of this software and associated documentation files (the "Software"), to deal
                    in the Software without restriction, including without limitation the rights
                    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                    copies of the Software, and to permit persons to whom the Software is
                    furnished to do so, subject to the following conditions:<br><br>
                    The above copyright notice and this permission notice shall be included in all
                    copies or substantial portions of the Software.<br><br>
                    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                    SOFTWARE.
                </div>
                
                <!-- German Explanation -->
                <h3 style="margin-bottom: 10px;">üá©üá™ Was bedeutet die MIT-Lizenz? (Deutsch)</h3>
                <div style="color: var(--text-muted); line-height: 1.6; margin-bottom: 20px; padding: 15px; background: var(--bg-light); border-radius: 6px; border-left: 4px solid var(--primary);">
                    <p style="margin-bottom: 10px;"><strong>Die MIT-Lizenz ist eine der freiz√ºgigsten Open-Source-Lizenzen.</strong></p>
                    <p style="margin-bottom: 10px;">Sie d√ºrfen diese Software:</p>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>‚úÖ <strong>Nutzen</strong> ‚Äì f√ºr private und kommerzielle Zwecke</li>
                        <li>‚úÖ <strong>Kopieren</strong> ‚Äì beliebig viele Kopien erstellen</li>
                        <li>‚úÖ <strong>Modifizieren</strong> ‚Äì den Quellcode anpassen</li>
                        <li>‚úÖ <strong>Verbreiten</strong> ‚Äì weitergeben oder ver√∂ffentlichen</li>
                        <li>‚úÖ <strong>Verkaufen</strong> ‚Äì auch kommerzielle Nutzung ist erlaubt</li>
                    </ul>
                    <p style="margin-bottom: 10px;"><strong>Einzige Bedingung:</strong> Der Urheberrechtshinweis und der Lizenztext m√ºssen in allen Kopien enthalten sein.</p>
                    <p><strong>‚ö†Ô∏è Haftungsausschluss:</strong> Die Software wird "wie sie ist" bereitgestellt, ohne jegliche Garantie.</p>
                </div>
                
                <!-- English Explanation -->
                <h3 style="margin-bottom: 10px;">üá¨üáß What does the MIT License mean? (English)</h3>
                <div style="color: var(--text-muted); line-height: 1.6; margin-bottom: 20px; padding: 15px; background: var(--bg-light); border-radius: 6px; border-left: 4px solid var(--primary);">
                    <p style="margin-bottom: 10px;"><strong>The MIT License is one of the most permissive open-source licenses.</strong></p>
                    <p style="margin-bottom: 10px;">You are allowed to:</p>
                    <ul style="margin-left: 20px; margin-bottom: 10px;">
                        <li>‚úÖ <strong>Use</strong> ‚Äì for private and commercial purposes</li>
                        <li>‚úÖ <strong>Copy</strong> ‚Äì create as many copies as you want</li>
                        <li>‚úÖ <strong>Modify</strong> ‚Äì adapt the source code</li>
                        <li>‚úÖ <strong>Distribute</strong> ‚Äì share or publish it</li>
                        <li>‚úÖ <strong>Sell</strong> ‚Äì commercial use is allowed</li>
                    </ul>
                    <p style="margin-bottom: 10px;"><strong>Only requirement:</strong> The copyright notice and license text must be included in all copies.</p>
                    <p><strong>‚ö†Ô∏è Disclaimer:</strong> The software is provided "as is", without warranty of any kind.</p>
                </div>
                
                <!-- Third Party Licenses -->
                <h3 style="margin-bottom: 10px;">üì¶ <span data-i18n="thirdPartyLicenses">Drittanbieter-Lizenzen</span></h3>
                <p style="color: var(--text-muted); margin-bottom: 15px;" data-i18n="thirdPartyDesc">Excel Data Sync Pro verwendet folgende Open-Source-Bibliotheken:</p>
                
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- Electron -->
                    <div style="background: var(--bg-light); padding: 12px; border-radius: 6px; border: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong style="color: var(--text-primary);">‚ö° Electron</strong>
                            <span style="background: var(--success); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">MIT</span>
                        </div>
                        <p style="color: var(--text-muted); font-size: 12px; margin-top: 5px;">Cross-platform desktop app framework</p>
                        <a href="https://www.electronjs.org/" style="color: var(--primary-light); font-size: 12px;">electronjs.org</a>
                    </div>
                    
                    <!-- xlsx-populate -->
                    <div style="background: var(--bg-light); padding: 12px; border-radius: 6px; border: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong style="color: var(--text-primary);">üìä xlsx-populate</strong>
                            <span style="background: var(--success); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">MIT</span>
                        </div>
                        <p style="color: var(--text-muted); font-size: 12px; margin-top: 5px;">Excel XLSX manipulation with formatting preservation</p>
                        <a href="https://github.com/dtjohnson/xlsx-populate" style="color: var(--primary-light); font-size: 12px;">github.com/dtjohnson/xlsx-populate</a>
                    </div>
                    
                    <!-- electron-builder -->
                    <div style="background: var(--bg-light); padding: 12px; border-radius: 6px; border: 1px solid var(--border);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong style="color: var(--text-primary);">üì¶ electron-builder</strong>
                            <span style="background: var(--success); color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;">MIT</span>
                        </div>
                        <p style="color: var(--text-muted); font-size: 12px; margin-top: 5px;">Build and publish Electron apps</p>
                        <a href="https://www.electron.build/" style="color: var(--primary-light); font-size: 12px;">electron.build</a>
                    </div>
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: var(--bg-lighter); border-radius: 6px; text-align: center;">
                    <p style="color: var(--text-muted); font-size: 13px;" data-i18n="allLicensesMIT">
                        Alle verwendeten Bibliotheken sind unter der MIT-Lizenz oder kompatiblen Open-Source-Lizenzen lizenziert.
                    </p>
                    <p style="color: var(--text-muted); font-size: 12px; margin-top: 8px;">
                        <strong>387</strong> <span data-i18n="packagesTotal">Pakete gesamt</span> ¬∑ 
                        <strong>MIT:</strong> 287 ¬∑ 
                        <strong>ISC:</strong> 62 ¬∑ 
                        <strong>Apache-2.0:</strong> 10 ¬∑ 
                        <strong>BSD:</strong> 13
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" id="btnCloseLicense" data-i18n="close">Schlie√üen</button>
            </div>
        </div>
    </div>
    
    <!-- Security Logs Modal -->
    <div class="modal-overlay hidden" id="securityLogsModal">
        <div class="modal" style="max-width: 1100px; width: 95vw;">
            <div class="modal-header">
                <div class="modal-title">üìã <span data-i18n="logsTitle">Protokolle</span></div>
                <button class="modal-close" id="btnCloseSecurityLogsModal">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 70vh; overflow-y: auto;">
                <!-- Tab-Umschalter -->
                <div style="display: flex; gap: 0; margin-bottom: 15px; border-bottom: 2px solid var(--border);">
                    <button class="btn" id="tabLocalLogs" style="padding: 10px 20px; border-radius: 6px 6px 0 0; border: 2px solid var(--primary); border-bottom: none; background: var(--primary); color: white; font-weight: bold; margin-bottom: -2px;">
                        üîí <span data-i18n="localLogs">Lokale Security-Logs</span>
                    </button>
                    <button class="btn" id="tabNetworkLogs" style="padding: 10px 20px; border-radius: 6px 6px 0 0; border: 2px solid var(--border); border-bottom: none; background: var(--bg-light); color: var(--text); margin-bottom: -2px; margin-left: -2px;">
                        üåê <span data-i18n="networkLogs">Netzwerk-Logs</span>
                    </button>
                </div>
                
                <!-- LOKALE LOGS SECTION -->
                <div id="localLogsSection">
                    <!-- Integrit√§tsstatus -->
                    <div id="securityLogsIntegrity" style="margin-bottom: 15px; padding: 12px; border-radius: 6px; border-left: 4px solid var(--success); background: var(--bg-light);">
                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                            <div>
                                <strong>üõ°Ô∏è <span data-i18n="integrityStatus">Integrit√§tsstatus:</span></strong>
                                <span id="securityLogsStatus" style="margin-left: 10px;">Wird gepr√ºft...</span>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-secondary" id="btnRefreshLogs" style="padding: 5px 10px; font-size: 12px;">
                                    üîÑ <span data-i18n="refresh">Aktualisieren</span>
                                </button>
                                <button class="btn btn-secondary" id="btnVerifyLogs" style="padding: 5px 10px; font-size: 12px;">
                                    ‚úì <span data-i18n="verify">Verifizieren</span>
                                </button>
                            </div>
                        </div>
                        <div id="securityLogsInfo" style="margin-top: 8px; font-size: 12px; color: var(--text-muted);">
                            Eintr√§ge: <span id="logsCount">0</span> | Pfad: <span id="logsPath">-</span>
                        </div>
                    </div>
                
                <!-- Filter -->
                <div style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                    <label style="font-size: 13px;">Filter:</label>
                    <select id="logsLevelFilter" class="config-select" style="width: auto; padding: 5px 10px;">
                        <option value="">Alle Levels</option>
                        <option value="INFO">‚ÑπÔ∏è INFO</option>
                        <option value="WARN">‚ö†Ô∏è WARN</option>
                        <option value="ERROR">‚ùå ERROR</option>
                        <option value="SECURITY">üõ°Ô∏è SECURITY</option>
                    </select>
                    <input type="text" id="logsSearchFilter" class="config-input" placeholder="Aktion suchen..." style="width: 200px; padding: 5px 10px;">
                </div>
                
                <!-- Log-Tabelle -->
                <div style="overflow-x: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                        <thead>
                            <tr style="background: var(--bg-lighter);">
                                <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--border); white-space: nowrap;">Zeitstempel</th>
                                <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--border); width: 80px;">Level</th>
                                <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--border);">Aktion</th>
                                <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--border);">Details</th>
                                <th style="padding: 10px; text-align: center; border-bottom: 2px solid var(--border); width: 60px;">‚úì</th>
                            </tr>
                        </thead>
                        <tbody id="securityLogsTableBody">
                            <tr><td colspan="5" style="padding: 20px; text-align: center; color: var(--text-muted);">Lade Logs...</td></tr>
                        </tbody>
                    </table>
                </div>
                
                    <!-- Verifikationsfehler (falls vorhanden) -->
                    <div id="securityLogsErrors" class="hidden" style="margin-top: 15px; padding: 12px; background: rgba(244, 67, 54, 0.1); border: 1px solid var(--error); border-radius: 6px;">
                        <strong style="color: var(--error);">‚ö†Ô∏è Integrit√§tsfehler gefunden:</strong>
                        <ul id="securityLogsErrorList" style="margin: 10px 0 0 20px; color: var(--error); font-size: 12px;"></ul>
                    </div>
                </div>
                
                <!-- NETZWERK LOGS SECTION -->
                <div id="networkLogsSection" class="hidden">
                    <!-- Netzwerk-Info -->
                    <div id="networkLogsInfo" style="margin-bottom: 15px; padding: 12px; border-radius: 6px; border-left: 4px solid var(--primary); background: var(--bg-light);">
                        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                            <div>
                                <strong>üñ•Ô∏è <span data-i18n="currentComputer">Aktueller Rechner:</span></strong>
                                <span id="networkHostname" style="margin-left: 10px; font-family: monospace;">-</span>
                            </div>
                            <button class="btn btn-secondary" id="btnRefreshNetworkLogs" style="padding: 5px 10px; font-size: 12px;">
                                üîÑ <span data-i18n="refresh">Aktualisieren</span>
                            </button>
                        </div>
                        <div style="margin-top: 8px; font-size: 12px; color: var(--text-muted);">
                            <span data-i18n="networkLogPath">Log-Pfad:</span> <span id="networkLogsPath" style="font-family: monospace;">-</span><br>
                            <span data-i18n="entries">Eintr√§ge:</span> <span id="networkLogsCount">0</span>
                        </div>
                    </div>
                    
                    <!-- Filter -->
                    <div style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                        <label style="font-size: 13px;">Filter:</label>
                        <select id="networkLogsHostFilter" class="config-select" style="width: auto; padding: 5px 10px;">
                            <option value=""><span data-i18n="allComputers">Alle Rechner</span></option>
                        </select>
                        <input type="text" id="networkLogsSearchFilter" class="config-input" placeholder="Aktion suchen..." style="width: 200px; padding: 5px 10px;">
                    </div>
                    
                    <!-- Log-Tabelle -->
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                            <thead>
                                <tr style="background: var(--bg-lighter);">
                                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--border); white-space: nowrap;"><span data-i18n="timestamp">Zeitstempel</span></th>
                                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--border); white-space: nowrap;">üñ•Ô∏è <span data-i18n="computer">Rechner</span></th>
                                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--border);"><span data-i18n="action">Aktion</span></th>
                                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--border);"><span data-i18n="file">Datei</span></th>
                                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid var(--border);"><span data-i18n="details">Details</span></th>
                                </tr>
                            </thead>
                            <tbody id="networkLogsTableBody">
                                <tr><td colspan="5" style="padding: 20px; text-align: center; color: var(--text-muted);" data-i18n="noNetworkLogs">Keine Netzwerk-Logs vorhanden</td></tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Hinweis -->
                    <div style="margin-top: 15px; padding: 10px; background: var(--bg-lighter); border-radius: 6px; font-size: 12px; color: var(--text-muted);">
                        <strong>‚ÑπÔ∏è Hinweis:</strong> <span data-i18n="networkLogsNote">Das Netzwerk-Protokoll wird nur f√ºr Dateien auf Netzlaufwerken gef√ºhrt. Es zeigt welcher Rechner wann welche Aktion durchgef√ºhrt hat (DSGVO-konform, keine pers√∂nlichen Daten).</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; justify-content: space-between;">
                <button class="btn btn-secondary" id="btnClearLogs" style="background: var(--error);">
                    üóëÔ∏è <span data-i18n="clearLogs">Logs l√∂schen</span>
                </button>
                <button class="btn btn-primary" id="btnCloseSecurityLogs" data-i18n="close">Schlie√üen</button>
            </div>
        </div>
    </div>

    <!-- Transfer Preview / Diff Modal -->
    <div class="modal-overlay hidden" id="diffPreviewModal">
        <div class="modal" style="max-width: 1000px; width: 90vw; max-height: 85vh;">
            <div class="modal-header">
                <div class="modal-title">üëÅÔ∏è Vorschau: <span id="diffPreviewCount">0</span> Zeile(n) werden √ºbertragen</div>
                <button class="modal-close" id="btnCloseDiffModal">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 60vh; overflow-y: auto; padding: 15px;">
                <div id="diffPreviewInfo" style="margin-bottom: 15px; padding: 12px; background: var(--bg-light); border-radius: 6px; border-left: 4px solid var(--primary);">
                    <strong>Zieldatei:</strong> <span id="diffTargetFile">-</span><br>
                    <strong>Arbeitsblatt:</strong> <span id="diffTargetSheet">-</span><br>
                    <strong>Neue Zeilen ab Zeile:</strong> <span id="diffTargetRow">-</span>
                </div>
                
                <div style="margin-bottom: 10px; display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="display: inline-block; width: 16px; height: 16px; background: rgba(76, 175, 80, 0.3); border: 1px solid #4CAF50; border-radius: 3px;"></span>
                        <span style="font-size: 13px;">Neue Zeile</span>
                    </span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="display: inline-block; width: 16px; height: 16px; background: rgba(244, 67, 54, 0.3); border: 1px solid #F44336; border-radius: 3px;"></span>
                        <span style="font-size: 13px;">Delete-Flag</span>
                    </span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="display: inline-block; width: 16px; height: 16px; background: rgba(255, 152, 0, 0.3); border: 1px solid #FF9800; border-radius: 3px;"></span>
                        <span style="font-size: 13px;">Change-Flag</span>
                    </span>
                </div>
                
                <div id="diffPreviewTable" style="overflow-x: auto;">
                    <!-- Wird dynamisch gef√ºllt -->
                </div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="btn btn-secondary" id="btnCancelDiff">Abbrechen</button>
                <button class="btn btn-success" id="btnConfirmTransfer">‚úÖ Jetzt √ºbertragen</button>
            </div>
        </div>
    </div>

    <!-- Column Context Menu for Data Explorer -->
    <div id="columnContextMenu" class="context-menu hidden" style="display: none; position: fixed; z-index: 10000; background: var(--bg-medium); border: 1px solid var(--border); border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); min-width: 180px; padding: 4px 0;">
        <div class="context-menu-header" style="padding: 8px 12px; font-weight: bold; color: var(--text-muted); font-size: 12px; border-bottom: 1px solid var(--border);">
            Spalte: <span id="contextMenuColumnName">-</span>
        </div>
        <div class="context-menu-item" data-action="sort-alpha-asc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üî§</span> Alphabetisch A ‚Üí Z
        </div>
        <div class="context-menu-item" data-action="sort-alpha-desc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üî§</span> Alphabetisch Z ‚Üí A
        </div>
        <div class="context-menu-divider" style="height: 1px; background: var(--border); margin: 4px 0;"></div>
        <div class="context-menu-item" data-action="sort-num-asc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üî¢</span> Numerisch 1 ‚Üí 9
        </div>
        <div class="context-menu-item" data-action="sort-num-desc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üî¢</span> Numerisch 9 ‚Üí 1
        </div>
        <div class="context-menu-divider" style="height: 1px; background: var(--border); margin: 4px 0;"></div>
        <div class="context-menu-item" data-action="sort-date-asc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üìÖ</span> Datum Alt ‚Üí Neu
        </div>
        <div class="context-menu-item" data-action="sort-date-desc" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üìÖ</span> Datum Neu ‚Üí Alt
        </div>
        <div class="context-menu-divider" style="height: 1px; background: var(--border); margin: 4px 0;"></div>
        <div class="context-menu-item" data-action="filter-date-soon" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>‚è∞</span> F√§llig in X Tagen...
        </div>
        <div class="context-menu-item" data-action="filter-date-overdue" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>‚ö†Ô∏è</span> √úberf√§llig seit X Tagen...
        </div>
        <div class="context-menu-divider" style="height: 1px; background: var(--border); margin: 4px 0;"></div>
        <div class="context-menu-item" data-action="hide-column" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>üëÅÔ∏è‚Äçüó®Ô∏è</span> Spalte ausblenden
        </div>
        <div class="context-menu-item" data-action="delete-column" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px; color: #F44336;">
            <span>üóëÔ∏è</span> Spalte l√∂schen
        </div>
        <div class="context-menu-divider" style="height: 1px; background: var(--border); margin: 4px 0;"></div>
        <div class="context-menu-item" data-action="insert-column-before" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>‚¨ÖÔ∏è</span> Spalte links einf√ºgen
        </div>
        <div class="context-menu-item" data-action="insert-column-after" style="padding: 8px 12px; cursor: pointer; display: flex; align-items: center; gap: 8px;">
            <span>‚û°Ô∏è</span> Spalte rechts einf√ºgen
        </div>
    </div>

    <!-- Data Explorer Modal -->
    <div class="modal-overlay hidden" id="dataExplorerModal">
        <div class="modal modal-large" style="max-width: 95vw; width: 1400px; max-height: 90vh; min-width: 600px; min-height: 400px;">
            <div class="modal-header">
                <div class="modal-title">üìä Datenexplorer - <span id="explorerFileName">Keine Datei geladen</span></div>
                <div style="display: flex; align-items: center;">
                    <button class="modal-fullscreen-btn" id="btnExplorerFullscreen" title="Vollbild umschalten (F11)">‚õ∂</button>
                    <button class="modal-close" id="btnCloseExplorerX">&times;</button>
                </div>
            </div>
            <div class="modal-body" style="display: flex; flex-direction: column; gap: 15px; padding: 15px; overflow-y: auto; flex: 1; min-height: 0;">
                <!-- Explorer Controls -->
                <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end; flex-shrink: 0;">
                    <button class="btn btn-primary" id="btnExplorerOpenFile">
                        üìÇ Datei √∂ffnen
                    </button>
                    <div class="transfer-field">
                        <label>Arbeitsblatt:</label>
                        <div style="display: flex; gap: 4px; align-items: center;">
                            <select id="explorerSheetSelect" class="config-select" style="min-width: 180px;">
                                <option value="">-- Datei laden --</option>
                            </select>
                            <button class="btn btn-sm" id="btnSheetManage" title="Arbeitsbl√§tter verwalten" style="padding: 4px 8px; font-size: 14px;">
                                üìã
                            </button>
                        </div>
                    </div>
                    <div class="transfer-field" style="flex: 1;">
                        <label>Volltextsuche:</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="explorerSearch" class="config-input" placeholder="Suchbegriff eingeben..." style="flex: 1; min-width: 200px;">
                            <button class="btn btn-primary btn-sm" id="btnExplorerSearch" title="Suche starten (Enter)">üîç</button>
                        </div>
                    </div>
                    <button class="btn btn-info btn-sm" id="btnToggleFindReplace" title="Suchen & Ersetzen (Strg+H)" data-i18n="findReplace" data-i18n-title="findReplaceTitle">
                        üîÑ Ersetzen
                    </button>
                    <button class="btn btn-primary" id="btnToggleColumns" title="Spalten ein-/ausblenden">
                        ‚ùô‚ùô Spalten
                    </button>
                    <button class="btn btn-primary" id="btnExplorerPreview" title="Vorschau des gesamten Datenblattes mit √Ñnderungen" disabled>
                        üëÅÔ∏è Vorschau
                    </button>
                    <button class="btn btn-info" id="btnDataJoin" title="Spalten aus einer anderen Excel-Datei hinzuf√ºgen (basierend auf gemeinsamer Seriennummer)" disabled data-i18n="addColumns" data-i18n-title="addColumnsTitle">
                        üîó Spalten hinzuf√ºgen
                    </button>
                    <button class="btn btn-success" id="btnExplorerExport" title="√Ñnderungen speichern oder als neue Datei exportieren">
                        üíæ Speichern
                    </button>
                </div>
                
                <!-- Filter Controls -->
                <div id="explorerFilterControls" style="display: flex; flex-direction: column; gap: 10px; padding: 12px; background: var(--bg-light); border-radius: 6px; border: 1px solid var(--border); flex-shrink: 0;">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <span style="font-weight: 600; font-size: 14px;">üîç Filter</span>
                        <button class="btn btn-primary btn-sm" id="btnAddExplorerFilter">‚ûï Filter hinzuf√ºgen</button>
                        <button class="btn btn-secondary btn-sm" id="btnClearExplorerFilters" disabled>üóëÔ∏è Filter zur√ºcksetzen</button>
                        <!-- Indikatoren-Bereich (rechts) -->
                        <div id="filterIndicatorsContainer" style="display: flex; gap: 8px; margin-left: auto; align-items: center;">
                            <!-- AutoFilter Indikator -->
                            <span id="autoFilterIndicator" style="display: none; background: #2196F3; color: white; font-size: 12px; padding: 4px 10px; border-radius: 4px; align-items: center; gap: 6px; cursor: help; font-weight: 500;">
                                ‚ñº AutoFilter
                            </span>
                            <!-- Container f√ºr Hidden-Indikatoren (Zeilen/Spalten) -->
                            <div id="hiddenIndicatorsContainer" style="display: flex; gap: 4px;"></div>
                        </div>
                    </div>
                    <div id="explorerFilters" style="display: flex; flex-direction: column; gap: 8px;"></div>
                </div>
                
                <!-- Find & Replace Panel (initially hidden) -->
                <div id="findReplacePanel" style="display: none; flex-direction: column; gap: 12px; padding: 15px; background: linear-gradient(135deg, #2d2d30 0%, #252526 100%); border-radius: 6px; border: 1px solid var(--border); border-left: 4px solid #9c27b0; flex-shrink: 0;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-weight: 600; color: #9c27b0;">üîÑ Suchen & Ersetzen</span>
                        <span id="findMatchCounter" style="color: var(--text-muted); font-size: 12px; font-weight: 500;"></span>
                        <span id="findReplaceInfo" style="color: var(--text-muted); font-size: 12px;"></span>
                        <button class="btn btn-secondary btn-sm" id="btnCloseFindReplace" style="margin-left: auto;">‚úï</button>
                    </div>
                    <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end;">
                        <div class="transfer-field" style="flex: 1; min-width: 200px;">
                            <label style="font-size: 12px;">Suchen nach:</label>
                            <input type="text" id="findText" class="config-input" placeholder="Text zum Suchen...">
                        </div>
                        <div class="transfer-field" style="flex: 1; min-width: 200px;">
                            <label style="font-size: 12px;">Ersetzen durch:</label>
                            <input type="text" id="replaceText" class="config-input" placeholder="Ersatztext...">
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;">
                                <input type="checkbox" id="findCaseSensitive" class="green-checkbox">
                                <span>Gro√ü/Klein</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;">
                                <input type="checkbox" id="findWholeWord" class="green-checkbox">
                                <span>Ganzes Wort</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 4px; font-size: 12px; cursor: pointer;">
                                <input type="checkbox" id="findRegex" class="green-checkbox">
                                <span>Regex</span>
                            </label>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="btn btn-primary btn-sm" id="btnFindNext" title="N√§chsten Treffer finden (F3)">üîç Weiter</button>
                            <button class="btn btn-warning btn-sm" id="btnReplaceOne" title="Aktuelle Auswahl ersetzen">Ersetzen</button>
                            <button class="btn btn-info btn-sm" id="btnReplaceAll" title="Alle Vorkommen ersetzen">Alle ersetzen</button>
                            <button class="btn btn-secondary btn-sm" id="btnFindReplaceUndo" title="Letzte Ersetzung r√ºckg√§ngig machen (Strg+Z)">‚Ü©Ô∏è R√ºckg√§ngig</button>
                        </div>
                    </div>
                </div>
                
                <!-- Column Visibility Panel (initially hidden) -->
                <div id="columnTogglePanel" style="display: none; flex-direction: column; gap: 10px; padding: 15px; background: var(--bg-light); border-radius: 6px; margin-bottom: 10px; border: 1px solid var(--border); flex-shrink: 0;">
                    <div style="display: flex; gap: 10px; margin-bottom: 5px;">
                        <button class="btn btn-secondary btn-sm" id="btnShowAllColumns">Alle anzeigen</button>
                        <button class="btn btn-secondary btn-sm" id="btnHideAllColumns">Alle ausblenden</button>
                    </div>
                    <div id="columnToggles" style="display: flex; flex-wrap: wrap; gap: 8px; max-height: 200px; overflow-y: auto;"></div>
                </div>
                
                <!-- Row Move Toolbar (initially hidden) -->
                <div id="rowMoveToolbar" style="display: none; gap: 10px; padding: 12px; background: linear-gradient(135deg, #217346 0%, #1a5c38 100%); border-radius: 6px; align-items: center; flex-wrap: wrap; flex-shrink: 0;">
                    <span style="color: white; font-weight: 600;">üîÄ <span id="selectedRowCount">0</span> Zeile(n) ausgew√§hlt</span>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <span style="color: white;">Verschieben:</span>
                        <select id="movePosition" class="config-select" style="min-width: 80px; padding: 4px 8px;">
                            <option value="before">Vor</option>
                            <option value="after">Nach</option>
                        </select>
                        <span style="color: white;">Zeile</span>
                        <input type="number" id="moveTargetRow" class="config-input" style="width: 80px; padding: 4px 8px;" min="1" placeholder="Nr.">
                        <button class="btn btn-sm" id="btnExecuteMove" style="background: white; color: #217346; font-weight: 600;">‚úì Verschieben</button>
                        <button class="btn btn-sm" id="btnHideSelectedRows" style="background: #FF9800; color: white; font-weight: 600; margin-left: 15px;">üëÅÔ∏è‚Äçüó®Ô∏è Ausblenden</button>
                        <button class="btn btn-sm" id="btnDeleteSelectedRows" style="background: #F44336; color: white; font-weight: 600;">üóëÔ∏è L√∂schen</button>
                    </div>
                    <button class="btn btn-sm" id="btnClearRowSelection" style="background: rgba(255,255,255,0.2); color: white; margin-left: auto;">‚úï Auswahl aufheben</button>
                </div>
                
                <!-- Results Info -->
                <div style="display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; flex-wrap: wrap; gap: 10px;">
                    <span id="explorerResultCount" style="color: var(--text-muted);">Keine Daten geladen.</span>
                    
                    <!-- Pagination Controls -->
                    <div id="explorerPagination" style="display: none; align-items: center; gap: 8px;">
                        <button class="btn btn-secondary btn-sm" id="btnExplorerFirstPage" title="Erste Seite">‚èÆ</button>
                        <button class="btn btn-secondary btn-sm" id="btnExplorerPrevPage" title="Vorherige Seite">‚óÄ</button>
                        <span id="explorerPageInfo" style="color: var(--text-muted); font-size: 13px; min-width: 120px; text-align: center;">Seite 1 von 1</span>
                        <button class="btn btn-secondary btn-sm" id="btnExplorerNextPage" title="N√§chste Seite">‚ñ∂</button>
                        <button class="btn btn-secondary btn-sm" id="btnExplorerLastPage" title="Letzte Seite">‚è≠</button>
                        <select id="explorerPageSize" style="padding: 4px 8px; border-radius: 4px; background: var(--bg-light); border: 1px solid var(--border); color: var(--text-primary);">
                            <option value="50">50 / Seite</option>
                            <option value="100" selected>100 / Seite</option>
                            <option value="250">250 / Seite</option>
                            <option value="500">500 / Seite</option>
                            <option value="1000">1000 / Seite</option>
                        </select>
                    </div>
                    
                    <span id="explorerStatus" style="color: #ff9800; font-size: 12px;"></span>
                </div>
                
                <!-- Table Container -->
                <div id="explorerTableContainer" style="flex: 1; min-height: 200px; overflow: auto; background: var(--bg-dark); border-radius: 6px; border: 1px solid var(--border); position: relative;">
                    <!-- Large Drop Zone (visible when no file loaded) -->
                    <div id="explorerDropZone" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 8px; cursor: pointer; transition: all 0.2s ease; z-index: 10;">
                        <div style="font-size: 48px; opacity: 0.5;">üì•</div>
                        <div style="font-size: 16px; color: var(--text-muted); font-weight: 500;">Excel-Datei hier ablegen</div>
                        <div style="font-size: 12px; color: var(--text-muted); opacity: 0.7;">oder klicken zum √ñffnen</div>
                        <div style="margin-top: 5px; padding: 5px 14px; border: 1px dashed var(--border); border-radius: 6px; color: var(--text-muted); font-size: 11px;">
                            .xlsx, .xls
                        </div>
                    </div>
                    <table class="results-table" id="explorerTable">
                        <thead id="explorerTableHead"></thead>
                        <tbody id="explorerTableBody">
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="btnCloseExplorerFooter">Schlie√üen</button>
            </div>
        </div>
    </div>
    
    <!-- Sheet Management Modal -->
    <div class="modal-overlay hidden" id="sheetManageModal">
        <div class="modal" style="max-width: 600px; width: 90vw;">
            <div class="modal-header">
                <div class="modal-title">üìã Arbeitsbl√§tter verwalten</div>
                <button class="modal-close" id="btnCloseSheetManage">&times;</button>
            </div>
            <div class="modal-body" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                <!-- Sheet-Liste -->
                <div>
                    <label style="font-weight: bold; margin-bottom: 8px; display: block;">Arbeitsbl√§tter:</label>
                    <div id="sheetManageList" style="border: 1px solid var(--border); border-radius: 6px; max-height: 300px; overflow-y: auto;">
                        <!-- Dynamisch gef√ºllt -->
                    </div>
                </div>
                
                <!-- Aktionen -->
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn btn-success btn-sm" id="btnSheetAdd" title="Neues Arbeitsblatt hinzuf√ºgen">
                        ‚ûï Hinzuf√ºgen
                    </button>
                    <button class="btn btn-info btn-sm" id="btnSheetRename" title="Ausgew√§hltes Arbeitsblatt umbenennen" disabled>
                        ‚úèÔ∏è Umbenennen
                    </button>
                    <button class="btn btn-primary btn-sm" id="btnSheetClone" title="Ausgew√§hltes Arbeitsblatt kopieren" disabled>
                        üìë Kopieren
                    </button>
                    <button class="btn btn-warning btn-sm" id="btnSheetMoveUp" title="Nach oben verschieben" disabled>
                        ‚¨ÜÔ∏è Hoch
                    </button>
                    <button class="btn btn-warning btn-sm" id="btnSheetMoveDown" title="Nach unten verschieben" disabled>
                        ‚¨áÔ∏è Runter
                    </button>
                    <button class="btn btn-danger btn-sm" id="btnSheetDelete" title="Ausgew√§hltes Arbeitsblatt l√∂schen" disabled>
                        üóëÔ∏è L√∂schen
                    </button>
                </div>
                
                <!-- Hinweis -->
                <div style="font-size: 12px; color: var(--text-muted); background: var(--bg-light); padding: 10px; border-radius: 6px;">
                    <strong>Hinweis:</strong> √Ñnderungen werden sofort in der Datei gespeichert.
                </div>
            </div>
            <div class="modal-footer" style="padding: 15px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end;">
                <button class="btn btn-secondary" id="btnSheetManageClose">Schlie√üen</button>
            </div>
        </div>
    </div>
    
    <!-- Explorer Preview Modal -->
    <div class="modal-overlay hidden" id="explorerPreviewModal">
        <div class="modal" style="max-width: 95vw; width: 1600px; max-height: 95vh;">
            <div class="modal-header">
                <div class="modal-title">üëÅÔ∏è Vorschau: <span id="previewFileName">-</span> - <span id="previewSheetName">-</span></div>
                <button class="modal-close" id="btnClosePreviewX">&times;</button>
            </div>
            <div class="modal-body" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; max-height: calc(95vh - 120px); overflow: hidden;">
                <!-- Info -->
                <div style="display: flex; gap: 20px; flex-wrap: wrap; padding: 12px; background: var(--bg-light); border-radius: 6px; border-left: 4px solid var(--primary);">
                    <div>
                        <strong>Zeilen:</strong> <span id="previewRowCount">0</span>
                    </div>
                    <div>
                        <strong>Spalten:</strong> <span id="previewColCount">0</span>
                    </div>
                    <div>
                        <strong>Bearbeitete Zellen:</strong> <span id="previewEditCount" style="color: var(--warning);">0</span>
                    </div>
                </div>
                
                <!-- Legende -->
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <span style="font-weight: 600;">Legende:</span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="display: inline-block; width: 20px; height: 20px; background: rgba(255, 193, 7, 0.3); border: 2px solid #FFC107; border-radius: 3px;"></span>
                        <span style="font-size: 13px;">Bearbeitete Zelle</span>
                    </span>
                    <span style="display: flex; align-items: center; gap: 6px;">
                        <span style="display: inline-block; width: 20px; height: 20px; background: var(--bg-light); border: 1px solid var(--border); border-radius: 3px;"></span>
                        <span style="font-size: 13px;">Unver√§ndert</span>
                    </span>
                </div>
                
                <!-- Tabellen-Container -->
                <div id="previewTableContainer" style="flex: 1; overflow: auto; background: var(--bg-dark); border-radius: 6px; border: 1px solid var(--border);">
                    <!-- Wird dynamisch gef√ºllt -->
                </div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="btn btn-secondary" id="btnClosePreview">Schlie√üen</button>
            </div>
        </div>
    </div>
    
    <!-- Data Join Modal - Spalten aus anderer Datei hinzuf√ºgen -->
    <div class="modal-overlay hidden" id="dataJoinModal">
        <div class="modal modal-large" style="max-width: 900px; width: 90%; max-height: 85vh;">
            <div class="modal-header">
                <div class="modal-title" data-i18n="joinModalTitle">üîó Spalten aus Datei hinzuf√ºgen</div>
                <button class="modal-close" id="btnCloseDataJoin">&times;</button>
            </div>
            <div class="modal-body" style="display: flex; flex-direction: column; gap: 15px; overflow-y: auto;">
                <!-- Info-Box -->
                <div style="padding: 12px; background: linear-gradient(135deg, #2d2d30 0%, #252526 100%); border-radius: 6px; border-left: 4px solid var(--info);">
                    <p style="color: var(--text-muted); font-size: 13px; line-height: 1.5;" data-i18n="joinModalInfo">
                        <strong style="color: var(--text);">üìã Funktion:</strong> F√ºgt Spalten aus einer anderen Excel-Datei hinzu, basierend auf einem gemeinsamen Schl√ºssel (z.B. Seriennummer).
                        Die Zeilen werden automatisch anhand des Schl√ºssels zugeordnet.
                    </p>
                </div>
                
                <!-- Schritt 1: Quelldatei w√§hlen -->
                <div class="config-group">
                    <div class="config-section-title" style="margin-bottom: 10px;" data-i18n="joinStep1">1Ô∏è‚É£ Datenquelle ausw√§hlen</div>
                    <div style="display: flex; gap: 15px; align-items: stretch;">
                        <!-- Button-Bereich -->
                        <div style="display: flex; flex-direction: column; gap: 8px; min-width: 180px;">
                            <button class="btn btn-primary" id="btnJoinSelectFile" data-i18n="joinSelectFile">
                                üìÇ Datei ausw√§hlen
                            </button>
                            <span id="joinSourceFileName" style="color: var(--text-muted); font-size: 12px; word-break: break-all;" data-i18n="joinNoFileSelected">Keine Datei ausgew√§hlt</span>
                        </div>
                        <!-- Drag & Drop Zone -->
                        <div id="joinDropZone" style="flex: 1; min-height: 80px; border: 2px dashed var(--border); border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 5px; cursor: pointer; transition: all 0.2s ease; background: var(--bg-dark);">
                            <span style="font-size: 24px;">üìÅ</span>
                            <span style="color: var(--text-muted); font-size: 12px; text-align: center;" data-i18n="joinDropZoneText">Excel-Datei hierher ziehen</span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                        <label class="config-label" style="margin: 0; min-width: 100px;" data-i18n="joinWorksheet">Arbeitsblatt:</label>
                        <select class="config-select" id="joinSourceSheet" style="flex: 1; max-width: 300px;" disabled>
                            <option value="" data-i18n="joinLoadFile">-- Datei laden --</option>
                        </select>
                    </div>
                </div>
                
                <!-- Schritt 2: Schl√ºsselspalte w√§hlen -->
                <div class="config-group">
                    <div class="config-section-title" style="margin-bottom: 10px;" data-i18n="joinStep2">2Ô∏è‚É£ Schl√ºsselspalte (z.B. Seriennummer)</div>
                    <p style="color: var(--text-muted); font-size: 12px; margin-bottom: 10px;" data-i18n="joinStep2Desc">
                        W√§hlen Sie die Spalte, die in beiden Dateien als gemeinsamer Schl√ºssel dient.
                    </p>
                    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 200px;">
                            <label class="config-label" data-i18n="joinTargetFile">Aktuelle Datei (Ziel):</label>
                            <select class="config-select" id="joinTargetKeyColumn" disabled>
                                <option value="" data-i18n="joinSelectColumn">-- Spalte w√§hlen --</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; color: var(--primary-light); font-size: 20px; padding-top: 20px;">
                            ‚ü∑
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <label class="config-label" data-i18n="joinSourceFile">Quelldatei:</label>
                            <select class="config-select" id="joinSourceKeyColumn" disabled>
                                <option value="" data-i18n="joinSelectColumn">-- Spalte w√§hlen --</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Schritt 3: Spalten zum Hinzuf√ºgen w√§hlen -->
                <div class="config-group">
                    <div class="config-section-title" style="margin-bottom: 10px;" data-i18n="joinStep3">3Ô∏è‚É£ Spalten zum Hinzuf√ºgen ausw√§hlen</div>
                    <p style="color: var(--text-muted); font-size: 12px; margin-bottom: 10px;" data-i18n="joinStep3Desc">
                        W√§hlen Sie die Spalten aus der Quelldatei, die zur aktuellen Datei hinzugef√ºgt werden sollen.
                    </p>
                    <div id="joinColumnsContainer" style="display: flex; flex-direction: column; gap: 8px; max-height: 200px; overflow-y: auto; padding: 10px; background: var(--bg-dark); border-radius: 6px; border: 1px solid var(--border);">
                        <div style="color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px;" data-i18n="joinLoadSourceFirst">
                            Laden Sie zuerst eine Quelldatei
                        </div>
                    </div>
                </div>
                
                <!-- Schritt 4: Optionen -->
                <div class="config-group">
                    <div class="config-section-title" style="margin-bottom: 10px;" data-i18n="joinStep4">4Ô∏è‚É£ Optionen</div>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <div style="padding: 10px; background: var(--bg-dark); border-radius: 4px; color: var(--text-muted); font-size: 12px;">
                            üí° <strong>Tipp:</strong> W√§hlen Sie f√ºr jede Spalte die Zielposition im Dropdown oben.
                            "Am Ende einf√ºgen" f√ºgt die Spalte ans Ende der Tabelle.
                        </div>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="joinMarkNotFound" class="green-checkbox" checked>
                            <span data-i18n="joinMarkNotFoundLabel">Nicht gefundene Zeilen markieren (gelb)</span>
                        </label>
                    </div>
                </div>
                
                <!-- Vorschau / Status -->
                <div id="joinPreviewContainer" class="config-group" style="display: none;">
                    <div class="config-section-title" style="margin-bottom: 10px;" data-i18n="joinPreviewTitle">üìä Vorschau</div>
                    <div id="joinPreviewStats" style="display: flex; gap: 20px; flex-wrap: wrap; padding: 10px; background: var(--bg-dark); border-radius: 6px;">
                        <div><strong data-i18n="joinStatTargetRowsLabel">Zeilen in Ziel:</strong> <span id="joinStatTargetRows">0</span></div>
                        <div><strong data-i18n="joinStatSourceRowsLabel">Zeilen in Quelle:</strong> <span id="joinStatSourceRows">0</span></div>
                        <div><strong data-i18n="joinStatMatchesLabel">Matches gefunden:</strong> <span id="joinStatMatches" style="color: var(--success);">0</span></div>
                        <div><strong data-i18n="joinStatNoMatchLabel">Ohne Match:</strong> <span id="joinStatNoMatch" style="color: var(--warning);">0</span></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="btnCancelDataJoin" data-i18n="cancel">Abbrechen</button>
                <button class="btn btn-primary" id="btnPreviewDataJoin" disabled data-i18n="joinPreviewBtn">
                    üëÅÔ∏è Vorschau berechnen
                </button>
                <button class="btn btn-success" id="btnExecuteDataJoin" disabled data-i18n="joinExecuteBtn">
                    ‚úì Spalten hinzuf√ºgen
                </button>
            </div>
        </div>
    </div>
    
    <!-- Filter Template f√ºr Explorer -->
    <template id="explorerFilterTemplate">
        <div class="explorer-filter-row" style="display: flex; gap: 8px; align-items: center; padding: 6px 8px; background: var(--bg-dark); border-radius: 4px;">
            <select class="filter-column config-select" style="flex: 0 0 auto; max-width: 150px;"></select>
            <select class="filter-operator config-select" style="flex: 0 0 auto; width: auto;">
                <optgroup label="Text">
                    <option value="contains">enth√§lt</option>
                    <option value="equals">ist gleich</option>
                    <option value="startsWith">beginnt mit</option>
                    <option value="endsWith">endet mit</option>
                    <option value="notContains">enth√§lt nicht</option>
                    <option value="isEmpty">ist leer</option>
                    <option value="isNotEmpty">nicht leer</option>
                </optgroup>
                <optgroup label="Datum">
                    <option value="dateInDays">üìÖ in X Tagen</option>
                    <option value="dateOverdueDays">üìÖ X Tage √ºberschritten</option>
                    <option value="dateToday">üìÖ heute</option>
                    <option value="datePast">üìÖ Vergangenheit</option>
                    <option value="dateFuture">üìÖ Zukunft</option>
                    <option value="dateThisWeek">üìÖ diese Woche</option>
                    <option value="dateThisMonth">üìÖ diesen Monat</option>
                </optgroup>
            </select>
            <input type="text" class="filter-value config-input" placeholder="Wert..." style="flex: 1; min-width: 100px;">
            <input type="number" class="filter-days config-input" placeholder="Tage" style="width: 60px; display: none;" min="0">
            <button type="button" class="btn btn-secondary btn-sm remove-filter" style="padding: 2px 8px;">‚úï</button>
        </div>
    </template>

    <script>
        // ============================================
        // ELECTRON-ONLY MODE
        // ============================================
        console.log('üöÄ Electron-Modus aktiv');
        
        // ============================================
        // INTERNATIONALIZATION (i18n)
        // ============================================
        const translations = {
            de: {
                // Header
                appTitle: 'Excel Data Sync Pro',
                loadConfig: 'üìÇ config.json laden',
                saveConfig: 'üíæ config.json speichern',
                help: '‚ùì Hilfe',
                
                // Sidebar
                configuration: 'Konfiguration',
                settings: '‚öôÔ∏è Einstellungen',
                language: 'Sprache',
                theme: 'Design',
                themeDark: 'üåô Dunkel',
                themeLight: '‚òÄÔ∏è Hell',
                
                // Working Directory
                workingDirectory: 'üìÅ Arbeitsordner',
                selectWorkingDir: 'üìÇ Ordner ausw√§hlen',
                noWorkingDirSet: 'Kein Ordner gew√§hlt',
                clearWorkingDir: '‚úñÔ∏è Arbeitsordner l√∂schen',
                workingDirSet: '‚úì ',
                workingDirCleared: 'Arbeitsordner gel√∂scht',
                
                // Files
                file1Source: 'üìÑ Datei 1 (Quelle)',
                file2Target: 'üìÑ Datei 2 (Ziel)',
                loadSourceFile: 'üìÇ Quelldatei laden',
                loadTargetFile: 'üìÇ Zieldatei laden',
                noFileLoaded: 'Keine Datei geladen',
                worksheet: 'Arbeitsblatt:',
                loadFileFirst: '-- Erst Datei laden --',
                
                // Mapping
                columnMapping: 'üîó Spalten-Zuordnung',
                configureColumns: '‚öôÔ∏è Spalten konfigurieren',
                loadBothFiles: 'Laden Sie beide Dateien',
                columnsConfigured: 'Spalte(n) konfiguriert',
                
                // Template
                monthTemplate: 'üìÑ Monats-Template',
                loadTemplate: 'üìÇ Template laden',
                createTemplateFromSource: 'üîß Template aus Quelldatei',
                noTemplateLoaded: 'Kein Template geladen',
                templateHint: 'Leere Excel-Vorlage f√ºr "üìÖ Neue Monatsdatei"',
                createTemplateTitle: 'üîß Template aus Quelldatei erstellen',
                createTemplateDesc: 'Erstellt ein leeres Template mit allen Formatierungen und bedingten Formatierungen aus der Quelldatei.',
                sourceFileLabel: 'Quelldatei:',
                selectSheets: 'Arbeitsbl√§tter ausw√§hlen:',
                loadSourceFirst: 'Laden Sie zuerst eine Quelldatei',
                selectAll: '‚úì Alle ausw√§hlen',
                deselectAll: '‚úó Alle abw√§hlen',
                templateInfoText: 'üí° Die Header-Zeile wird behalten, alle Datenzeilen werden gel√∂scht. CF-Regeln werden auf ganze Spalten erweitert.',
                createAndSave: 'üîß Template erstellen & speichern',
                templateCreated: 'Template erfolgreich erstellt',
                sheetsProcessed: 'Arbeitsbl√§tter verarbeitet',
                cfRulesPreserved: 'CF-Regeln erhalten',
                extraColumnsInTemplate: 'Extra-Spalten im Template erstellen:',
                flagColumn: 'Flag-Spalte (A)',
                commentColumn: 'Kommentar-Spalte (B)',
                extraColumnsHint: 'Aktivieren, wenn in "Spalten konfigurieren" die entsprechenden Optionen genutzt werden.',
                
                // History
                lastTransfers: 'üìã Letzte √úbertragungen',
                noTransfersYet: 'Noch keine √úbertragungen',
                
                // Search
                searchPlaceholder: 'Suche... (Platzhalter: * = beliebig, ? = ein Zeichen)',
                search: 'üîç Suchen',
                newRow: '‚ûï Neue Zeile',
                
                // Results
                readyToStart: 'Bereit zum Starten',
                instructions: '1. Laden Sie die Quelldatei (Datei 1)<br>2. Laden Sie die Zieldatei (Datei 2)<br>3. Konfigurieren Sie die Spalten-Zuordnung<br>4. Suchen Sie nach Zeilen und √ºbertragen Sie diese',
                noResults: 'Keine Treffer f√ºr',
                results: 'Treffer f√ºr',
                
                // Transfer
                prepareTransfer: 'üì§ Zeile(n) zur √úbertragung vorbereiten',
                selected: 'ausgew√§hlt',
                flag: 'Spalte 1 - Flag:',
                comment: 'Spalte 2 - Kommentar:',
                commentPlaceholder: 'Freier Text...',
                addToQueue: '‚ûï Markierte zur Warteschlange',
                transferDirect: '‚û°Ô∏è Markierte direkt √ºbertragen',
                selectAll: '‚úì Alle ausw√§hlen',
                deselectAll: '‚úó Alles abw√§hlen',
                
                // Queue
                queue: 'üìã Warteschlange',
                rows: 'Zeilen',
                clear: 'üóëÔ∏è Leeren',
                preview: 'üëÅÔ∏è Vorschau',
                exportToTarget: 'üì§ Export zur Zieldatei',
                directTransfer: '‚úÖ Direkt √ºbertragen',
                dataExplorer: 'Datenexplorer',
                newMonthFile: 'üìÖ Neue Monatsdatei',
                noRowsInQueue: 'Keine Zeilen in der Warteschlange',
                
                // New Row
                createNewRow: '‚úèÔ∏è Neue Zeile erstellen',
                close: '‚úï Schlie√üen',
                toQueue: '‚ûï Zur Warteschlange',
                transferDirectly: '‚û°Ô∏è Direkt √ºbertragen',
                
                // Messages
                noTargetFile: 'Keine Zieldatei geladen',
                selectAtLeastOne: 'Bitte w√§hlen Sie mindestens eine Zeile aus',
                rowsTransferred: 'Zeile(n) direkt √ºbertragen!',
                rowsAdded: 'Zeile(n) zur Warteschlange hinzugef√ºgt',
                edited: 'bearbeitet',
                duplicates: 'Duplikat(e)',
                configFirst: 'Bitte zuerst Spalten konfigurieren',
                
                // Data Explorer
                explorerTitle: 'Datenexplorer',
                noFileLoadedExplorer: 'Keine Datei geladen',
                openFile: 'üìÇ Datei √∂ffnen',
                fullTextSearch: 'Volltextsuche:',
                searchPlaceholderExplorer: 'Suchbegriff eingeben...',
                columns: '‚ùô‚ùô Spalten',
                exportXlsx: 'üíæ Speichern',
                filter: 'üîç Filter',
                addFilter: '‚ûï Filter hinzuf√ºgen',
                resetFilters: 'üóëÔ∏è Filter zur√ºcksetzen',
                showAll: 'Alle anzeigen',
                hideAll: 'Alle ausblenden',
                noDataLoaded: 'No data loaded.',
                pleaseLoadFile: 'üìÇ Please load an Excel file',
                contains: 'enth√§lt',
                equals: 'gleich',
                startsWith: 'beginnt mit',
                endsWith: 'endet mit',
                selectColumn: 'Spalte w√§hlen',
                filterValue: 'Filterwert',
                findReplace: 'üîÑ Ersetzen',
                findReplaceTitle: 'Suchen & Ersetzen (Strg+H)',
                addColumns: 'üîó Spalten hinzuf√ºgen',
                addColumnsTitle: 'Spalten aus einer anderen Excel-Datei hinzuf√ºgen (basierend auf gemeinsamer Seriennummer)',
                
                // Data Join Modal
                joinModalTitle: 'üîó Spalten aus Datei hinzuf√ºgen',
                joinModalInfo: '<strong style="color: var(--text);">üìã Funktion:</strong> F√ºgt Spalten aus einer anderen Excel-Datei hinzu, basierend auf einem gemeinsamen Schl√ºssel (z.B. Seriennummer). Die Zeilen werden automatisch anhand des Schl√ºssels zugeordnet.',
                joinStep1: '1Ô∏è‚É£ Datenquelle ausw√§hlen',
                joinSelectFile: 'üìÇ Datei ausw√§hlen',
                joinNoFileSelected: 'Keine Datei ausgew√§hlt',
                joinDropZoneText: 'Excel-Datei hierher ziehen',
                joinWorksheet: 'Arbeitsblatt:',
                joinLoadFile: '-- Datei laden --',
                joinStep2: '2Ô∏è‚É£ Schl√ºsselspalte (z.B. Seriennummer)',
                joinStep2Desc: 'W√§hlen Sie die Spalte, die in beiden Dateien als gemeinsamer Schl√ºssel dient.',
                joinTargetFile: 'Aktuelle Datei (Ziel):',
                joinSourceFile: 'Quelldatei:',
                joinSelectColumn: '-- Spalte w√§hlen --',
                joinStep3: '3Ô∏è‚É£ Spalten zum Hinzuf√ºgen ausw√§hlen',
                joinStep3Desc: 'W√§hlen Sie die Spalten aus der Quelldatei, die zur aktuellen Datei hinzugef√ºgt werden sollen.',
                joinLoadSourceFirst: 'Laden Sie zuerst eine Quelldatei',
                joinStep4: '4Ô∏è‚É£ Optionen',
                joinInsertAfterKeyLabel: 'Neue Spalten direkt nach der Schl√ºsselspalte einf√ºgen',
                joinMarkNotFoundLabel: 'Nicht gefundene Zeilen markieren (leere Zellen = kein Match)',
                joinPreviewTitle: 'üìä Vorschau',
                joinStatTargetRowsLabel: 'Zeilen in Ziel:',
                joinStatSourceRowsLabel: 'Zeilen in Quelle:',
                joinStatMatchesLabel: 'Matches gefunden:',
                joinStatNoMatchLabel: 'Ohne Match:',
                joinPreviewBtn: 'üëÅÔ∏è Vorschau berechnen',
                joinExecuteBtn: '‚úì Spalten hinzuf√ºgen',
                
                // Row/Column Actions
                insertRowAbove: 'Zeile dar√ºber einf√ºgen',
                insertRowBelow: 'Zeile darunter einf√ºgen',
                deleteRow: 'Zeile l√∂schen',
                hideRow: 'Zeile ausblenden',
                showRow: 'Zeile einblenden',
                showAllRows: 'Alle Zeilen einblenden',
                hiddenRows: 'versteckte Zeilen',
                hiddenColumns: 'versteckte Spalten',
                rowHidden: 'Zeile ausgeblendet',
                rowShown: 'Zeile eingeblendet',
                allRowsShown: 'Alle Zeilen eingeblendet',
                columnHidden: 'Spalte ausgeblendet',
                columnShown: 'Spalte eingeblendet',
                allColumnsShown: 'Alle Spalten eingeblendet',
                showColumn: 'Spalte einblenden',
                showAllColumns: 'Alle Spalten einblenden',
                insertColumnBefore: 'Spalte links einf√ºgen',
                insertColumnAfter: 'Spalte rechts einf√ºgen',
                deleteColumn: 'Spalte l√∂schen',
                hideColumn: 'Spalte ausblenden',
                newColumn: 'Neue Spalte',
                enterColumnName: 'Spaltenname eingeben:',
                rowInserted: 'Zeile eingef√ºgt',
                rowDeleted: 'Zeile gel√∂scht',
                columnInserted: 'Spalte eingef√ºgt',
                columnDeleted: 'Spalte gel√∂scht',
                deleteRowTitle: 'Zeile l√∂schen?',
                deleteColumnTitle: 'Spalte l√∂schen?',
                deleteRowConfirm: 'M√∂chten Sie diese Zeile wirklich l√∂schen?',
                deleteColumnConfirm: 'M√∂chten Sie diese Spalte wirklich l√∂schen?',
                deleteColumnWarning: '‚ö†Ô∏è Alle Daten in dieser Spalte gehen verloren!',
                
                // New Month Modal
                createNewMonthFile: 'üìÖ Neue Monatsdatei erstellen',
                newMonthDescription: 'Erschafft eine Kopie der Template-Datei unter neuem Namen und setzt sie als Datei 2.',
                newFilename: 'Neuer Dateiname:',
                filenamePlaceholder: 'z.B. Vertragsliste_2025-01.xlsx',
                templateLabel: 'üí° Template:',
                cancel: 'Abbrechen',
                createAndLoad: 'üìÖ Erstellen & Laden',
                
                // Footer
                copyright: '¬© Norbert Jander 2025 ¬∑ v1.0.15',
                
                // Extra Columns
                extraColumns: 'Extra-Spalten',
                enableFlag: 'Flag-Spalte (A/D/C)',
                enableComment: 'Kommentar-Spalte',
                
                // License
                license: 'Lizenz',
                licenseTitle: 'Lizenzinformationen',
                thirdPartyLicenses: 'Drittanbieter-Lizenzen',
                thirdPartyDesc: 'Excel Data Sync Pro verwendet folgende Open-Source-Bibliotheken:',
                allLicensesMIT: 'Alle verwendeten Bibliotheken sind unter der MIT-Lizenz oder kompatiblen Open-Source-Lizenzen lizenziert.',
                packagesTotal: 'Pakete gesamt',
                
                // Security Logs
                logsButton: 'Protokolle',
                logsTitle: 'Protokolle',
                localLogs: 'Lokale Security-Logs',
                securityLogs: 'Security-Logs',
                securityLogsTitle: 'Security-Logs (Manipulationssicher)',
                integrityStatus: 'Integrit√§tsstatus:',
                refresh: 'Aktualisieren',
                verify: 'Verifizieren',
                clearLogs: 'Logs l√∂schen',
                
                // Network Logs
                networkLogs: 'Netzwerk-Logs',
                networkLogsTitle: 'Netzwerk-Protokoll',
                currentComputer: 'Aktueller Rechner:',
                networkLogPath: 'Log-Pfad:',
                entries: 'Eintr√§ge:',
                allComputers: 'Alle Rechner',
                timestamp: 'Zeitstempel',
                computer: 'Rechner',
                action: 'Aktion',
                file: 'Datei',
                details: 'Details',
                noNetworkLogs: 'Keine Netzwerk-Logs vorhanden',
                networkLogsNote: 'Das Netzwerk-Protokoll wird nur f√ºr Dateien auf Netzlaufwerken gef√ºhrt. Es zeigt welcher Rechner wann welche Aktion durchgef√ºhrt hat (DSGVO-konform, keine pers√∂nlichen Daten).'
            },
            en: {
                // Header
                appTitle: 'Excel Data Sync Pro',
                loadConfig: 'üìÇ Load config.json',
                saveConfig: 'üíæ Save config.json',
                help: '‚ùì Help',
                
                // Sidebar
                configuration: 'Configuration',
                settings: '‚öôÔ∏è Settings',
                language: 'Language',
                theme: 'Theme',
                themeDark: 'üåô Dark',
                themeLight: '‚òÄÔ∏è Light',
                
                // Working Directory
                workingDirectory: 'üìÅ Working Directory',
                selectWorkingDir: 'üìÇ Select Folder',
                noWorkingDirSet: 'No folder selected',
                clearWorkingDir: '‚úñÔ∏è Clear Working Directory',
                workingDirSet: '‚úì ',
                workingDirCleared: 'Working directory cleared',
                
                // Files
                file1Source: 'üìÑ File 1 (Source)',
                file2Target: 'üìÑ File 2 (Target)',
                loadSourceFile: 'üìÇ Load Source File',
                loadTargetFile: 'üìÇ Load Target File',
                noFileLoaded: 'No file loaded',
                worksheet: 'Worksheet:',
                loadFileFirst: '-- Load file first --',
                
                // Mapping
                columnMapping: 'üîó Column Mapping',
                configureColumns: '‚öôÔ∏è Configure Columns',
                loadBothFiles: 'Load both files',
                columnsConfigured: 'column(s) configured',
                
                // Template
                monthTemplate: 'üìÑ Month Template',
                loadTemplate: 'üìÇ Load Template',
                createTemplateFromSource: 'üîß Template from Source',
                noTemplateLoaded: 'No template loaded',
                templateHint: 'Empty Excel template for "üìÖ New Month File"',
                createTemplateTitle: 'üîß Create Template from Source',
                createTemplateDesc: 'Creates an empty template with all formatting and conditional formatting from the source file.',
                sourceFileLabel: 'Source file:',
                selectSheets: 'Select worksheets:',
                loadSourceFirst: 'Load a source file first',
                selectAll: '‚úì Select all',
                deselectAll: '‚úó Deselect all',
                templateInfoText: 'üí° The header row is kept, all data rows are deleted. CF rules are extended to entire columns.',
                createAndSave: 'üîß Create & save template',
                templateCreated: 'Template created successfully',
                sheetsProcessed: 'Worksheets processed',
                cfRulesPreserved: 'CF rules preserved',
                extraColumnsInTemplate: 'Create extra columns in template:',
                flagColumn: 'Flag column (A)',
                commentColumn: 'Comment column (B)',
                extraColumnsHint: 'Enable if these options are used in "Configure columns".',
                
                // History
                lastTransfers: 'üìã Recent Transfers',
                noTransfersYet: 'No transfers yet',
                
                // Search
                searchPlaceholder: 'Search... (Wildcards: * = any, ? = one character)',
                search: 'üîç Search',
                newRow: '‚ûï New Row',
                
                // Results
                readyToStart: 'Ready to Start',
                instructions: '1. Load the source file (File 1)<br>2. Load the target file (File 2)<br>3. Configure the column mapping<br>4. Search for rows and transfer them',
                noResults: 'No results for',
                results: 'results for',
                
                // Transfer
                prepareTransfer: 'üì§ Prepare row(s) for transfer',
                selected: 'selected',
                flag: 'Column 1 - Flag:',
                comment: 'Column 2 - Comment:',
                commentPlaceholder: 'Free text...',
                addToQueue: '‚ûï Add to Queue',
                transferDirect: '‚û°Ô∏è Transfer Directly',
                selectAll: '‚úì Select All',
                deselectAll: '‚úó Deselect All',
                
                // Queue
                queue: 'üìã Queue',
                rows: 'rows',
                clear: 'üóëÔ∏è Clear',
                preview: 'üëÅÔ∏è Preview',
                exportToTarget: 'üì§ Export to Target',
                directTransfer: '‚úÖ Transfer Directly',
                dataExplorer: 'Data Explorer',
                newMonthFile: 'üìÖ New Month File',
                noRowsInQueue: 'No rows in queue',
                
                // New Row
                createNewRow: '‚úèÔ∏è Create New Row',
                close: '‚úï Close',
                toQueue: '‚ûï To Queue',
                transferDirectly: '‚û°Ô∏è Transfer Directly',
                
                // Messages
                noTargetFile: 'No target file loaded',
                selectAtLeastOne: 'Please select at least one row',
                rowsTransferred: 'row(s) transferred directly!',
                rowsAdded: 'row(s) added to queue',
                edited: 'edited',
                duplicates: 'duplicate(s)',
                configFirst: 'Please configure columns first',
                
                // Data Explorer
                explorerTitle: 'Data Explorer',
                noFileLoadedExplorer: 'No file loaded',
                openFile: 'üìÇ Open File',
                fullTextSearch: 'Full-text search:',
                searchPlaceholderExplorer: 'Enter search term...',
                columns: '‚ùô‚ùô Columns',
                exportXlsx: 'üìä Export as XLSX',
                saveFile: 'üíæ Save',
                filter: 'üîç Filter',
                addFilter: '‚ûï Add Filter',
                resetFilters: 'üóëÔ∏è Reset Filters',
                showAll: 'Show all',
                hideAll: 'Hide all',
                noDataLoaded: 'No data loaded.',
                pleaseLoadFile: 'üìÇ Please load an Excel file',
                contains: 'contains',
                equals: 'equals',
                startsWith: 'starts with',
                endsWith: 'ends with',
                selectColumn: 'Select column',
                filterValue: 'Filter value',
                findReplace: 'üîÑ Replace',
                findReplaceTitle: 'Find & Replace (Ctrl+H)',
                addColumns: 'üîó Add Columns',
                addColumnsTitle: 'Add columns from another Excel file (based on matching serial number)',
                
                // Data Join Modal
                joinModalTitle: 'üîó Add Columns from File',
                joinModalInfo: '<strong style="color: var(--text);">üìã Function:</strong> Adds columns from another Excel file based on a common key (e.g. serial number). Rows are automatically matched by the key.',
                joinStep1: '1Ô∏è‚É£ Select Data Source',
                joinSelectFile: 'üìÇ Select File',
                joinNoFileSelected: 'No file selected',
                joinDropZoneText: 'Drop Excel file here',
                joinWorksheet: 'Worksheet:',
                joinLoadFile: '-- Load file --',
                joinStep2: '2Ô∏è‚É£ Key Column (e.g. Serial Number)',
                joinStep2Desc: 'Select the column that serves as a common key in both files.',
                joinTargetFile: 'Current File (Target):',
                joinSourceFile: 'Source File:',
                joinSelectColumn: '-- Select column --',
                joinStep3: '3Ô∏è‚É£ Select Columns to Add',
                joinStep3Desc: 'Select the columns from the source file to add to the current file.',
                joinLoadSourceFirst: 'Load a source file first',
                joinStep4: '4Ô∏è‚É£ Options',
                joinInsertAfterKeyLabel: 'Insert new columns directly after the key column',
                joinMarkNotFoundLabel: 'Mark rows not found (empty cells = no match)',
                joinPreviewTitle: 'üìä Preview',
                joinStatTargetRowsLabel: 'Rows in target:',
                joinStatSourceRowsLabel: 'Rows in source:',
                joinStatMatchesLabel: 'Matches found:',
                joinStatNoMatchLabel: 'No match:',
                joinPreviewBtn: 'üëÅÔ∏è Calculate Preview',
                joinExecuteBtn: '‚úì Add Columns',
                
                // Row/Column Actions
                insertRowAbove: 'Insert row above',
                insertRowBelow: 'Insert row below',
                deleteRow: 'Delete row',
                hideRow: 'Hide row',
                showRow: 'Show row',
                showAllRows: 'Show all rows',
                hiddenRows: 'hidden rows',
                hiddenColumns: 'hidden columns',
                rowHidden: 'Row hidden',
                rowShown: 'Row shown',
                allRowsShown: 'All rows shown',
                columnHidden: 'Column hidden',
                columnShown: 'Column shown',
                allColumnsShown: 'All columns shown',
                showColumn: 'Show column',
                showAllColumns: 'Show all columns',
                insertColumnBefore: 'Insert column left',
                insertColumnAfter: 'Insert column right',
                deleteColumn: 'Delete column',
                hideColumn: 'Hide column',
                newColumn: 'New Column',
                enterColumnName: 'Enter column name:',
                rowInserted: 'Row inserted',
                rowDeleted: 'Row deleted',
                columnInserted: 'Column inserted',
                columnDeleted: 'Column deleted',
                deleteRowTitle: 'Delete Row?',
                deleteColumnTitle: 'Delete Column?',
                deleteRowConfirm: 'Do you really want to delete this row?',
                deleteColumnConfirm: 'Do you really want to delete this column?',
                deleteColumnWarning: '‚ö†Ô∏è All data in this column will be lost!',
                
                // New Month Modal
                createNewMonthFile: 'üìÖ Create New Month File',
                newMonthDescription: 'Creates a copy of the template file with a new name and sets it as File 2.',
                newFilename: 'New filename:',
                filenamePlaceholder: 'e.g. ContractList_2025-01.xlsx',
                templateLabel: 'üí° Template:',
                cancel: 'Cancel',
                createAndLoad: 'üìÖ Create & Load',
                
                // Footer
                copyright: '¬© Norbert Jander 2025 ¬∑ v1.0.15',
                
                // Extra Columns
                extraColumns: 'Extra Columns',
                enableFlag: 'Flag Column (A/D/C)',
                enableComment: 'Comment Column',
                
                // License
                license: 'License',
                licenseTitle: 'License Information',
                thirdPartyLicenses: 'Third-Party Licenses',
                thirdPartyDesc: 'Excel Data Sync Pro uses the following open-source libraries:',
                allLicensesMIT: 'All libraries used are licensed under the MIT License or compatible open-source licenses.',
                packagesTotal: 'packages total',
                
                // Security Logs
                logsButton: 'Logs',
                logsTitle: 'Logs',
                localLogs: 'Local Security Logs',
                securityLogs: 'Security Logs',
                securityLogsTitle: 'Security Logs (Tamper-Proof)',
                integrityStatus: 'Integrity Status:',
                refresh: 'Refresh',
                verify: 'Verify',
                clearLogs: 'Clear Logs',
                
                // Network Logs
                networkLogs: 'Network Logs',
                networkLogsTitle: 'Network Protocol',
                currentComputer: 'Current Computer:',
                networkLogPath: 'Log Path:',
                entries: 'Entries:',
                allComputers: 'All Computers',
                timestamp: 'Timestamp',
                computer: 'Computer',
                action: 'Action',
                file: 'File',
                details: 'Details',
                noNetworkLogs: 'No network logs available',
                networkLogsNote: 'The network log is only kept for files on network drives. It shows which computer performed which action and when (GDPR compliant, no personal data).'
            }
        };
        
        let currentLanguage = localStorage.getItem('excelSyncLanguage') || 'de';
        let currentTheme = localStorage.getItem('excelSyncTheme') || 'dark';
        
        function t(key) {
            return translations[currentLanguage]?.[key] || translations['de'][key] || key;
        }
        
        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('excelSyncLanguage', lang);
            applyTranslations();
        }
        
        function setTheme(theme) {
            currentTheme = theme;
            localStorage.setItem('excelSyncTheme', theme);
            if (theme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                document.body.classList.remove('light-theme');
            }
        }
        
        function applyTranslations() {
            // Update all elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const text = t(key);
                if (el.tagName === 'INPUT' && el.type === 'text') {
                    el.placeholder = text;
                } else if (el.tagName === 'OPTION') {
                    el.textContent = text;
                } else {
                    // Keep existing content if it's a dynamic element (like file info)
                    const dynamicElements = ['file1Info', 'file2Info', 'templateInfo', 'mappingInfo'];
                    if (!dynamicElements.includes(el.id)) {
                        el.innerHTML = text;
                    }
                }
                // Update title attribute if data-i18n-title is present
                const titleKey = el.getAttribute('data-i18n-title');
                if (titleKey) {
                    el.title = t(titleKey);
                }
            });
            
            // Header
            document.querySelector('.logo span').textContent = t('appTitle');
            document.getElementById('btnImportConfig').innerHTML = t('loadConfig');
            document.getElementById('btnExportConfig').innerHTML = t('saveConfig');
            document.getElementById('btnHelp').innerHTML = t('help');
            document.querySelector('.sidebar-header-text').textContent = t('configuration');
            
            // Search section
            document.getElementById('searchInput').placeholder = t('searchPlaceholder');
            document.getElementById('btnSearch').innerHTML = t('search');
            document.getElementById('btnNewRow').innerHTML = t('newRow');
            
            // Empty state
            document.querySelector('.empty-state-title').textContent = t('readyToStart');
            document.querySelector('.empty-state-text').innerHTML = t('instructions');
            
            // Footer
            document.querySelector('footer').innerHTML = t('copyright');
            
            // Queue panel
            document.getElementById('btnClearQueue').innerHTML = t('clear');
            document.getElementById('btnPreviewTransfer').innerHTML = t('preview');
            document.getElementById('btnExportPS').innerHTML = t('exportToTarget');
            document.getElementById('btnDataExplorer').innerHTML = 'üìä ' + t('dataExplorer');
            document.getElementById('btnNewMonth').innerHTML = t('newMonthFile');
            
            // Queue title - update the text before and after the count span
            const queueTitleEl = document.querySelector('#queuePanel .transfer-title');
            if (queueTitleEl) {
                const countSpan = document.getElementById('queueCount');
                const count = countSpan ? countSpan.textContent : '0';
                queueTitleEl.innerHTML = `${t('queue')} (<span id="queueCount">${count}</span> ${t('rows')})`;
            }
            
            // Queue empty message
            const queueEmpty = document.querySelector('.queue-empty');
            if (queueEmpty) {
                queueEmpty.textContent = t('noRowsInQueue');
            }
            
            // Transfer panel
            document.getElementById('btnAddToQueue').innerHTML = t('addToQueue');
            document.getElementById('btnTransferDirect').innerHTML = t('transferDirect');
            document.getElementById('btnSelectAll').innerHTML = t('selectAll');
            document.getElementById('btnDeselectAll').innerHTML = t('deselectAll');
            
            // Theme dropdown options
            const darkOpt = document.querySelector('#selectTheme option[value="dark"]');
            const lightOpt = document.querySelector('#selectTheme option[value="light"]');
            if (darkOpt) darkOpt.textContent = t('themeDark');
            if (lightOpt) lightOpt.textContent = t('themeLight');
            
            // Sidebar buttons
            const btnLoadFile1 = document.getElementById('btnLoadFile1');
            const btnLoadFile2 = document.getElementById('btnLoadFile2');
            const btnConfigMapping = document.getElementById('btnConfigMapping');
            const btnLoadTemplate = document.getElementById('btnLoadTemplate');
            if (btnLoadFile1) btnLoadFile1.innerHTML = t('loadSourceFile');
            if (btnLoadFile2) btnLoadFile2.innerHTML = t('loadTargetFile');
            if (btnConfigMapping) btnConfigMapping.innerHTML = t('configureColumns');
            if (btnLoadTemplate) btnLoadTemplate.innerHTML = t('loadTemplate');
            
            // New row panel
            const newRowTitle = document.querySelector('.new-row-title');
            const btnCloseNewRow = document.getElementById('btnCloseNewRow');
            const btnAddNewRowToQueue = document.getElementById('btnAddNewRowToQueue');
            const btnTransferNewRowDirect = document.getElementById('btnTransferNewRowDirect');
            if (newRowTitle) newRowTitle.textContent = t('createNewRow');
            if (btnCloseNewRow) btnCloseNewRow.innerHTML = t('close');
            if (btnAddNewRowToQueue) btnAddNewRowToQueue.innerHTML = t('toQueue');
            if (btnTransferNewRowDirect) btnTransferNewRowDirect.innerHTML = t('transferDirectly');
            
            // Data Explorer Modal
            const explorerTitle = document.querySelector('#dataExplorerModal .modal-title');
            if (explorerTitle) {
                // Nur den Text vor dem Span aktualisieren, nicht das ganze HTML ersetzen
                const fileNameSpan = document.getElementById('explorerFileName');
                const currentFileName = fileNameSpan ? fileNameSpan.textContent : t('noFileLoadedExplorer');
                // Verwende einen TextNode f√ºr den Titel-Prefix
                explorerTitle.childNodes[0].textContent = `üìä ${t('explorerTitle')} - `;
                // Falls der Span nicht existiert oder entfernt wurde, neu erstellen
                if (!explorerTitle.querySelector('#explorerFileName')) {
                    const newSpan = document.createElement('span');
                    newSpan.id = 'explorerFileName';
                    newSpan.textContent = currentFileName;
                    explorerTitle.appendChild(newSpan);
                }
            }
            const btnExplorerOpenFile = document.getElementById('btnExplorerOpenFile');
            const btnToggleColumns = document.getElementById('btnToggleColumns');
            const btnExplorerExport = document.getElementById('btnExplorerExport');
            const btnAddExplorerFilter = document.getElementById('btnAddExplorerFilter');
            const btnClearExplorerFilters = document.getElementById('btnClearExplorerFilters');
            const btnShowAllColumns = document.getElementById('btnShowAllColumns');
            const btnHideAllColumns = document.getElementById('btnHideAllColumns');
            const btnCloseExplorerFooter = document.getElementById('btnCloseExplorerFooter');
            const explorerResultCount = document.getElementById('explorerResultCount');
            const explorerSearch = document.getElementById('explorerSearch');
            
            if (btnExplorerOpenFile) btnExplorerOpenFile.innerHTML = t('openFile');
            if (btnToggleColumns) btnToggleColumns.innerHTML = t('columns');
            if (btnExplorerExport) btnExplorerExport.innerHTML = t('exportXlsx');
            if (btnAddExplorerFilter) btnAddExplorerFilter.innerHTML = t('addFilter');
            if (btnClearExplorerFilters) btnClearExplorerFilters.innerHTML = t('resetFilters');
            if (btnShowAllColumns) btnShowAllColumns.textContent = t('showAll');
            if (btnHideAllColumns) btnHideAllColumns.textContent = t('hideAll');
            if (btnCloseExplorerFooter) btnCloseExplorerFooter.textContent = t('close');
            if (explorerResultCount && (explorerResultCount.textContent === 'Keine Daten geladen.' || explorerResultCount.textContent === 'No data loaded.')) {
                explorerResultCount.textContent = t('noDataLoaded');
            }
            if (explorerSearch) explorerSearch.placeholder = t('searchPlaceholderExplorer');
            
            // Data Explorer Preview button
            const btnExplorerPreview = document.getElementById('btnExplorerPreview');
            if (btnExplorerPreview) btnExplorerPreview.innerHTML = t('preview');
            
            // Explorer filter section label
            const filterLabel = document.querySelector('#explorerFilterControls > div > span');
            if (filterLabel) filterLabel.textContent = t('filter');
            
            // Explorer worksheet label and full-text search label
            const worksheetLabels = document.querySelectorAll('#dataExplorerModal .transfer-field label');
            worksheetLabels.forEach(label => {
                if (label.textContent === 'Arbeitsblatt:' || label.textContent === 'Worksheet:') {
                    label.textContent = t('worksheet');
                }
                if (label.textContent === 'Volltextsuche:' || label.textContent === 'Full-text search:') {
                    label.textContent = t('fullTextSearch');
                }
            });
            
            // Explorer filter operator options
            document.querySelectorAll('#explorerFilters .filter-operator').forEach(select => {
                const options = select.querySelectorAll('option');
                options.forEach(opt => {
                    if (opt.value === 'contains') opt.textContent = t('contains');
                    if (opt.value === 'equals') opt.textContent = t('equals');
                    if (opt.value === 'startsWith') opt.textContent = t('startsWith');
                    if (opt.value === 'endsWith') opt.textContent = t('endsWith');
                });
            });
            
            // Data Join Modal - Update select default options
            const joinSourceSheet = document.getElementById('joinSourceSheet');
            const joinTargetKeyColumn = document.getElementById('joinTargetKeyColumn');
            const joinSourceKeyColumn = document.getElementById('joinSourceKeyColumn');
            const joinSourceFileName = document.getElementById('joinSourceFileName');
            const joinColumnsContainer = document.getElementById('joinColumnsContainer');
            
            // Update default options if they exist and are in initial state
            if (joinSourceSheet && joinSourceSheet.options.length === 1) {
                joinSourceSheet.options[0].textContent = t('joinLoadFile');
            }
            if (joinTargetKeyColumn && joinTargetKeyColumn.options.length > 0 && joinTargetKeyColumn.options[0].value === '') {
                joinTargetKeyColumn.options[0].textContent = t('joinSelectColumn');
            }
            if (joinSourceKeyColumn && joinSourceKeyColumn.options.length > 0 && joinSourceKeyColumn.options[0].value === '') {
                joinSourceKeyColumn.options[0].textContent = t('joinSelectColumn');
            }
            // Update "no file selected" text if in initial state
            if (joinSourceFileName && (joinSourceFileName.textContent === 'Keine Datei ausgew√§hlt' || joinSourceFileName.textContent === 'No file selected')) {
                joinSourceFileName.textContent = t('joinNoFileSelected');
            }
            // Update "load source first" text if in initial state
            if (joinColumnsContainer) {
                const initialMsg = joinColumnsContainer.querySelector('div[style*="text-align: center"]');
                if (initialMsg && (initialMsg.textContent.includes('Laden Sie zuerst') || initialMsg.textContent.includes('Load a source file'))) {
                    initialMsg.textContent = t('joinLoadSourceFirst');
                }
            }
            
            // New Month Modal
            const newMonthTitle = document.querySelector('#newMonthModal .modal-title');
            const newMonthDesc = document.querySelector('#newMonthModal .modal-body > p:first-of-type');
            const newMonthLabel = document.querySelector('#newMonthModal .config-label');
            const newMonthFilename = document.getElementById('newMonthFilename');
            const newMonthTemplateLabel = document.querySelector('#newMonthModal .modal-body > p:last-of-type');
            const btnCancelNewMonth = document.getElementById('btnCancelNewMonth');
            const btnConfirmNewMonth = document.getElementById('btnConfirmNewMonth');
            
            if (newMonthTitle) newMonthTitle.textContent = t('createNewMonthFile');
            if (newMonthDesc) newMonthDesc.textContent = t('newMonthDescription');
            if (newMonthLabel) newMonthLabel.textContent = t('newFilename');
            if (newMonthFilename) newMonthFilename.placeholder = t('filenamePlaceholder');
            if (newMonthTemplateLabel) {
                const templateName = document.getElementById('newMonthTemplateName');
                newMonthTemplateLabel.innerHTML = `${t('templateLabel')} <strong id="newMonthTemplateName">${templateName ? templateName.textContent : '-'}</strong>`; 
            }
            if (btnCancelNewMonth) btnCancelNewMonth.textContent = t('cancel');
            if (btnConfirmNewMonth) btnConfirmNewMonth.innerHTML = t('createAndLoad');
        }
        
        // ==================== JSDoc Type Definitions ====================
        /**
         * @typedef {Object} FileState
         * @property {string|null} name - File name
         * @property {Object|null} workbook - Workbook object
         * @property {string[]} sheets - List of sheet names
         * @property {string|null} selectedSheet - Currently selected sheet
         * @property {Array<Array<string|number>>} data - Sheet data
         * @property {string[]} headers - Column headers
         * @property {string|null} filePath - Full file path
         */

        /**
         * @typedef {Object} MappingConfig
         * @property {number[]} sourceColumns - Source column indices to copy
         * @property {number} targetStartColumn - Target start column (default 1)
         * @property {number} duplicateCheckColumn - Column index for duplicate check
         */

        /**
         * @typedef {Object} TransferQueueItem
         * @property {Array<string|number>} data - Row data array
         * @property {string} flag - Flag value (A/D/C or empty)
         * @property {string} comment - Comment text
         * @property {string} checkValue - Value used for duplicate checking
         * @property {boolean} [wasEdited] - Whether the row was edited
         */

        /**
         * @typedef {Object} TemplateState
         * @property {string|null} name - Template file name
         * @property {Object|null} data - Template data
         * @property {string|null} filePath - Template file path
         */

        /**
         * @typedef {Object} PaginationState
         * @property {number} currentPage - Current page number (1-based)
         * @property {number} pageSize - Items per page
         * @property {number[]} pageSizeOptions - Available page size options
         */

        /**
         * @typedef {Object} AppState
         * @property {FileState} file1 - Source file state
         * @property {FileState} file2 - Target file state
         * @property {MappingConfig} mapping - Column mapping configuration
         * @property {number|null} selectedRow - Currently selected row index
         * @property {number[]} selectedRows - Array of selected row indices
         * @property {Array<Array<string|number>>} searchResults - Search results
         * @property {Array<Object>} history - Transfer history
         * @property {TransferQueueItem[]} transferQueue - Items queued for transfer
         * @property {TemplateState} template - Template file state
         * @property {Object|null} lastDirectoryHandle - Last used directory handle
         * @property {PaginationState} searchPagination - Search results pagination
         */

        // ==================== Undo/Redo System ====================
        const undoRedoState = {
            // Suchergebnisse
            searchUndoStack: [],
            searchRedoStack: [],
            // Datenexplorer
            explorerUndoStack: [],
            explorerRedoStack: [],
            maxStackSize: 50
        };
        
        function pushSearchUndo(action) {
            undoRedoState.searchUndoStack.push(action);
            if (undoRedoState.searchUndoStack.length > undoRedoState.maxStackSize) {
                undoRedoState.searchUndoStack.shift();
            }
            undoRedoState.searchRedoStack = []; // Redo-Stack leeren bei neuer Aktion
        }
        
        function pushExplorerUndo(action) {
            undoRedoState.explorerUndoStack.push(action);
            if (undoRedoState.explorerUndoStack.length > undoRedoState.maxStackSize) {
                undoRedoState.explorerUndoStack.shift();
            }
            undoRedoState.explorerRedoStack = []; // Redo-Stack leeren bei neuer Aktion
        }
        
        function undoSearch() {
            if (undoRedoState.searchUndoStack.length === 0) return false;
            
            const action = undoRedoState.searchUndoStack.pop();
            undoRedoState.searchRedoStack.push(action);
            
            // Urspr√ºnglichen Wert wiederherstellen
            const { rowIndex, colIndex, oldValue, newValue } = action;
            state.searchResults[rowIndex].data[colIndex] = oldValue;
            
            // UI aktualisieren
            const cell = document.querySelector(`#resultsTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
            if (cell) {
                cell.textContent = oldValue;
                cell.classList.toggle('edited', oldValue !== cell.dataset.original);
            }
            return true;
        }
        
        function redoSearch() {
            if (undoRedoState.searchRedoStack.length === 0) return false;
            
            const action = undoRedoState.searchRedoStack.pop();
            undoRedoState.searchUndoStack.push(action);
            
            // Neuen Wert wiederherstellen
            const { rowIndex, colIndex, oldValue, newValue } = action;
            state.searchResults[rowIndex].data[colIndex] = newValue;
            
            // UI aktualisieren
            const cell = document.querySelector(`#resultsTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
            if (cell) {
                cell.textContent = newValue;
                cell.classList.toggle('edited', newValue !== cell.dataset.original);
            }
            return true;
        }
        
        function undoExplorer() {
            if (undoRedoState.explorerUndoStack.length === 0) return false;
            
            const action = undoRedoState.explorerUndoStack.pop();
            undoRedoState.explorerRedoStack.push(action);
            
            // Pr√ºfe auf moveRows Aktion
            if (action.type === 'moveRows') {
                // HINWEIS: Undo f√ºr moveRows aktuell nicht unterst√ºtzt (Performance-Optimierung)
                showNotification('Undo f√ºr Zeilen-Verschiebung nicht m√∂glich. Bitte Datei neu laden.', 'warning');
                return false;
            }
            
            // Pr√ºfe auf Multi-Aktion (mehrere Zellen gleichzeitig)
            if (action.type === 'multi') {
                action.actions.forEach(subAction => {
                    const { rowIndex, colIndex, oldValue, originalValue } = subAction;
                    explorerState.data[rowIndex][colIndex] = oldValue;
                    
                    const cellKey = `${rowIndex}-${colIndex}`;
                    if (oldValue === originalValue) {
                        explorerState.editedCells.delete(cellKey);
                    } else {
                        explorerState.editedCells.set(cellKey, oldValue);
                    }
                    
                    // UI aktualisieren
                    const cell = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                    if (cell) {
                        cell.textContent = oldValue;
                        cell.dataset.lastValue = oldValue;
                        cell.classList.toggle('edited', oldValue !== cell.dataset.original);
                    }
                });
                updateExplorerEditStatus();
                showNotification(`${action.actions.length} Zelle(n) wiederhergestellt`, 'info');
                return true;
            }
            
            // Urspr√ºnglichen Wert wiederherstellen (Standard-Zellbearbeitung)
            const { rowIndex, colIndex, oldValue, newValue } = action;
            explorerState.data[rowIndex][colIndex] = oldValue;
            
            const cellKey = `${rowIndex}-${colIndex}`;
            if (oldValue === action.originalValue) {
                explorerState.editedCells.delete(cellKey);
            } else {
                explorerState.editedCells.set(cellKey, oldValue);
            }
            
            // UI aktualisieren
            const cell = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
            if (cell) {
                cell.textContent = oldValue;
                cell.classList.toggle('edited', oldValue !== cell.dataset.original);
            }
            updateExplorerEditStatus();
            return true;
        }
        
        function redoExplorer() {
            if (undoRedoState.explorerRedoStack.length === 0) return false;
            
            const action = undoRedoState.explorerRedoStack.pop();
            undoRedoState.explorerUndoStack.push(action);
            
            // Pr√ºfe auf moveRows Aktion
            if (action.type === 'moveRows') {
                // HINWEIS: Redo f√ºr moveRows aktuell nicht unterst√ºtzt (Performance-Optimierung)
                showNotification('Redo f√ºr Zeilen-Verschiebung nicht m√∂glich.', 'warning');
                return false;
            }
            
            // Pr√ºfe auf Multi-Aktion (mehrere Zellen gleichzeitig)
            if (action.type === 'multi') {
                action.actions.forEach(subAction => {
                    const { rowIndex, colIndex, newValue, originalValue } = subAction;
                    explorerState.data[rowIndex][colIndex] = newValue;
                    
                    const cellKey = `${rowIndex}-${colIndex}`;
                    if (newValue === originalValue) {
                        explorerState.editedCells.delete(cellKey);
                    } else {
                        explorerState.editedCells.set(cellKey, newValue);
                    }
                    
                    // UI aktualisieren
                    const cell = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                    if (cell) {
                        cell.textContent = newValue;
                        cell.dataset.lastValue = newValue;
                        cell.classList.toggle('edited', newValue !== cell.dataset.original);
                    }
                });
                updateExplorerEditStatus();
                showNotification(`${action.actions.length} Zelle(n) gel√∂scht`, 'info');
                return true;
            }
            
            // Neuen Wert wiederherstellen (Standard-Zellbearbeitung)
            const { rowIndex, colIndex, oldValue, newValue, originalValue } = action;
            explorerState.data[rowIndex][colIndex] = newValue;
            
            const cellKey = `${rowIndex}-${colIndex}`;
            if (newValue === originalValue) {
                explorerState.editedCells.delete(cellKey);
            } else {
                explorerState.editedCells.set(cellKey, newValue);
            }
            
            // UI aktualisieren
            const cell = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
            if (cell) {
                cell.textContent = newValue;
                cell.classList.toggle('edited', newValue !== cell.dataset.original);
            }
            updateExplorerEditStatus();
            return true;
        }
        
        function showUndoRedoFeedback(action) {
            // Kurzes visuelles Feedback
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--bg-lighter);
                color: #ff9800;
                padding: 8px 16px;
                border-radius: 4px;
                font-size: 13px;
                z-index: 10000;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                animation: fadeInOut 1.5s ease-in-out;
            `;
            toast.textContent = action;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 1500);
        }
        
        // Globale Notification-Funktion f√ºr Erfolgs-, Warn- und Fehlermeldungen
        function showNotification(message, type = 'info') {
            const colors = {
                success: { bg: '#217346', border: '#2d9a5d' },
                error: { bg: '#d32f2f', border: '#f44336' },
                warning: { bg: '#f57c00', border: '#ff9800' },
                info: { bg: '#1976d2', border: '#2196f3' }
            };
            const color = colors[type] || colors.info;
            
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${color.bg};
                border: 1px solid ${color.border};
                color: #ff9800;
                padding: 12px 20px;
                border-radius: 6px;
                font-size: 14px;
                z-index: 100000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideInRight 0.3s ease-out;
                max-width: 400px;
                word-wrap: break-word;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // ==================== Auto-Save System ====================
        const AUTO_SAVE_KEY = 'excelsync_autosave';
        const CLEAN_SHUTDOWN_KEY = 'excelsync_clean_shutdown';
        const AUTO_SAVE_INTERVAL = 30000; // 30 Sekunden
        let autoSaveTimer = null;
        
        function getAutoSaveData() {
            // Sammle alle bearbeiteten Daten
            const data = {
                timestamp: Date.now(),
                version: '1.1',
                // Quelldatei (Datei 1)
                file1: {
                    filePath: state.file1.filePath || null,
                    name: state.file1.name || null,
                    selectedSheet: state.file1.selectedSheet || null
                },
                // Zieldatei (Datei 2)
                file2: {
                    filePath: state.file2.filePath || null,
                    name: state.file2.name || null,
                    selectedSheet: state.file2.selectedSheet || null
                },
                // Mapping
                mapping: state.mapping,
                // Datenexplorer
                explorer: {
                    filePath: explorerState.filePath,
                    fileName: explorerState.fileName,
                    selectedSheet: explorerState.selectedSheet,
                    editedCells: Array.from(explorerState.editedCells.entries())
                },
                // Warteschlange
                transferQueue: state.transferQueue,
                // Suchergebnisse-Bearbeitungen (nur wenn Suche aktiv)
                searchEdits: []
            };
            
            // Suchergebnis-Bearbeitungen sammeln
            document.querySelectorAll('#resultsTableBody td.edited').forEach(td => {
                data.searchEdits.push({
                    row: parseInt(td.dataset.row),
                    col: parseInt(td.dataset.col),
                    original: td.dataset.original,
                    current: td.textContent
                });
            });
            
            return data;
        }
        
        function autoSave() {
            const data = getAutoSaveData();
            
            // Nur speichern wenn es etwas zu speichern gibt
            const hasExplorerEdits = data.explorer.editedCells.length > 0;
            const hasQueueItems = data.transferQueue.length > 0;
            const hasSearchEdits = data.searchEdits.length > 0;
            
            if (hasExplorerEdits || hasQueueItems || hasSearchEdits) {
                try {
                    localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify(data));
                    console.log('Auto-Save: Daten gesichert', {
                        explorerEdits: data.explorer.editedCells.length,
                        queueItems: data.transferQueue.length,
                        searchEdits: data.searchEdits.length
                    });
                } catch (e) {
                    console.warn('Auto-Save fehlgeschlagen:', e);
                }
            }
        }
        
        function clearAutoSave() {
            localStorage.removeItem(AUTO_SAVE_KEY);
            localStorage.removeItem(CLEAN_SHUTDOWN_KEY);
        }
        
        // Markiert einen sauberen App-Shutdown (kein Crash)
        function markCleanShutdown() {
            localStorage.setItem(CLEAN_SHUTDOWN_KEY, 'true');
            // AutoSave-Daten l√∂schen bei normalem Beenden
            localStorage.removeItem(AUTO_SAVE_KEY);
        }
        
        // Pr√ºft ob der letzte Shutdown sauber war
        function wasCleanShutdown() {
            return localStorage.getItem(CLEAN_SHUTDOWN_KEY) === 'true';
        }
        
        async function checkAutoSaveRecovery() {
            try {
                const saved = localStorage.getItem(AUTO_SAVE_KEY);
                const cleanShutdown = wasCleanShutdown();
                
                // Clean-Shutdown-Flag l√∂schen f√ºr n√§chsten Start
                localStorage.removeItem(CLEAN_SHUTDOWN_KEY);
                
                // Wenn sauberer Shutdown oder keine Daten -> nichts tun
                if (!saved || cleanShutdown) {
                    if (saved) clearAutoSave(); // Alte Daten l√∂schen falls vorhanden
                    return;
                }
                
                const data = JSON.parse(saved);
                const age = Date.now() - data.timestamp;
                const ageMinutes = Math.round(age / 60000);
                
                // Nur wiederherstellen wenn weniger als 24 Stunden alt
                if (age > 24 * 60 * 60 * 1000) {
                    clearAutoSave();
                    return;
                }
                
                const hasExplorerEdits = data.explorer?.editedCells?.length > 0;
                const hasQueueItems = data.transferQueue?.length > 0;
                const hasSearchEdits = data.searchEdits?.length > 0;
                const hasFile1 = data.file1?.filePath;
                const hasFile2 = data.file2?.filePath;
                
                if (!hasExplorerEdits && !hasQueueItems && !hasSearchEdits && !hasFile1 && !hasFile2) {
                    clearAutoSave();
                    return;
                }
                
                // Zusammenfassung erstellen
                let summary = 'Ungespeicherte Daten gefunden:\n\n';
                if (hasFile1) {
                    summary += `‚Ä¢ Quelldatei: ${data.file1.name || data.file1.filePath}\n`;
                }
                if (hasFile2) {
                    summary += `‚Ä¢ Zieldatei: ${data.file2.name || data.file2.filePath}\n`;
                }
                if (hasQueueItems) {
                    summary += `‚Ä¢ ${data.transferQueue.length} Eintr√§ge in der Warteschlange\n`;
                }
                if (hasExplorerEdits) {
                    summary += `‚Ä¢ ${data.explorer.editedCells.length} bearbeitete Zellen im Datenexplorer\n`;
                    if (data.explorer.fileName) {
                        summary += `  (Datei: ${data.explorer.fileName})\n`;
                    }
                }
                if (hasSearchEdits) {
                    summary += `‚Ä¢ ${data.searchEdits.length} bearbeitete Suchergebnisse\n`;
                }
                summary += `\nGespeichert vor ${ageMinutes} Minuten.\n\nM√∂chten Sie diese Daten wiederherstellen?`;
                
                if (confirm(summary)) {
                    await restoreAutoSave(data);
                } else {
                    clearAutoSave();
                }
            } catch (e) {
                console.warn('Auto-Save Recovery fehlgeschlagen:', e);
                clearAutoSave();
            }
        }
        
        async function restoreAutoSave(data) {
            console.log('[Auto-Save] Starte Wiederherstellung...', data);
            
            // Mapping wiederherstellen (vor den Dateien, da es f√ºr die Anzeige ben√∂tigt wird)
            if (data.mapping) {
                state.mapping = data.mapping;
                updateMappingPreview();
            }
            
            // Quelldatei wiederherstellen
            if (data.file1?.filePath) {
                try {
                    console.log('[Auto-Save] Lade Quelldatei:', data.file1.filePath);
                    const result = await window.electronAPI.readExcelFile(data.file1.filePath);
                    if (result.success) {
                        state.file1.name = result.fileName;
                        state.file1.filePath = data.file1.filePath;
                        state.file1.sheets = result.sheets;
                        state.file1.workbook = { SheetNames: result.sheets };
                        
                        elements.selectSheet1.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
                        elements.selectSheet1.disabled = false;
                        elements.file1Info.textContent = `‚úì ${result.fileName}`;
                        elements.file1Info.classList.add('loaded');
                        
                        const sheetToLoad = data.file1.selectedSheet || result.sheets[0];
                        elements.selectSheet1.value = sheetToLoad;
                        await loadSheet1Electron(sheetToLoad);
                        console.log('[Auto-Save] Quelldatei wiederhergestellt');
                    }
                } catch (e) {
                    console.warn('[Auto-Save] Quelldatei konnte nicht geladen werden:', e);
                }
            }
            
            // Zieldatei wiederherstellen
            if (data.file2?.filePath) {
                try {
                    console.log('[Auto-Save] Lade Zieldatei:', data.file2.filePath);
                    const result = await window.electronAPI.readExcelFile(data.file2.filePath);
                    if (result.success) {
                        state.file2.name = result.fileName;
                        state.file2.filePath = data.file2.filePath;
                        state.file2.sheets = result.sheets;
                        state.file2.workbook = { SheetNames: result.sheets };
                        
                        elements.selectSheet2.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
                        elements.selectSheet2.disabled = false;
                        elements.file2Info.textContent = `‚úì ${result.fileName}`;
                        elements.file2Info.classList.add('loaded');
                        
                        const sheetToLoad = data.file2.selectedSheet || result.sheets[0];
                        elements.selectSheet2.value = sheetToLoad;
                        await loadSheet2Electron(sheetToLoad);
                        console.log('[Auto-Save] Zieldatei wiederhergestellt');
                    }
                } catch (e) {
                    console.warn('[Auto-Save] Zieldatei konnte nicht geladen werden:', e);
                }
            }
            
            // Warteschlange wiederherstellen
            if (data.transferQueue?.length > 0) {
                state.transferQueue = data.transferQueue;
                updateQueueDisplay();
                showUndoRedoFeedback(`${data.transferQueue.length} Eintr√§ge wiederhergestellt`);
            }
            
            // Datenexplorer-Bearbeitungen werden beim √ñffnen der Datei wiederhergestellt
            if (data.explorer?.editedCells?.length > 0 && data.explorer.filePath) {
                // Speichere f√ºr sp√§tere Wiederherstellung
                window._pendingExplorerRestore = data.explorer;
            }
            
            // Button-Status nochmal aktualisieren (nach allen async Operationen)
            updateQueueDisplay();
            
            console.log('[Auto-Save] Wiederherstellung abgeschlossen. file2.filePath:', state.file2.filePath);
            
            // Auto-Save nach Wiederherstellung nicht l√∂schen (wird bei n√§chster Aktion √ºberschrieben)
        }
        
        function startAutoSave() {
            if (autoSaveTimer) clearInterval(autoSaveTimer);
            autoSaveTimer = setInterval(autoSave, AUTO_SAVE_INTERVAL);
        }
        
        function stopAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        }

        // ==================== Such-Historie System ====================
        const SEARCH_HISTORY_KEY = 'excelsync_search_history';
        const SEARCH_HISTORY_MAX = 15;
        let searchHistorySelectedIndex = -1;
        
        function getSearchHistory() {
            try {
                const saved = localStorage.getItem(SEARCH_HISTORY_KEY);
                return saved ? JSON.parse(saved) : [];
            } catch (e) {
                return [];
            }
        }
        
        function saveSearchHistory(history) {
            try {
                localStorage.setItem(SEARCH_HISTORY_KEY, JSON.stringify(history));
            } catch (e) {
                console.warn('Such-Historie speichern fehlgeschlagen:', e);
            }
        }
        
        function addToSearchHistory(term, resultCount) {
            if (!term || term.trim().length === 0) return;
            
            const trimmed = term.trim();
            let history = getSearchHistory();
            
            // Existierenden Eintrag entfernen (wird oben neu eingef√ºgt)
            history = history.filter(item => item.term.toLowerCase() !== trimmed.toLowerCase());
            
            // Neuen Eintrag am Anfang einf√ºgen
            history.unshift({
                term: trimmed,
                count: resultCount,
                timestamp: Date.now()
            });
            
            // Auf Maximum begrenzen
            if (history.length > SEARCH_HISTORY_MAX) {
                history = history.slice(0, SEARCH_HISTORY_MAX);
            }
            
            saveSearchHistory(history);
        }
        
        function removeFromSearchHistory(term) {
            let history = getSearchHistory();
            history = history.filter(item => item.term !== term);
            saveSearchHistory(history);
            renderSearchHistoryDropdown();
        }
        
        function clearSearchHistory() {
            localStorage.removeItem(SEARCH_HISTORY_KEY);
            renderSearchHistoryDropdown();
            hideSearchHistoryDropdown();
        }
        
        function renderSearchHistoryDropdown(filterText = '') {
            const dropdown = document.getElementById('searchHistoryDropdown');
            if (!dropdown) return;
            
            let history = getSearchHistory();
            
            // Nach Filter filtern
            if (filterText) {
                const lower = filterText.toLowerCase();
                history = history.filter(item => item.term.toLowerCase().includes(lower));
            }
            
            if (history.length === 0) {
                dropdown.innerHTML = '';
                dropdown.classList.remove('show');
                return;
            }
            
            let html = `
                <div class="search-history-header">
                    <span>üïê Letzte Suchen</span>
                    <button class="search-history-clear" onclick="clearSearchHistory()">Alle l√∂schen</button>
                </div>
            `;
            
            history.forEach((item, index) => {
                const selected = index === searchHistorySelectedIndex ? ' selected' : '';
                html += `
                    <div class="search-history-item${selected}" 
                         data-index="${index}"
                         data-term="${escapeHtml(item.term)}">
                        <span class="search-history-text">${escapeHtml(item.term)}</span>
                        <span class="search-history-count">${item.count} Treffer</span>
                        <button class="search-history-delete" 
                                onclick="event.stopPropagation(); removeFromSearchHistory('${escapeHtml(item.term).replace(/'/g, "\\'")}')">‚úï</button>
                    </div>
                `;
            });
            
            dropdown.innerHTML = html;
            
            // Click-Handler f√ºr Items
            dropdown.querySelectorAll('.search-history-item').forEach(item => {
                item.addEventListener('click', () => {
                    const term = item.dataset.term;
                    elements.searchInput.value = term;
                    hideSearchHistoryDropdown();
                    performSearch();
                });
            });
        }
        
        function showSearchHistoryDropdown() {
            const dropdown = document.getElementById('searchHistoryDropdown');
            const history = getSearchHistory();
            
            if (history.length === 0) return;
            
            searchHistorySelectedIndex = -1;
            renderSearchHistoryDropdown(elements.searchInput.value);
            dropdown.classList.add('show');
        }
        
        function hideSearchHistoryDropdown() {
            const dropdown = document.getElementById('searchHistoryDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
            }
            searchHistorySelectedIndex = -1;
        }
        
        function navigateSearchHistory(direction) {
            const history = getSearchHistory();
            const filterText = elements.searchInput.value;
            const filtered = filterText 
                ? history.filter(item => item.term.toLowerCase().includes(filterText.toLowerCase()))
                : history;
            
            if (filtered.length === 0) return;
            
            if (direction === 'down') {
                searchHistorySelectedIndex = Math.min(searchHistorySelectedIndex + 1, filtered.length - 1);
            } else if (direction === 'up') {
                searchHistorySelectedIndex = Math.max(searchHistorySelectedIndex - 1, -1);
            }
            
            renderSearchHistoryDropdown(filterText);
            
            // Bei Auswahl den Text ins Feld setzen
            if (searchHistorySelectedIndex >= 0 && filtered[searchHistorySelectedIndex]) {
                elements.searchInput.value = filtered[searchHistorySelectedIndex].term;
            }
        }

        // ==================== State ====================
        /** @type {AppState} */
        const state = {
            file1: {
                name: null,
                workbook: null,
                sheets: [],
                selectedSheet: null,
                data: [],
                headers: [],
                filePath: null
            },
            file2: {
                name: null,
                workbook: null,
                sheets: [],
                selectedSheet: null,
                data: [],
                headers: [],
                filePath: null
            },
            mapping: {
                sourceColumns: [],
                targetStartColumn: 1,
                duplicateCheckColumn: 0
            },
            selectedRow: null,
            selectedRows: [],
            searchResults: [],
            history: [],
            transferQueue: [],
            template: {
                name: null,
                data: null
            },
            lastDirectoryHandle: null,
            // Pagination f√ºr Suchergebnisse
            searchPagination: {
                currentPage: 1,
                pageSize: 100,
                pageSizeOptions: [50, 100, 250, 500]
            },
            // Arbeitsordner
            workingDirectory: null
        };
        
        // ==================== DOM Elements ====================
        const elements = {
            // Working Directory
            btnSelectWorkingDir: document.getElementById('btnSelectWorkingDir'),
            workingDirInfo: document.getElementById('workingDirInfo'),
            btnClearWorkingDir: document.getElementById('btnClearWorkingDir'),
            
            // File 1
            btnLoadFile1: document.getElementById('btnLoadFile1'),
            fileInput1: document.getElementById('fileInput1'),
            file1Info: document.getElementById('file1Info'),
            selectSheet1: document.getElementById('selectSheet1'),
            
            // File 2
            btnLoadFile2: document.getElementById('btnLoadFile2'),
            fileInput2: document.getElementById('fileInput2'),
            file2Info: document.getElementById('file2Info'),
            selectSheet2: document.getElementById('selectSheet2'),
            
            // Mapping
            btnConfigMapping: document.getElementById('btnConfigMapping'),
            mappingInfo: document.getElementById('mappingInfo'),
            mappingModal: document.getElementById('mappingModal'),
            mappingList: document.getElementById('mappingList'),
            
            // Search
            searchInput: document.getElementById('searchInput'),
            searchHistoryDropdown: document.getElementById('searchHistoryDropdown'),
            btnSearch: document.getElementById('btnSearch'),
            btnNewRow: document.getElementById('btnNewRow'),
            searchResultsInfo: document.getElementById('searchResultsInfo'),
            
            // New Row
            newRowPanel: document.getElementById('newRowPanel'),
            newRowForm: document.getElementById('newRowForm'),
            newRowFlag: document.getElementById('newRowFlag'),
            newRowComment: document.getElementById('newRowComment'),
            btnCloseNewRow: document.getElementById('btnCloseNewRow'),
            btnAddNewRowToQueue: document.getElementById('btnAddNewRowToQueue'),
            btnTransferNewRowDirect: document.getElementById('btnTransferNewRowDirect'),
            newRowStatus: document.getElementById('newRowStatus'),
            
            // Results
            emptyState: document.getElementById('emptyState'),
            resultsTableContainer: document.getElementById('resultsTableContainer'),
            resultsTable: document.getElementById('resultsTable'),
            resultsTableHead: document.getElementById('resultsTableHead'),
            resultsTableBody: document.getElementById('resultsTableBody'),
            
            // Transfer
            transferPanel: document.getElementById('transferPanel'),
            transferFlag: document.getElementById('transferFlag'),
            transferComment: document.getElementById('transferComment'),
            btnAddToQueue: document.getElementById('btnAddToQueue'),
            btnTransferDirect: document.getElementById('btnTransferDirect'),
            btnSelectAll: document.getElementById('btnSelectAll'),
            btnDeselectAll: document.getElementById('btnDeselectAll'),
            transferStatus: document.getElementById('transferStatus'),
            
            // Queue
            queuePanel: document.getElementById('queuePanel'),
            queueList: document.getElementById('queueList'),
            queueCount: document.getElementById('queueCount'),
            btnClearQueue: document.getElementById('btnClearQueue'),
            btnExportPS: document.getElementById('btnExportPS'),
            btnPreviewTransfer: document.getElementById('btnPreviewTransfer'),
            btnNewMonth: document.getElementById('btnNewMonth'),
            btnDataExplorer: document.getElementById('btnDataExplorer'),
            
            // Diff Preview Modal
            diffPreviewModal: document.getElementById('diffPreviewModal'),
            
            // Template
            btnLoadTemplate: document.getElementById('btnLoadTemplate'),
            btnCreateTemplate: document.getElementById('btnCreateTemplate'),
            templateInput: document.getElementById('templateInput'),
            templateInfo: document.getElementById('templateInfo'),
            
            // Create Template Modal
            createTemplateModal: document.getElementById('createTemplateModal'),
            createTemplateSourceName: document.getElementById('createTemplateSourceName'),
            createTemplateSheetList: document.getElementById('createTemplateSheetList'),
            
            // New Month Modal
            newMonthModal: document.getElementById('newMonthModal'),
            newMonthFilename: document.getElementById('newMonthFilename'),
            newMonthTemplateName: document.getElementById('newMonthTemplateName'),
            
            // History
            historyList: document.getElementById('historyList'),
            
            // Config
            btnExportConfig: document.getElementById('btnExportConfig'),
            btnImportConfig: document.getElementById('btnImportConfig'),
            configInput: document.getElementById('configInput'),
            
            // Data Explorer
            dataExplorerModal: document.getElementById('dataExplorerModal'),
            explorerFileName: document.getElementById('explorerFileName'),
            explorerSheetSelect: document.getElementById('explorerSheetSelect'),
            explorerSearch: document.getElementById('explorerSearch'),
            explorerResultCount: document.getElementById('explorerResultCount'),
            explorerStatus: document.getElementById('explorerStatus'),
            explorerTableHead: document.getElementById('explorerTableHead'),
            explorerTableBody: document.getElementById('explorerTableBody'),
            btnExplorerExport: document.getElementById('btnExplorerExport'),
            btnExplorerOpenFile: document.getElementById('btnExplorerOpenFile'),
            btnExplorerSearch: document.getElementById('btnExplorerSearch'),
            btnExplorerPreview: document.getElementById('btnExplorerPreview'),
            btnExplorerFullscreen: document.getElementById('btnExplorerFullscreen'),
            btnCloseExplorerX: document.getElementById('btnCloseExplorerX'),
            btnCloseExplorerFooter: document.getElementById('btnCloseExplorerFooter'),
            btnToggleColumns: document.getElementById('btnToggleColumns'),
            btnShowAllColumns: document.getElementById('btnShowAllColumns'),
            btnHideAllColumns: document.getElementById('btnHideAllColumns'),
            btnAddExplorerFilter: document.getElementById('btnAddExplorerFilter'),
            btnClearExplorerFilters: document.getElementById('btnClearExplorerFilters'),
            explorerDropZone: document.getElementById('explorerDropZone'),
            explorerPageSize: document.getElementById('explorerPageSize'),
            btnExplorerFirstPage: document.getElementById('btnExplorerFirstPage'),
            btnExplorerPrevPage: document.getElementById('btnExplorerPrevPage'),
            btnExplorerNextPage: document.getElementById('btnExplorerNextPage'),
            btnExplorerLastPage: document.getElementById('btnExplorerLastPage'),
            
            // Data Join Modal
            dataJoinModal: document.getElementById('dataJoinModal'),
            btnDataJoin: document.getElementById('btnDataJoin'),
            btnCloseDataJoin: document.getElementById('btnCloseDataJoin'),
            btnJoinSelectFile: document.getElementById('btnJoinSelectFile'),
            joinSourceFileName: document.getElementById('joinSourceFileName'),
            joinSourceSheet: document.getElementById('joinSourceSheet'),
            joinTargetKeyColumn: document.getElementById('joinTargetKeyColumn'),
            joinSourceKeyColumn: document.getElementById('joinSourceKeyColumn'),
            joinColumnsContainer: document.getElementById('joinColumnsContainer'),
            joinInsertAfterKey: document.getElementById('joinInsertAfterKey'),
            joinMarkNotFound: document.getElementById('joinMarkNotFound'),
            joinPreviewContainer: document.getElementById('joinPreviewContainer'),
            joinStatTargetRows: document.getElementById('joinStatTargetRows'),
            joinStatSourceRows: document.getElementById('joinStatSourceRows'),
            joinStatMatches: document.getElementById('joinStatMatches'),
            joinStatNoMatch: document.getElementById('joinStatNoMatch'),
            btnCancelDataJoin: document.getElementById('btnCancelDataJoin'),
            btnPreviewDataJoin: document.getElementById('btnPreviewDataJoin'),
            btnExecuteDataJoin: document.getElementById('btnExecuteDataJoin'),
            
            // Help
            btnHelp: document.getElementById('btnHelp'),
            helpModal: document.getElementById('helpModal')
        };

        // ==================== Utility Functions ====================
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ==================== Local Storage ====================
        const STORAGE_KEY = 'mvmcVertragslistenConfig';
        const LAST_EXPORT_KEY = 'mvmcVertragslistenLastExport';
        const DB_NAME = 'MVMCVertragsListenDB';
        const DB_VERSION = 1;
        let db = null;
        
        // ==================== Helper Functions ====================
        function showStatus(element, message, type = 'info') {
            if (!element) return;
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
            // Auto-clear after 10 seconds for success messages
            if (type === 'success') {
                setTimeout(() => {
                    if (element.querySelector('.status.success')) {
                        element.innerHTML = '';
                    }
                }, 10000);
            }
        }
        
        // Im Electron-Modus werden Datei-Downloads via electronAPI gehandhabt
        
        function updateWorkbook() {
            // Im Electron-Modus nicht ben√∂tigt - √Ñnderungen gehen direkt in die Datei
            return;
        }
        
        // Formatiert Datum und Uhrzeit f√ºr History-Eintr√§ge
        function formatHistoryDateTime() {
            const now = new Date();
            const date = now.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: '2-digit' });
            const time = now.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            return `${date} ${time}`;
        }
        
        function updateHistoryDisplay() {
            if (!elements.historyList) return;
            
            if (state.history.length === 0) {
                elements.historyList.innerHTML = `

                    <div style="color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px;">
                        Noch keine √úbertragungen
                    </div>`;
                return;
            }
            
            let html = '';
            state.history.forEach(entry => {
                html += `
                    <div class="history-item">
                        <span><strong>[${entry.flag}]</strong> ${escapeHtml(entry.preview || entry.searchValue || '')}</span>
                        <span class="history-time">${entry.time}</span>
                    </div>`;
            });
            elements.historyList.innerHTML = html;
        }
        
        // IndexedDB f√ºr gro√üe Dateien
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const database = event.target.result;
                    if (!database.objectStoreNames.contains('files')) {
                        database.createObjectStore('files', { keyPath: 'id' });
                    }
                    if (!database.objectStoreNames.contains('config')) {
                        database.createObjectStore('config', { keyPath: 'id' });
                    }
                };
            });
        }
        
        function saveToIndexedDB(storeName, id, data) {
            return new Promise((resolve, reject) => {
                if (!db) { reject('DB not initialized'); return; }
                const transaction = db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put({ id, data, timestamp: Date.now() });
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }
        
        function loadFromIndexedDB(storeName, id) {
            return new Promise((resolve, reject) => {
                if (!db) { reject('DB not initialized'); return; }
                const transaction = db.transaction(storeName, 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(id);
                request.onsuccess = () => resolve(request.result?.data);
                request.onerror = () => reject(request.error);
            });
        }
        
        function saveConfig() {
            const config = {
                file1SheetName: state.file1.selectedSheet,
                file2SheetName: state.file2.selectedSheet,
                mapping: state.mapping,
                history: state.history.slice(-100),  // Keep last 100 entries
                // Extra-Spalten Konfiguration
                extraColumns: {
                    enableFlag: isFlagEnabled(),
                    enableComment: isCommentEnabled(),
                    flagColumn: getFlagColumn(),
                    flagValues: getFlagValues().join(','),
                    commentColumn: getCommentColumn(),
                    commentPlaceholder: getCommentPlaceholder()
                }
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
        }
        
        function loadConfig() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const config = JSON.parse(saved);
                    state.mapping = config.mapping || state.mapping;
                    state.history = config.history || [];
                    
                    // Extra-Spalten Konfiguration laden
                    if (config.extraColumns) {
                        const ec = config.extraColumns;
                        if (ec.enableFlag !== undefined) {
                            document.getElementById('enableFlagColumn').checked = ec.enableFlag;
                            localStorage.setItem('excelSyncEnableFlag', String(ec.enableFlag));
                        }
                        if (ec.enableComment !== undefined) {
                            document.getElementById('enableCommentColumn').checked = ec.enableComment;
                            localStorage.setItem('excelSyncEnableComment', String(ec.enableComment));
                        }
                        if (ec.flagValues) {
                            document.getElementById('flagValues').value = ec.flagValues;
                            localStorage.setItem('excelSyncFlagValues', ec.flagValues);
                        }
                        if (ec.commentPlaceholder) {
                            document.getElementById('commentPlaceholder').value = ec.commentPlaceholder;
                            localStorage.setItem('excelSyncCommentPlaceholder', ec.commentPlaceholder);
                        }
                        // UI aktualisieren
                        updateFlagDropdownOptions();
                        updateCommentPlaceholders();
                        updateFlagCommentVisibility();
                        updateColumnDisplays();
                    }
                    
                    updateHistoryDisplay();
                    return config;
                }
            } catch (e) {
                console.error('Error loading config:', e);
            }
            return null;
        }
        
        async function exportConfig() {
            const config = {
                file1SheetName: state.file1.selectedSheet,
                file2SheetName: state.file2.selectedSheet,
                mapping: state.mapping,
                exportDate: new Date().toISOString(),
                // Extra-Spalten Konfiguration
                extraColumns: {
                    enableFlag: isFlagEnabled(),
                    enableComment: isCommentEnabled(),
                    flagColumn: getFlagColumn(),
                    flagValues: getFlagValues().join(','),
                    commentColumn: getCommentColumn(),
                    commentPlaceholder: getCommentPlaceholder()
                }
            };
            
            // Im Electron-Modus: Nur Mapping und Dateipfade speichern
            if (state.file1.filePath) {
                config.file1Path = state.file1.filePath;
                config.file1Name = state.file1.name;
            }
            if (state.file2.filePath) {
                config.file2Path = state.file2.filePath;
                config.file2Name = state.file2.name;
            }
            // Template-Pfad speichern
            if (state.template.filePath) {
                config.templatePath = state.template.filePath;
                config.templateName = state.template.name;
            }
            
            // Template speichern (falls vorhanden) - f√ºr Browser-Modus als Base64
            if (state.template.data) {
                config.templateData = state.template.data;
                config.templateName = state.template.name;
            }
            
            // In IndexedDB speichern (f√ºr gro√üe Dateien)
            if (db) {
                saveToIndexedDB('config', 'lastExport', config)
                    .then(() => console.log('Konfig in IndexedDB gespeichert'))
                    .catch(e => console.error('IndexedDB Fehler:', e));
            }
            
            // Kleine Konfig (ohne Dateien) auch in LocalStorage f√ºr Fallback
            const configSmall = { ...config };
            delete configSmall.file1Data;
            delete configSmall.file2Data;
            try {
                localStorage.setItem(LAST_EXPORT_KEY, JSON.stringify(configSmall));
            } catch (e) {
                console.warn('LocalStorage Fehler:', e);
            }
            
            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            
            // Electron-Modus: Verwende Electron-API zum Speichern
            try {
                const savePath = await window.electronAPI.saveFileDialog({
                    title: 'Konfiguration speichern',
                    defaultPath: getWorkingDirectoryPath() ? (getWorkingDirectoryPath() + '/config.json') : 'config.json',
                    filters: [{ name: 'JSON Dateien', extensions: ['json'] }]
                });
                if (savePath) {
                    const result = await window.electronAPI.saveConfig(savePath, config);
                    if (result && result.success === false) {
                        showStatus(elements.transferStatus, `‚ö†Ô∏è ${result.error}`, 'error');
                        alert(`‚ùå Speichern fehlgeschlagen:\n\n${result.error}`);
                    } else {
                        // Zeige Info √ºber Computer-Abschnitt
                        let statusMsg = `‚úì config.json gespeichert: ${savePath}`;
                        if (result.savedToSection) {
                            if (result.convertedToNested) {
                                statusMsg = `‚úì Config f√ºr "${result.savedToSection}" gespeichert (Datei wurde f√ºr Mehrbenutzer konvertiert)`;
                            } else {
                                statusMsg = `‚úì Config f√ºr "${result.savedToSection}" gespeichert`;
                            }
                        }
                        showStatus(elements.transferStatus, statusMsg, 'success');
                    }
                }
            } catch (e) {
                console.error('Fehler beim Speichern:', e);
                showStatus(elements.transferStatus, `Fehler: ${e.message}`, 'error');
                alert(`‚ùå Speichern fehlgeschlagen:\n\n${e.message}`);
            }
        }
        
        function importConfig(file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const config = JSON.parse(e.target.result);
                    state.mapping = config.mapping || state.mapping;
                    
                    // Extra-Spalten Konfiguration importieren
                    if (config.extraColumns) {
                        const ec = config.extraColumns;
                        if (ec.enableFlag !== undefined) {
                            document.getElementById('enableFlagColumn').checked = ec.enableFlag;
                            localStorage.setItem('excelSyncEnableFlag', String(ec.enableFlag));
                        }
                        if (ec.enableComment !== undefined) {
                            document.getElementById('enableCommentColumn').checked = ec.enableComment;
                            localStorage.setItem('excelSyncEnableComment', String(ec.enableComment));
                        }
                        if (ec.flagValues) {
                            document.getElementById('flagValues').value = ec.flagValues;
                            localStorage.setItem('excelSyncFlagValues', ec.flagValues);
                        }
                        if (ec.commentPlaceholder) {
                            document.getElementById('commentPlaceholder').value = ec.commentPlaceholder;
                            localStorage.setItem('excelSyncCommentPlaceholder', ec.commentPlaceholder);
                        }
                        // UI aktualisieren
                        updateFlagDropdownOptions();
                        updateCommentPlaceholders();
                        updateFlagCommentVisibility();
                    }
                    
                    // Speichere in IndexedDB (kann gro√üe Dateien speichern)
                    if (db) {
                        try {
                            await saveToIndexedDB('config', 'lastExport', config);
                            console.log('Importierte Konfig in IndexedDB gespeichert');
                        } catch (dbErr) {
                            console.warn('IndexedDB Fehler:', dbErr);
                        }
                    }
                    
                    // Fallback: Speichere auch in LocalStorage (ohne Dateiinhalt wenn zu gro√ü)
                    try {
                        localStorage.setItem(LAST_EXPORT_KEY, e.target.result);
                    } catch (lsErr) {
                        // LocalStorage zu klein - speichere ohne Dateien
                        const smallConfig = { ...config };
                        delete smallConfig.file1Data;
                        delete smallConfig.file2Data;
                        localStorage.setItem(LAST_EXPORT_KEY, JSON.stringify(smallConfig));
                        console.log('LocalStorage zu klein f√ºr Dateien, nur Mapping gespeichert');
                    }
                    
                    // Lade eingebettete Excel-Dateien
                    if (config.file1Data) {
                        await loadWorkbookFromBase64(config.file1Data, config.file1Name, 1, config.file1SheetName);
                    } else if (config.file1SheetName) {
                        state.file1.pendingSheet = config.file1SheetName;
                        elements.file1Info.textContent = `‚è≥ Arbeitsblatt: ${config.file1SheetName}`;
                        elements.file1Info.style.color = 'var(--warning)';
                    }
                    
                    if (config.file2Data) {
                        await loadWorkbookFromBase64(config.file2Data, config.file2Name, 2, config.file2SheetName);
                    } else if (config.file2SheetName) {
                        state.file2.pendingSheet = config.file2SheetName;
                        elements.file2Info.textContent = `‚è≥ Arbeitsblatt: ${config.file2SheetName}`;
                        elements.file2Info.style.color = 'var(--warning)';
                    }
                    
                    // Template laden (falls vorhanden)
                    if (config.templateData) {
                        state.template.data = config.templateData;
                        state.template.name = config.templateName;
                        elements.templateInfo.textContent = config.templateName;
                        elements.btnNewMonth.disabled = false;
                    }
                    
                    updateMappingInfo();
                    updateMappingPreview();
                    saveConfig();
                    
                    // Zeige geladene Konfig-Details
                    const date = config.exportDate ? new Date(config.exportDate).toLocaleString('de-DE') : 'unbekannt';
                    const mappingCount = state.mapping.sourceColumns?.length || 0;
                    const filesIncluded = (config.file1Data ? 1 : 0) + (config.file2Data ? 1 : 0);

                    showStatus(elements.transferStatus, 
                        `‚úì Konfiguration importiert! (${mappingCount} Spalten, ${filesIncluded} Datei(en), vom ${date})`, 'success');

                    elements.mappingInfo.textContent = `${mappingCount} Spalte(n) konfiguriert`;
                    
                } catch (err) {
                    showStatus(elements.transferStatus, 'Fehler beim Importieren: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
        }
        
        // ==================== File Loading (Electron-Modus) ====================
        // Dateien werden √ºber electronAPI.openFileDialog() geladen
        // Die Browser-Funktionen loadFile(), processFile(), loadWorkbookFromBase64() wurden entfernt
        // selectSheet1/2 im Browser-Modus wurden entfernt (XLSX-basiert)
        
        function checkReadyState() {
            const hasFile1 = state.file1.filePath;
            const hasFile2 = state.file2.filePath;
            const bothLoaded = hasFile1 && hasFile2;
            
            // Mapping-Button nur deaktivieren wenn KEINE Konfig geladen AND kein Dateien
            const hasMapping = state.mapping.sourceColumns && state.mapping.sourceColumns.length > 0;
            elements.btnConfigMapping.disabled = !bothLoaded && !hasMapping;
            
            elements.searchInput.disabled = !state.file1.selectedSheet;
            elements.btnSearch.disabled = !state.file1.selectedSheet;
            
            // "Neue Zeile" Button aktivieren wenn Mapping vorhanden und Datei 2 geladen
            elements.btnNewRow.disabled = !hasMapping || !hasFile2;
            
            // Datenexplorer ist immer aktiviert (kann eigene Dateien √∂ffnen)
            elements.btnDataExplorer.disabled = false;
            
            updateMappingInfo();
            updateMappingPreview();
        }
        
        function updateMappingPreview() {
            const preview = document.getElementById('mappingPreview');
            if (!preview) return;
            
            if (!state.mapping.sourceColumns || state.mapping.sourceColumns.length === 0) {
                preview.innerHTML = '';
                return;
            }
            
            let html = '<strong>Aktuelle Konfig:</strong><br>';
            html += `Start-Spalte: ${getColumnLetter(getDataStartColumn())}<br>`;
            html += `Duplikat-Check: Spalte ${state.mapping.duplicateCheckColumn + 1}<br>`;
            html += `Spalten: ${state.mapping.sourceColumns.length}`;
            
            preview.innerHTML = html;
        }
        
        function updateMappingInfo() {
            const hasFile1 = state.file1.filePath;
            const hasFile2 = state.file2.filePath;
            
            if (!hasFile1 || !hasFile2) {
                if (state.mapping.sourceColumns && state.mapping.sourceColumns.length > 0) {
                    elements.mappingInfo.textContent = `${state.mapping.sourceColumns.length} Spalte(n) konfiguriert (Dateien laden)`;
                    elements.mappingInfo.style.color = 'var(--warning)';
                } else {
                    elements.mappingInfo.textContent = 'Laden Sie beide Dateien';
                    elements.mappingInfo.style.color = '';
                }
                return;
            }
            
            elements.mappingInfo.style.color = '';
            if (state.mapping.sourceColumns.length === 0) {
                elements.mappingInfo.textContent = 'Klicken Sie auf "Spalten konfigurieren"';
            } else {
                elements.mappingInfo.textContent = `${state.mapping.sourceColumns.length} Spalte(n) konfiguriert ‚úì`;
            }
        }
        
        function openMappingModal() {
            elements.mappingModal.classList.remove('hidden');
            renderMappingList();
        }
        
        function closeMappingModal() {
            elements.mappingModal.classList.add('hidden');
        }
        
        function renderMappingList() {
            elements.mappingList.innerHTML = '';
            
            // If no mappings yet, add all columns by default (skip first column - usually row numbers)
            if (state.mapping.sourceColumns.length === 0 && state.file1.headers.length > 1) {
                state.mapping.sourceColumns = state.file1.headers.slice(1).map((_, i) => i + 1);
            } else if (state.mapping.sourceColumns.length === 0 && state.file1.headers.length === 1) {
                state.mapping.sourceColumns = [0];
            }
            
            // Populate duplicate check column dropdown
            const dupSelect = document.getElementById('duplicateCheckColumn');
            dupSelect.innerHTML = '';
            state.file1.headers.forEach((header, idx) => {
                const option = document.createElement('option');
                option.value = idx;
                option.textContent = `${getColumnLetter(idx + 1)}: ${header || '(leer)'}`;
                if (idx === state.mapping.duplicateCheckColumn) option.selected = true;
                dupSelect.appendChild(option);
            });
            
            state.mapping.sourceColumns.forEach((colIndex, i) => {
                const item = document.createElement('div');
                item.className = 'mapping-item';
                
                const select = document.createElement('select');
                state.file1.headers.forEach((header, idx) => {
                    const option = document.createElement('option');
                    option.value = idx;
                    option.textContent = `${getColumnLetter(idx + 1)}: ${header || '(leer)'}`;
                    if (idx === colIndex) option.selected = true;
                    select.appendChild(option);
                });
                select.addEventListener('change', () => {
                    state.mapping.sourceColumns[i] = parseInt(select.value);
                });
                
                const arrow = document.createElement('span');
                arrow.className = 'mapping-arrow';
                arrow.textContent = '‚Üí';
                
                const target = document.createElement('span');
                target.className = 'mapping-target';
                const targetCol = getDataStartColumn() + i;
                target.textContent = `Spalte ${getColumnLetter(targetCol)} in Datei 2`;
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'mapping-remove';
                removeBtn.textContent = '‚úï';
                removeBtn.onclick = () => {
                    state.mapping.sourceColumns.splice(i, 1);
                    renderMappingList();
                };
                
                item.appendChild(select);
                item.appendChild(arrow);
                item.appendChild(target);
                item.appendChild(removeBtn);
                elements.mappingList.appendChild(item);
            });
            
            // Update column displays
            updateColumnDisplays();
        }
        
        function addMappingColumn() {
            const nextCol = state.mapping.sourceColumns.length;
            if (nextCol < state.file1.headers.length) {
                state.mapping.sourceColumns.push(nextCol);
                renderMappingList();
            }
        }
        
        function saveMapping() {
            state.mapping.duplicateCheckColumn = parseInt(document.getElementById('duplicateCheckColumn').value);
            saveConfig();
            updateMappingInfo();
            closeMappingModal();
        }
        
        function getColumnLetter(num) {
            let result = '';
            while (num > 0) {
                num--;
                result = String.fromCharCode(65 + (num % 26)) + result;
                num = Math.floor(num / 26);
            }
            return result;
        }
        
        // ==================== Search Functions ====================
        function wildcardToRegex(pattern) {
            let escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            escaped = escaped.replace(/\*/g, '.*');
            escaped = escaped.replace(/\?/g, '.');
            return new RegExp('^' + escaped + '$', 'i');
        }
        
        /**
         * Pr√ºft ob ein Text einem Suchterm entspricht (mit Platzhalter-Unterst√ºtzung)
         */
        function matchesTerm(text, term, hasWildcards) {
            if (!text) return false;
            const str = String(text);
            if (hasWildcards) {
                return wildcardToRegex(term).test(str);
            }
            return str.toLowerCase().includes(term.toLowerCase());
        }
        
        /**
         * Parst eine Suchanfrage mit AND/OR Operatoren
         * Beispiele: "Projekt AND 2025", "Alpha OR Beta", "Item AND (2024 OR 2025)"
         */
        function parseSearchQuery(query) {
            const trimmed = query.trim();
            
            // Pr√ºfen ob AND oder OR Operatoren vorhanden sind
            const hasAnd = / AND /i.test(trimmed);
            const hasOr = / OR /i.test(trimmed);
            
            if (!hasAnd && !hasOr) {
                // Einfache Suche
                return { type: 'simple', term: trimmed };
            }
            
            if (hasAnd && !hasOr) {
                // Nur AND
                const terms = trimmed.split(/ AND /i).map(t => t.trim()).filter(t => t);
                return { type: 'and', terms };
            }
            
            if (hasOr && !hasAnd) {
                // Nur OR
                const terms = trimmed.split(/ OR /i).map(t => t.trim()).filter(t => t);
                return { type: 'or', terms };
            }
            
            // Gemischt: OR hat niedrigere Priorit√§t, AND wird zuerst ausgewertet
            // "A AND B OR C AND D" ‚Üí (A AND B) OR (C AND D)
            const orParts = trimmed.split(/ OR /i).map(part => {
                const andTerms = part.split(/ AND /i).map(t => t.trim()).filter(t => t);
                if (andTerms.length === 1) {
                    return { type: 'simple', term: andTerms[0] };
                }
                return { type: 'and', terms: andTerms };
            });
            
            return { type: 'or', parts: orParts };
        }
        
        /**
         * Pr√ºft ob eine Zeile der geparsten Suchanfrage entspricht
         */
        function rowMatchesQuery(row, parsed) {
            const rowStr = row.join(' ').toLowerCase();
            
            function termHasWildcards(term) {
                return term.includes('*') || term.includes('?');
            }
            
            function rowContainsTerm(term) {
                const hasWc = termHasWildcards(term);
                for (const cell of row) {
                    if (matchesTerm(cell, term, hasWc)) return true;
                }
                return false;
            }
            
            if (parsed.type === 'simple') {
                return rowContainsTerm(parsed.term);
            }
            
            if (parsed.type === 'and') {
                // Alle Terme m√ºssen in der Zeile vorkommen
                return parsed.terms.every(term => rowContainsTerm(term));
            }
            
            if (parsed.type === 'or') {
                if (parsed.terms) {
                    // Einfache OR-Verkn√ºpfung
                    return parsed.terms.some(term => rowContainsTerm(term));
                }
                if (parsed.parts) {
                    // Gemischte Anfrage mit AND-Gruppen
                    return parsed.parts.some(part => rowMatchesQuery(row, part));
                }
            }
            
            return false;
        }
        
        function search() {
            const query = elements.searchInput.value.trim();
            if (!query || !state.file1.data.length) return;
            
            const hasWildcards = query.includes('*') || query.includes('?');
            const hasOperators = / (AND|OR) /i.test(query);
            state.searchResults = [];
            
            if (hasOperators) {
                // Erweiterte Suche mit AND/OR
                const parsed = parseSearchQuery(query);
                state.file1.data.forEach((row, rowIndex) => {
                    if (rowMatchesQuery(row, parsed)) {
                        state.searchResults.push({ rowIndex: rowIndex, data: row });
                    }
                });
            } else if (hasWildcards) {
                const regex = wildcardToRegex(query);
                state.file1.data.forEach((row, rowIndex) => {
                    for (let col of row) {
                        if (col && regex.test(String(col))) {
                            state.searchResults.push({ rowIndex: rowIndex, data: row });
                            break;
                        }
                    }
                });
            } else {
                const lowerQuery = query.toLowerCase();
                state.file1.data.forEach((row, rowIndex) => {
                    for (let col of row) {
                        if (col && String(col).toLowerCase().includes(lowerQuery)) {
                            state.searchResults.push({ rowIndex: rowIndex, data: row });
                            break;
                        }
                    }
                });
            }
            
            // Such-Historie aktualisieren
            addToSearchHistory(query, state.searchResults.length);
            hideSearchHistoryDropdown();
            
            displaySearchResults(query, hasWildcards || hasOperators);
        }
        
        function displaySearchResults(query, hasWildcards = false) {
            state.selectedRows = [];
            state.searchPagination.currentPage = 1; // Bei neuer Suche zur ersten Seite
            
            if (state.searchResults.length === 0) {
                elements.searchResultsInfo.innerHTML = `Keine Treffer f√ºr "<strong>${escapeHtml(query)}</strong>"`;
                elements.emptyState.style.display = 'flex';
                elements.resultsTableContainer.style.display = 'none';
                elements.transferPanel.classList.add('hidden');
                document.getElementById('searchPagination').style.display = 'none';
                return;
            }
            
            renderSearchResultsPage(query, hasWildcards);
        }
        
        function renderSearchResultsPage(query = '', hasWildcards = false) {
            const totalResults = state.searchResults.length;
            const pageSize = state.searchPagination.pageSize;
            const totalPages = Math.max(1, Math.ceil(totalResults / pageSize));
            
            // Sicherstellen, dass currentPage g√ºltig ist
            if (state.searchPagination.currentPage > totalPages) {
                state.searchPagination.currentPage = totalPages;
            }
            if (state.searchPagination.currentPage < 1) {
                state.searchPagination.currentPage = 1;
            }
            
            const startIndex = (state.searchPagination.currentPage - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, totalResults);
            const pageResults = state.searchResults.slice(startIndex, endIndex);
            
            const wildcardInfo = hasWildcards ? ' (Platzhalter)' : '';
            if (totalResults > pageSize) {
                elements.searchResultsInfo.innerHTML = 
                    `Zeige <strong>${startIndex + 1}-${endIndex}</strong> von <strong>${totalResults}</strong> Treffern f√ºr "<strong>${escapeHtml(query)}</strong>"${wildcardInfo}`;
            } else {
                elements.searchResultsInfo.innerHTML = 
                    `<strong>${totalResults}</strong> Treffer f√ºr "<strong>${escapeHtml(query)}</strong>"${wildcardInfo}`;
            }
            
            elements.emptyState.style.display = 'none';
            elements.resultsTableContainer.style.display = 'block';
            
            let headerHtml = '<tr><th style="width: 40px;"><input type="checkbox" id="selectAllCheckbox" title="Alle auf dieser Seite ausw√§hlen"></th>';
            state.file1.headers.forEach((header, i) => {
                headerHtml += `<th>${escapeHtml(header || `Spalte ${getColumnLetter(i + 1)}`)}</th>`;
            });
            headerHtml += '</tr>';
            elements.resultsTableHead.innerHTML = headerHtml;
            
            // Nur die aktuelle Seite rendern
            let bodyHtml = '';
            pageResults.forEach((result, pageIndex) => {
                const globalIndex = startIndex + pageIndex;
                bodyHtml += `<tr data-index="${globalIndex}">`;
                bodyHtml += `<td><input type="checkbox" class="row-checkbox" data-index="${globalIndex}" onclick="event.stopPropagation()"></td>`;
                state.file1.headers.forEach((_, colIndex) => {
                    const cell = result.data[colIndex];
                    const cellStr = String(cell ?? '');
                    bodyHtml += `<td contenteditable="true" data-row="${globalIndex}" data-col="${colIndex}" data-original="${escapeHtml(cellStr)}" onclick="event.stopPropagation()">${escapeHtml(cellStr)}</td>`;
                });
                bodyHtml += '</tr>';
            });
            elements.resultsTableBody.innerHTML = bodyHtml;
            
            document.querySelectorAll('#resultsTableBody td[contenteditable]').forEach(td => {
                // Speichere den letzten bekannten Wert f√ºr Undo
                td.dataset.lastValue = td.textContent;
                
                td.addEventListener('blur', function() {
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    const original = this.dataset.original;
                    const lastValue = this.dataset.lastValue;
                    const current = this.textContent;
                    
                    // Nur Undo speichern wenn sich der Wert ge√§ndert hat
                    if (lastValue !== current) {
                        pushSearchUndo({
                            rowIndex,
                            colIndex,
                            oldValue: lastValue,
                            newValue: current,
                            originalValue: original
                        });
                        // Daten im State aktualisieren
                        state.searchResults[rowIndex].data[colIndex] = current;
                        this.dataset.lastValue = current;
                    }
                    
                    this.classList.toggle('edited', original !== current);
                });
                
                td.addEventListener('input', function() {
                    const original = this.dataset.original;
                    const current = this.textContent;
                    this.classList.toggle('edited', original !== current);
                });
                
                td.addEventListener('focus', function() {
                    const rowIndex = parseInt(this.dataset.row);
                    if (!state.selectedRows.includes(rowIndex)) {
                        toggleRowSelection(rowIndex, true);
                    }
                });
            });
            
            document.getElementById('selectAllCheckbox').addEventListener('change', (e) => {
                selectAllRows(e.target.checked);
            });
            
            document.querySelectorAll('.row-checkbox').forEach(cb => {
                cb.addEventListener('change', (e) => {
                    toggleRowSelection(parseInt(e.target.dataset.index), e.target.checked);
                });
            });
            
            // Pagination UI aktualisieren
            updateSearchPagination(totalPages);
            
            // Erste Zeile auf der aktuellen Seite ausw√§hlen
            if (pageResults.length > 0) {
                toggleRowSelection(startIndex, true);
            }
            elements.transferPanel.classList.remove('hidden');
        }
        
        function updateSearchPagination(totalPages) {
            const paginationEl = document.getElementById('searchPagination');
            const pageInfoEl = document.getElementById('searchPageInfo');
            const firstBtn = document.getElementById('btnSearchFirstPage');
            const prevBtn = document.getElementById('btnSearchPrevPage');
            const nextBtn = document.getElementById('btnSearchNextPage');
            const lastBtn = document.getElementById('btnSearchLastPage');
            
            // Pagination nur anzeigen wenn mehr als eine Seite
            if (state.searchResults.length > state.searchPagination.pageSize) {
                paginationEl.style.display = 'flex';
                pageInfoEl.textContent = `Seite ${state.searchPagination.currentPage} von ${totalPages}`;
                
                // Buttons aktivieren/deaktivieren
                firstBtn.disabled = state.searchPagination.currentPage === 1;
                prevBtn.disabled = state.searchPagination.currentPage === 1;
                nextBtn.disabled = state.searchPagination.currentPage === totalPages;
                lastBtn.disabled = state.searchPagination.currentPage === totalPages;
            } else {
                paginationEl.style.display = 'none';
            }
        }
        
        function searchGoToPage(page) {
            const totalPages = Math.ceil(state.searchResults.length / state.searchPagination.pageSize);
            state.searchPagination.currentPage = Math.max(1, Math.min(page, totalPages));
            renderSearchResultsPage(elements.searchInput.value.trim());
            
            // Zum Tabellenanfang scrollen
            elements.resultsTableContainer.scrollTop = 0;
        }
        
        function searchChangePageSize(newSize) {
            state.searchPagination.pageSize = parseInt(newSize);
            state.searchPagination.currentPage = 1;
            renderSearchResultsPage(elements.searchInput.value.trim());
        }
        
        function getEditedRowData(rowIndex) {
            const cells = document.querySelectorAll(`#resultsTableBody td[data-row="${rowIndex}"]`);
            const data = [];
            cells.forEach(cell => {
                const colIndex = parseInt(cell.dataset.col);
                data[colIndex] = cell.textContent;
            });
            return data;
        }
        
        function isRowEdited(rowIndex) {
            const cells = document.querySelectorAll(`#resultsTableBody td[data-row="${rowIndex}"].edited`);
            return cells.length > 0;
        }
        
        function selectAllRows(selected) {
            const checkboxes = document.querySelectorAll('.row-checkbox');
            checkboxes.forEach(cb => {
                const index = parseInt(cb.dataset.index);
                toggleRowSelection(index, selected);
            });
        }
        
        function toggleRowSelection(index, forceState) {
            const checkbox = document.querySelector(`.row-checkbox[data-index="${index}"]`);
            const tr = document.querySelector(`#resultsTableBody tr[data-index="${index}"]`);
            if (!checkbox || !tr) return;
            
            const isSelected = forceState !== undefined ? forceState : !checkbox.checked;
            checkbox.checked = isSelected;
            tr.classList.toggle('selected', isSelected);
            
            if (isSelected) {
                if (!state.selectedRows.includes(index)) {
                    state.selectedRows.push(index);
                }
            } else {
                state.selectedRows = state.selectedRows.filter(i => i !== index);
            }
            
            document.getElementById('selectedCount').textContent = state.selectedRows.length;
            
            const allCheckbox = document.getElementById('selectAllCheckbox');
            const allCheckboxes = document.querySelectorAll('.row-checkbox');
            const checkedCount = document.querySelectorAll('.row-checkbox:checked').length;
            if (allCheckbox) {
                allCheckbox.checked = checkedCount === allCheckboxes.length;
                allCheckbox.indeterminate = checkedCount > 0 && checkedCount < allCheckboxes.length;
            }
            
            if (state.selectedRows.length > 0) {
                state.selectedRow = state.searchResults[state.selectedRows[state.selectedRows.length - 1]];
            } else {
                state.selectedRow = null;
            }
        }

        function removeFromQueue(index) {
            if (typeof index !== 'number' || index < 0 || index >= state.transferQueue.length) return;
            state.transferQueue.splice(index, 1);
            updateQueueDisplay();
        }
        
        // Sichere globale Funktionen mit Object.defineProperty (nicht √ºberschreibbar)
        Object.defineProperty(window, 'removeFromQueue', {
            value: removeFromQueue,
            writable: false,
            configurable: false
        });
        Object.defineProperty(window, 'toggleRowSelection', {
            value: toggleRowSelection,
            writable: false,
            configurable: false
        });

        // ==================== New Row Functions ====================
        function openNewRowPanel() {
            if (!state.mapping.sourceColumns || state.mapping.sourceColumns.length === 0) {
                showStatus(elements.transferStatus, 'Bitte zuerst Spalten konfigurieren', 'error');
                return;
            }
            
            // Formular mit konfigurierten Spalten aufbauen
            let html = '';
            state.mapping.sourceColumns.forEach((colIndex, i) => {
                const headerName = state.file1.headers[colIndex] || `Spalte ${colIndex + 1}`;
                html += `
                    <div class="new-row-field">
                        <label title="${headerName}">${headerName}</label>
                        <input type="text" id="newRowField_${i}" data-col-index="${colIndex}" placeholder="${headerName}">
                    </div>`;
            });
            
            elements.newRowForm.innerHTML = html;
            elements.newRowPanel.classList.remove('hidden');
            
            // Fokus auf erstes Feld
            const firstField = document.getElementById('newRowField_0');
            if (firstField) firstField.focus();
        }
        
        function closeNewRowPanel() {
            elements.newRowPanel.classList.add('hidden');
            // Felder leeren
            elements.newRowForm.innerHTML = '';
            elements.newRowComment.value = '';
            elements.newRowFlag.value = 'A';
        }
        
        function getNewRowData() {
            // Sammle alle Werte aus den Eingabefeldern
            const data = new Array(Math.max(...state.mapping.sourceColumns) + 1).fill(''); 
            
            state.mapping.sourceColumns.forEach((colIndex, i) => {
                const field = document.getElementById(`newRowField_${i}`);
                if (field) {
                    data[colIndex] = field.value;
                }
            });
            
            return data;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        // ==================== New Row Functions ====================
        function addNewRowToQueue() {
            const data = getNewRowData();
            const flag = elements.newRowFlag.value;
            const comment = elements.newRowComment.value;
            const checkValue = data[state.mapping.duplicateCheckColumn] || '';
            
            // Pr√ºfe ob bereits in Zieldatei (Datei 2)
            if (checkValue) {
                const duplicate = checkForDuplicate(checkValue);
                if (duplicate) {
                    const errorMsg = `‚ö†Ô∏è Zeile bereits in Zieldatei vorhanden (Zeile ${duplicate.rowIndex})`;
                    showStatus(elements.transferStatus, errorMsg, 'warning');
                    showStatus(elements.newRowStatus, errorMsg, 'warning');
                    return;
                }
            }
            
            state.transferQueue.push({
                data: data,
                flag: flag,
                comment: comment,
                checkValue: checkValue,
                isManual: true
            });
            
            updateQueueDisplay();
            const successMsg = '‚úÖ Neue Zeile zur Warteschlange hinzugef√ºgt!';
            showStatus(elements.transferStatus, successMsg, 'success');
            showStatus(elements.newRowStatus, successMsg, 'success');
            
            // Felder leeren f√ºr n√§chste Eingabe
            state.mapping.sourceColumns.forEach((colIndex, i) => {
                const field = document.getElementById(`newRowField_${i}`);
                if (field) field.value = '';
            });
            elements.newRowComment.value = '';
            
            const firstField = document.getElementById('newRowField_0');
            if (firstField) firstField.focus();
        }
        
        // Leerzeile hinzuf√ºgen - unabh√§ngig von Flag-Spalte
        function addEmptyRowToQueue() {
            const comment = elements.newRowComment?.value || '';
            
            // Leeres data-Array erstellen
            const data = new Array(Math.max(...state.mapping.sourceColumns) + 1).fill('');
            
            state.transferQueue.push({
                data: data,
                flag: 'leer',
                comment: comment,
                checkValue: '(Leerzeile)',
                isManual: true
            });
            
            updateQueueDisplay();
            const successMsg = '‚úÖ Leerzeile zur Warteschlange hinzugef√ºgt!';
            showStatus(elements.transferStatus, successMsg, 'success');
            showStatus(elements.newRowStatus, successMsg, 'success');
            
            // Kommentar leeren
            if (elements.newRowComment) {
                elements.newRowComment.value = '';
            }
        }

        async function transferNewRowDirect() {
            const data = getNewRowData();
            const flag = elements.newRowFlag.value;
            const comment = elements.newRowComment.value;
            
            // Pr√ºfe ob Zieldatei verf√ºgbar ist
            const hasTargetFile = state.file2.filePath;
            if (!hasTargetFile) {
                const errorMsg = 'Keine Zieldatei geladen';
                showStatus(elements.transferStatus, errorMsg, 'error');
                showStatus(elements.newRowStatus, errorMsg, 'error');
                return;
            }
            
            // Zur Warteschlange hinzuf√ºgen und direkt √ºbertragen
            if (state.file2.filePath) {
                const checkValue = data[state.mapping.duplicateCheckColumn] || '';
                
                // Pr√ºfe ob bereits in Zieldatei (Datei 2)
                if (checkValue) {
                    const duplicate = checkForDuplicate(checkValue);
                    if (duplicate) {
                        const errorMsg = `‚ö†Ô∏è Zeile bereits in Zieldatei vorhanden (Zeile ${duplicate.rowIndex})`;
                        showStatus(elements.transferStatus, errorMsg, 'warning');
                        showStatus(elements.newRowStatus, errorMsg, 'warning');
                        return;
                    }
                }
                
                state.transferQueue.push({
                    data: data,
                    flag: flag,
                    comment: comment,
                    checkValue: checkValue,
                    isManual: true
                });
                
                updateQueueDisplay();
                
                try {
                    // Direkt √ºbertragen
                    await transferQueueToExcel();
                    
                    // Felder leeren f√ºr n√§chste Eingabe
                    state.mapping.sourceColumns.forEach((colIndex, i) => {
                        const field = document.getElementById(`newRowField_${i}`);
                        if (field) field.value = '';
                    });
                    elements.newRowComment.value = '';
                    
                    const firstField = document.getElementById('newRowField_0');
                    if (firstField) firstField.focus();
                    
                    // Erfolgsmeldung auch im Modal anzeigen
                    showStatus(elements.newRowStatus, '‚úÖ Zeile erfolgreich √ºbertragen!', 'success');
                } catch (err) {
                    console.error('Fehler bei √úbertragung:', err);
                    const errorMsg = `Fehler: ${err.message}`;
                    showStatus(elements.transferStatus, errorMsg, 'error');
                    showStatus(elements.newRowStatus, errorMsg, 'error');
                }
                
                return;
            }
            
            // Browser-Modus: Original-Logik
            const dataStartCol = getDataStartColumn();
            const newRow = new Array(Math.max(
                state.file2.headers.length,
                dataStartCol + state.mapping.sourceColumns.length
            )).fill('');
            
            // Flag und Kommentar in automatisch berechneten Spalten
            if (isFlagEnabled()) {
                newRow[getFlagColumn() - 1] = flag;
            }
            if (isCommentEnabled()) {
                newRow[getCommentColumn() - 1] = comment;
            }
            
            state.mapping.sourceColumns.forEach((srcColIndex, i) => {
                const targetColIndex = dataStartCol - 1 + i;
                newRow[targetColIndex] = data[srcColIndex] || '';
            });
            
            state.file2.data.push(newRow);
            updateWorkbook();
            
            state.history.unshift({
                time: formatHistoryDateTime(),
                flag: flag,
                searchValue: '(Manuelle Eingabe)',
                preview: data[state.mapping.duplicateCheckColumn] || '(Neue Zeile)'
            });
            if (state.history.length > 100) state.history = state.history.slice(0, 100);
            updateHistoryDisplay();
            
            showStatus(elements.transferStatus, '‚úÖ Neue Zeile direkt √ºbertragen!', 'success');
            
            state.mapping.sourceColumns.forEach((colIndex, i) => {
                const field = document.getElementById(`newRowField_${i}`);
                if (field) field.value = '';
            });
            elements.newRowComment.value = '';
            
            const firstField = document.getElementById('newRowField_0');
            if (firstField) firstField.focus();
            
            saveConfig();
        }
        
        // ==================== Transfer ====================
        function checkForDuplicate(value) {
            if (!value || !state.file2.data.length) return null;
            
            const valueStr = String(value).toLowerCase().trim();
            const dataStartCol = getDataStartColumn();
            
            for (let i = 0; i < state.file2.data.length; i++) {
                const row = state.file2.data[i];
                for (let j = dataStartCol - 1; j < row.length; j++) {
                    if (row[j] && String(row[j]).toLowerCase().trim() === valueStr) {
                        return { rowIndex: i + 2, value: row[j] };
                    }
                }
            }
            return null;
        }
        
        async function transferSelectedDirect() {
            if (state.selectedRows.length === 0) {
                showStatus(elements.transferStatus, 'Bitte w√§hlen Sie mindestens eine Zeile aus', 'error');
                return;
            }
            
            // Pr√ºfe ob Zieldatei verf√ºgbar ist
            const hasTargetFile = state.file2.filePath;
            if (!hasTargetFile) {
                showStatus(elements.transferStatus, 'Keine Zieldatei geladen', 'error');
                return;
            }
            
            const flag = elements.transferFlag.value;
            const comment = elements.transferComment.value;
            
            // Zur Warteschlange hinzuf√ºgen und direkt √ºbertragen
            if (state.file2.filePath) {
                // Zeilen zur Warteschlange hinzuf√ºgen
                let addedCount = 0;
                let skippedQueue = 0;
                let skippedTarget = 0;
                
                for (const rowIndex of state.selectedRows) {
                    const row = state.searchResults[rowIndex];
                    if (!row) continue;
                    
                    const rowData = getEditedRowData(rowIndex);
                    const checkValue = rowData[state.mapping.duplicateCheckColumn];
                    
                    // Pr√ºfe ob bereits in Warteschlange
                    const rowAlreadyInQueue = state.transferQueue.some(item => item.rowIndex === row.rowIndex);
                    if (rowAlreadyInQueue) {
                        skippedQueue++;
                        continue;
                    }
                    
                    // Pr√ºfe ob bereits in Zieldatei (Datei 2)
                    if (checkValue) {
                        const duplicate = checkForDuplicate(checkValue);
                        if (duplicate) {
                            skippedTarget++;
                            continue;
                        }
                    }
                    
                    state.transferQueue.push({
                        data: [...rowData],
                        rowIndex: row.rowIndex,
                        flag: flag,
                        comment: comment,
                        checkValue: checkValue,
                        wasEdited: isRowEdited(rowIndex),
                        sourceRowIndex: row.rowIndex + 2 // +2: rowIndex ist 0-basiert, Excel ist 1-basiert + Header-Zeile
                    });
                    addedCount++;
                }
                
                // Statusmeldung f√ºr √ºbersprungene Zeilen
                if (skippedQueue > 0 || skippedTarget > 0) {
                    let skipMsg = '';
                    if (skippedQueue > 0) skipMsg += `${skippedQueue} bereits in Warteschlange, `;
                    if (skippedTarget > 0) skipMsg += `${skippedTarget} bereits in Zieldatei`;
                    showStatus(elements.transferStatus, `‚ö†Ô∏è √úbersprungen: ${skipMsg}`, 'warning');
                    await new Promise(r => setTimeout(r, 1500));
                }
                
                if (addedCount === 0) {
                    showStatus(elements.transferStatus, 'Keine neuen Zeilen zum √úbertragen', 'warning');
                    return;
                }
                
                updateQueueDisplay();
                
                try {
                    // Direkt √ºbertragen
                    await transferQueueToExcel();
                } catch (err) {
                    console.error('Fehler bei √úbertragung:', err);
                    showStatus(elements.transferStatus, `Fehler: ${err.message}`, 'error');
                }
                
                selectAllRows(false);
                elements.transferComment.value = '';
                elements.searchInput.value = '';
                elements.searchInput.focus();
                return;
            }
            
            // Browser-Modus: Original-Logik
            let transferredCount = 0;
            let editedCount = 0;
            let duplicatesFound = [];
            const dataStartCol = getDataStartColumn();
            
            for (const rowIndex of state.selectedRows) {
                const row = state.searchResults[rowIndex];
                if (!row) continue;
                
                const rowData = getEditedRowData(rowIndex);
                const wasEdited = isRowEdited(rowIndex);
                if (wasEdited) editedCount++;
                
                const checkValue = rowData[state.mapping.duplicateCheckColumn];
                
                if (checkValue) {
                    const duplicate = checkForDuplicate(checkValue);
                    if (duplicate) {
                        duplicatesFound.push({ value: checkValue, row: duplicate.rowIndex });
                    }
                }
                
                const newRow = new Array(Math.max(
                    state.file2.headers.length,
                    dataStartCol + state.mapping.sourceColumns.length
                )).fill('');
                
                // Flag und Kommentar in automatisch berechneten Spalten
                if (isFlagEnabled()) {
                    newRow[getFlagColumn() - 1] = flag;
                }
                if (isCommentEnabled()) {
                    newRow[getCommentColumn() - 1] = comment;
                }
            
                state.mapping.sourceColumns.forEach((srcColIndex, i) => {
                    const targetColIndex = dataStartCol - 1 + i;
                    newRow[targetColIndex] = rowData[srcColIndex] || '';
                });
                
                state.file2.data.push(newRow);
                transferredCount++;
                
                state.history.unshift({
                    time: formatHistoryDateTime(),
                    flag: flag,
                    searchValue: checkValue,
                    preview: rowData[state.mapping.duplicateCheckColumn] || '(Neue Zeile)'
                });
            }
            
            updateWorkbook();
            
            if (state.history.length > 100) state.history.length = 100;
            updateHistoryDisplay();
            saveConfig();
            
            let message = `‚úì ${transferredCount} Zeile(n) direkt √ºbertragen!`;
            let status = 'success';
            if (editedCount > 0) {
                message += ` (${editedCount} bearbeitet ‚úèÔ∏è)`;
            }
            if (duplicatesFound.length > 0) {
                message += ` ‚ö†Ô∏è ${duplicatesFound.length} Duplikat(e)!`;
                status = 'warning';
            }
            
            showStatus(elements.transferStatus, message, status);
            
            selectAllRows(false);
            elements.transferComment.value = '';
            elements.searchInput.value = '';
            elements.searchInput.focus();
        }
        
        // ==================== Queue Functions ====================
        function addToQueue() {
            if (state.selectedRows.length === 0) {
                showStatus(elements.transferStatus, 'Bitte w√§hlen Sie mindestens eine Zeile aus', 'error');
                return;
            }
            
            const flag = elements.transferFlag.value;
            const comment = elements.transferComment.value;
            
            let addedCount = 0;
            let editedCount = 0;
            let skippedQueue = 0;
            let skippedTarget = 0;
            
            for (const rowIndex of state.selectedRows) {
                const row = state.searchResults[rowIndex];
                if (!row) continue;
                
                const rowData = getEditedRowData(rowIndex);
                const wasEdited = isRowEdited(rowIndex);
                
                const checkValue = rowData[state.mapping.duplicateCheckColumn];
                
                // Pr√ºfe ob bereits in Warteschlange
                const rowAlreadyInQueue = state.transferQueue.some(item => item.rowIndex === row.rowIndex);
                if (rowAlreadyInQueue) {
                    skippedQueue++;
                    continue;
                }
                
                // Pr√ºfe ob bereits in Zieldatei (Datei 2)
                if (checkValue) {
                    const duplicate = checkForDuplicate(checkValue);
                    if (duplicate) {
                        skippedTarget++;
                        continue;
                    }
                }
                
                if (wasEdited) editedCount++;
                
                state.transferQueue.push({
                    data: [...rowData],
                    rowIndex: row.rowIndex,
                    flag: flag,
                    comment: comment,
                    checkValue: checkValue,
                    wasEdited: wasEdited,
                    sourceRowIndex: row.rowIndex + 2 // +2: rowIndex ist 0-basiert, Excel ist 1-basiert + Header-Zeile
                });
                addedCount++;
            }
            
            updateQueueDisplay();
            elements.transferComment.value = '';
            
            let message = `‚úì ${addedCount} Zeile(n) zur Warteschlange hinzugef√ºgt`;
            let status = 'success';
            
            if (editedCount > 0) {
                message += ` (${editedCount} bearbeitet ‚úèÔ∏è)`;
            }
            if (skippedQueue > 0) {
                message += ` (${skippedQueue} bereits in Warteschlange)`;
            }
            if (skippedTarget > 0) {
                message += ` ‚ö†Ô∏è ${skippedTarget} bereits in Zieldatei!`;
                status = 'warning';
            }
            
            showStatus(elements.transferStatus, message, status);
            
            selectAllRows(false);
            elements.searchInput.value = '';
            elements.searchInput.focus();
        }
        
        function clearQueue() {
            if (state.transferQueue.length > 0 && 
                !confirm(`Warteschlange mit ${state.transferQueue.length} Zeilen wirklich leeren?`)) {
                return;
            }
            state.transferQueue = [];
            updateQueueDisplay();
            autoSave(); // Auto-Save aktualisieren nach Leeren
        }
        
        function updateQueueDisplay() {
            const hasFile2 = state.file2.filePath;
            
            elements.queueCount.textContent = state.transferQueue.length;
            elements.btnClearQueue.disabled = state.transferQueue.length === 0;
            elements.btnExportPS.disabled = state.transferQueue.length === 0 || !hasFile2;
            elements.btnPreviewTransfer.disabled = state.transferQueue.length === 0 || !hasFile2;
            
            if (state.transferQueue.length === 0) {
                elements.queueList.innerHTML = '<div class="queue-empty">Keine Zeilen in der Warteschlange</div>';
                return;
            }
            
            let html = '';
            state.transferQueue.forEach((item, index) => {
                const preview = String(item.checkValue || item.data[0] || '').substring(0, 40);
                const editedBadge = item.wasEdited ? '<span class="queue-item-edited" title="Bearbeitet">‚úèÔ∏è</span>' : '';
                html += `
                    <div class="queue-item" style="display: flex; gap: 10px; padding: 8px; background: var(--bg-light); border-radius: 4px; margin-bottom: 5px; align-items: center;">
                        <span style="background: var(--primary); color: white; padding: 2px 8px; border-radius: 3px; font-weight: bold;">${item.flag}</span>
                        ${editedBadge}
                        <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(String(item.data))}">${escapeHtml(preview)}</span>
                        ${item.comment ? `<span style="color: var(--text-muted); font-size: 12px;" title="${escapeHtml(item.comment)}">${escapeHtml(item.comment.substring(0, 20))}</span>` : '' }
                        <button class="btn btn-secondary btn-sm" data-remove-index="${index}" title="Entfernen">‚úï</button>
                    </div>`;
            });
            elements.queueList.innerHTML = html;
            
            // Event-Delegation f√ºr Remove-Buttons
            elements.queueList.querySelectorAll('[data-remove-index]').forEach(btn => {
                btn.onclick = () => removeFromQueue(parseInt(btn.dataset.removeIndex, 10));
            });
        }
        
        async function transferQueueToExcel() {
            if (state.transferQueue.length === 0) {
                showStatus(elements.transferStatus, 'Keine Zeilen in der Warteschlange', 'error');
                return;
            }
            
            if (!state.file2.filePath) {
                showStatus(elements.transferStatus, 'Keine Zieldatei geladen', 'error');
                return;
            }
            
            const rows = state.transferQueue.map(item => {
                // Konvertiere item.data (Array) zu rowData (Objekt mit Index als Key)
                const rowData = {};
                state.mapping.sourceColumns.forEach((srcColIndex, i) => {
                    rowData[i] = item.data[srcColIndex] || '';
                });
                return {
                    flag: isFlagEnabled() ? item.flag : null,
                    comment: isCommentEnabled() ? item.comment : null,
                    data: rowData,
                    sourceRowIndex: item.sourceRowIndex || null, // Zeilen-Index aus Quelldatei f√ºr Formatierung
                    isManual: item.isManual || false
                };
            });
            
            const result = await window.electronAPI.insertExcelRows({
                filePath: state.file2.filePath,
                sheetName: state.file2.selectedSheet,
                rows: rows,
                startColumn: getDataStartColumn(),
                enableFlag: isFlagEnabled(),
                enableComment: isCommentEnabled(),
                flagColumn: getFlagColumn(),
                commentColumn: getCommentColumn(),
                // Quelldatei-Infos f√ºr Formatierungskopie
                sourceFilePath: state.file1.filePath || null,
                sourceSheetName: state.file1.selectedSheet || null,
                sourceColumns: state.mapping.sourceColumns || []
            });
            
            if (result.success) {
                state.transferQueue.forEach(item => {
                    state.history.unshift({
                        time: formatHistoryDateTime(),
                        flag: item.flag,
                        searchValue: item.checkValue,
                        preview: String(item.checkValue || item.data[0] || '').substring(0, 30)
                    });
                });
                if (state.history.length > 100) state.history = state.history.slice(0, 100);
                updateHistoryDisplay();
                
                state.transferQueue = [];
                updateQueueDisplay();
                
                // Auto-Save l√∂schen nach erfolgreicher √úbertragung
                clearAutoSave();
                
                await loadSheet2Electron(state.file2.selectedSheet);
                
                const successMsg = `‚úÖ ${result.insertedCount} Zeile(n) direkt in Excel eingef√ºgt!`;
                showStatus(elements.transferStatus, successMsg, 'success');
                showStatus(elements.newRowStatus, successMsg, 'success');
            } else {
                const errorMsg = `‚ùå Fehler: ${result.error}`;
                showStatus(elements.transferStatus, errorMsg, 'error');
                showStatus(elements.newRowStatus, errorMsg, 'error');
            }
        }
        
        // Diff-Vorschau vor Transfer anzeigen
        function showDiffPreview() {
            if (state.transferQueue.length === 0 || !state.file2.filePath) {
                showStatus(elements.transferStatus, 'Keine Zeilen in der Warteschlange oder keine Zieldatei geladen', 'error');
                return;
            }
            
            const modal = elements.diffPreviewModal;
            const targetFileName = state.file2.name || 'Zieldatei';
            const targetSheet = state.file2.selectedSheet || 'Sheet1';
            const currentRowCount = state.file2.data ? state.file2.data.length : 0;
            const startRow = currentRowCount + 1; // 1-basiert f√ºr Anzeige
            
            // Info-Bereich aktualisieren
            document.getElementById('diffTargetFile').textContent = targetFileName;
            document.getElementById('diffTargetSheet').textContent = targetSheet;
            document.getElementById('diffTargetRow').textContent = startRow;
            document.getElementById('diffPreviewCount').textContent = state.transferQueue.length;
            
            // Tabelle rendern
            const tableContainer = document.getElementById('diffPreviewTable');
            
            // Ermittle ob Flag/Kommentar aktiv sind
            const flagEnabled = isFlagEnabled();
            const commentEnabled = isCommentEnabled();
            const flagCol = getFlagColumn();      // 1-basiert
            const commentCol = getCommentColumn(); // 1-basiert
            
            // Header erstellen - Zeile zuerst, dann Spalten wie sie in der Zieldatei erscheinen
            let headerHtml = '<tr><th style="width: 50px; text-align: center;">#</th>';
            
            // Spalten√ºberschriften aus der Zieldatei verwenden
            const targetHeaders = state.file2.headers || [];
            // Automatisch berechnete Startspalte (0-basiert)
            const targetStartCol = getDataStartColumn() - 1;
            
            // Berechne welche Spalten in der Vorschau angezeigt werden sollen
            // Zeige alle Spalten von der niedrigsten bis zur h√∂chsten belegten Spalte
            const previewColumns = [];
            
            // Sammle alle belegten Spaltenindizes
            const usedColumns = new Map(); // index -> {type, sourceIndex?, name}
            
            // Flag-Spalte (wenn aktiv)
            if (flagEnabled) {
                usedColumns.set(flagCol - 1, {
                    type: 'flag',
                    name: targetHeaders[flagCol - 1] || `Flag`
                });
            }
            
            // Kommentar-Spalte (wenn aktiv)
            if (commentEnabled) {
                usedColumns.set(commentCol - 1, {
                    type: 'comment',
                    name: targetHeaders[commentCol - 1] || `Kommentar`
                });
            }
            
            // Daten-Spalten aus dem Mapping
            state.mapping.sourceColumns.forEach((srcIdx, i) => {
                const targetColIdx = targetStartCol + i;
                usedColumns.set(targetColIdx, {
                    type: 'data',
                    sourceIndex: srcIdx,
                    name: targetHeaders[targetColIdx] || `Spalte ${String.fromCharCode(65 + targetColIdx)}`
                });
            });
            
            // Finde min und max Spaltenindex
            const colIndices = Array.from(usedColumns.keys());
            const minCol = Math.min(...colIndices);
            const maxCol = Math.max(...colIndices);
            
            // Erstelle Spalten von min bis max (inkl. leerer Spalten)
            for (let i = minCol; i <= maxCol; i++) {
                if (usedColumns.has(i)) {
                    previewColumns.push({
                        index: i,
                        ...usedColumns.get(i)
                    });
                } else {
                    // Leere Spalte
                    previewColumns.push({
                        index: i,
                        type: 'empty',
                        name: targetHeaders[i] || `-`
                    });
                }
            }
            
            // Header-Zeile erstellen
            previewColumns.forEach(col => {
                const colLetter = String.fromCharCode(65 + col.index);
                const style = col.type === 'flag' ? 'background: rgba(33, 115, 70, 0.3);' : 
                              col.type === 'comment' ? 'background: rgba(33, 115, 70, 0.2);' : 
                              col.type === 'empty' ? 'background: rgba(128, 128, 128, 0.1); color: var(--text-muted);' : '';
                headerHtml += `<th style="${style}"><small style="color: var(--text-muted);">${colLetter}</small><br>${escapeHtml(col.name)}</th>`;
            });
            headerHtml += '</tr>';
            
            // Zeilen rendern
            let rowsHtml = '';
            state.transferQueue.forEach((item, idx) => {
                const rowNum = startRow + idx;
                const flagClass = item.flag === 'A' ? 'diff-row-add' : 
                                  item.flag === 'D' ? 'diff-row-delete' : 
                                  item.flag === 'C' ? 'diff-row-change' : '';
                
                rowsHtml += `<tr class="${flagClass}">`;
                rowsHtml += `<td style="text-align: center; font-weight: bold; color: var(--text-muted);">${rowNum}</td>`;
                
                // Zellen in der richtigen Reihenfolge
                previewColumns.forEach(col => {
                    if (col.type === 'flag') {
                        const flagValue = item.flag || '';
                        const flagStyle = 'font-weight: bold; text-align: center; background: rgba(33, 115, 70, 0.15);';
                        rowsHtml += `<td style="${flagStyle}"><span class="diff-flag">${flagValue}</span></td>`;
                    } else if (col.type === 'comment') {
                        const commentValue = item.comment || '';
                        const commentStyle = 'font-style: italic; background: rgba(33, 115, 70, 0.1);';
                        rowsHtml += `<td style="${commentStyle}">${escapeHtml(String(commentValue))}</td>`;
                    } else if (col.type === 'empty') {
                        // Leere Spalte - wird nicht beschrieben
                        rowsHtml += `<td style="color: var(--text-muted); text-align: center;">-</td>`;
                    } else {
                        const cellValue = item.data[col.sourceIndex] !== undefined ? item.data[col.sourceIndex] : '';
                        rowsHtml += `<td>${escapeHtml(String(cellValue))}</td>`;
                    }
                });
                
                rowsHtml += '</tr>';
            });
            
            tableContainer.innerHTML = `
                <table class="diff-table">
                    <thead>${headerHtml}</thead>
                    <tbody>${rowsHtml}</tbody>
                </table>
            `;
            
            // Modal anzeigen
            modal.classList.remove('hidden');
        }
        
        function closeDiffPreview() {
            elements.diffPreviewModal.classList.add('hidden');
        }
        
        function confirmTransferFromDiff() {
            closeDiffPreview();
            transferQueueToExcel();
        }
        
        // ==================== Working Directory Functions ====================
        async function selectWorkingDirectory() {
            try {
                const folderPath = await window.electronAPI.openFolderDialog({
                    title: t('selectWorkingDir') || 'Arbeitsordner ausw√§hlen'
                });
                
                if (!folderPath) return;
                
                state.workingDirectory = folderPath;
                updateWorkingDirectoryUI();
                
                // Im localStorage speichern f√ºr Persistenz
                localStorage.setItem('workingDirectory', folderPath);
                
                showStatus(elements.transferStatus, `‚úì ${t('workingDirSet')}${folderPath}`, 'success');
            } catch (err) {
                console.error('Fehler beim Ausw√§hlen des Arbeitsordners:', err);
                showStatus(elements.transferStatus, `Fehler: ${err.message}`, 'error');
            }
        }
        
        function clearWorkingDirectory() {
            state.workingDirectory = null;
            localStorage.removeItem('workingDirectory');
            updateWorkingDirectoryUI();
            showStatus(elements.transferStatus, `‚úì ${t('workingDirCleared')}`, 'success');
        }
        
        function updateWorkingDirectoryUI() {
            if (state.workingDirectory) {
                // Zeige den Ordnernamen (letzter Teil des Pfads)
                const folderName = state.workingDirectory.split(/[/\\]/).pop();
                elements.workingDirInfo.textContent = `‚úì ${folderName}`;
                elements.workingDirInfo.title = state.workingDirectory;
                elements.workingDirInfo.classList.add('loaded');
                elements.btnClearWorkingDir.style.display = 'block';
            } else {
                elements.workingDirInfo.textContent = t('noWorkingDirSet');
                elements.workingDirInfo.title = '';
                elements.workingDirInfo.classList.remove('loaded');
                elements.btnClearWorkingDir.style.display = 'none';
            }
        }
        
        function getWorkingDirectoryPath() {
            return state.workingDirectory || undefined;
        }
        
        // Arbeitsordner beim Start laden
        function loadWorkingDirectoryFromStorage() {
            const savedPath = localStorage.getItem('workingDirectory');
            if (savedPath) {
                state.workingDirectory = savedPath;
                updateWorkingDirectoryUI();
            }
        }
        
        // ==================== Electron-Specific Functions ====================
        async function loadFile1Electron() {
            const filePath = await window.electronAPI.openFileDialog({
                title: 'Quelldatei √∂ffnen',
                filters: [{ name: 'Excel', extensions: ['xlsx', 'xls'] }],
                defaultPath: getWorkingDirectoryPath()
            });
            if (!filePath) return;
            
            // Konfliktpr√ºfung f√ºr Netzlaufwerke
            const conflictCheck = await checkAndWarnNetworkConflict(filePath);
            if (!conflictCheck.proceed) return;
            
            const result = await window.electronAPI.readExcelFile(filePath);
            if (!result.success) {
                showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                return;
            }
            
            state.file1.name = result.fileName;
            state.file1.filePath = filePath;
            state.file1.sheets = result.sheets;
            state.file1.workbook = { SheetNames: result.sheets };
            
            elements.selectSheet1.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
            elements.selectSheet1.disabled = false;
            elements.file1Info.textContent = `‚úì ${result.fileName}`;
            elements.file1Info.classList.add('loaded');
            
            // Session-Lock erstellen
            await window.electronAPI.createSessionLock(filePath);
            
            await loadSheet1Electron(result.sheets[0]);
        }
        
        async function loadFile2Electron() {
            const filePath = await window.electronAPI.openFileDialog({
                title: 'Zieldatei √∂ffnen',
                filters: [{ name: 'Excel', extensions: ['xlsx', 'xls'] }],
                defaultPath: getWorkingDirectoryPath()
            });
            if (!filePath) return;
            
            // Konfliktpr√ºfung f√ºr Netzlaufwerke
            const conflictCheck = await checkAndWarnNetworkConflict(filePath);
            if (!conflictCheck.proceed) return;
            
            const result = await window.electronAPI.readExcelFile(filePath);
            if (!result.success) {
                showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                return;
            }
            
            state.file2.name = result.fileName;
            state.file2.filePath = filePath;
            state.file2.sheets = result.sheets;
            state.file2.workbook = { SheetNames: result.sheets };
            
            elements.selectSheet2.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
            elements.selectSheet2.disabled = false;
            elements.file2Info.textContent = `‚úì ${result.fileName}`;
            elements.file2Info.classList.add('loaded');
            
            // Session-Lock erstellen
            await window.electronAPI.createSessionLock(filePath);
            
            await loadSheet2Electron(result.sheets[0]);
        }
        
        async function loadSheet1Electron(sheetName) {
            if (!state.file1.filePath || !sheetName) return;
            
            const result = await window.electronAPI.readExcelSheet(state.file1.filePath, sheetName);
            if (!result.success) {
                showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                return;
            }
            
            state.file1.selectedSheet = sheetName;
            state.file1.headers = result.headers;
            state.file1.data = result.data.slice(1);
            
            saveConfig();
            checkReadyState();
        }
        
        async function loadSheet2Electron(sheetName) {
            if (!state.file2.filePath || !sheetName) return;
            
            const result = await window.electronAPI.readExcelSheet(state.file2.filePath, sheetName);
            if (!result.success) {
                showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                return;
            }
            
            state.file2.selectedSheet = sheetName;
            state.file2.headers = result.headers;
            state.file2.data = result.data.slice(1);
            
            saveConfig();
            checkReadyState();
        }
        
        async function loadTemplateElectron() {
            const filePath = await window.electronAPI.openFileDialog({
                title: 'Template-Datei √∂ffnen',
                filters: [{ name: 'Excel', extensions: ['xlsx', 'xls'] }],
                defaultPath: getWorkingDirectoryPath()
            });
            if (!filePath) return;
            
            const result = await window.electronAPI.readExcelFile(filePath);
            if (!result.success) {
                showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                return;
            }
            
            state.template.filePath = filePath;
            state.template.name = result.fileName;
            
            elements.templateInfo.textContent = `‚úì ${result.fileName}`;
            elements.templateInfo.classList.add('loaded');
            elements.btnNewMonth.disabled = false;
            
            showStatus(elements.transferStatus, `‚úì Template geladen: ${result.fileName}`, 'success');
        }
        
        /**
         * Erstellt ein Template aus einer Quelldatei mit allen Formatierungen
         * - √ñffnet Quelldatei-Dialog
         * - Zeigt Sheet-Auswahl Modal
         * - √ñffnet Speicher-Dialog f√ºr neues Template
         * - Erstellt leeres Template mit erweiterten CF-Ranges
         */
        
        // State f√ºr Template-Erstellung
        let createTemplateState = {
            sourcePath: null,
            sheets: []
        };
        
        async function createTemplateFromSourceElectron() {
            const lang = localStorage.getItem('excelSyncLanguage') || 'de';
            const isDE = lang === 'de';
            
            // 1. Quelldatei ausw√§hlen
            const sourcePath = await window.electronAPI.openFileDialog({
                title: isDE ? 'Quelldatei ausw√§hlen (mit Formatierungen)' : 'Select source file (with formatting)',
                filters: [{ name: 'Excel', extensions: ['xlsx'] }],
                defaultPath: getWorkingDirectoryPath()
            });
            if (!sourcePath) return;
            
            // 2. Datei lesen um Sheets zu bekommen
            const fileResult = await window.electronAPI.readExcelFile(sourcePath);
            if (!fileResult.success) {
                showStatus(elements.transferStatus, `‚ùå ${isDE ? 'Fehler' : 'Error'}: ${fileResult.error}`, 'error');
                return;
            }
            
            // State speichern
            createTemplateState.sourcePath = sourcePath;
            createTemplateState.sheets = fileResult.sheets;
            
            // 3. Modal mit Sheet-Auswahl anzeigen
            elements.createTemplateSourceName.textContent = fileResult.fileName;
            
            // Sheet-Liste aufbauen
            const sheetListHtml = fileResult.sheets.map((sheetName, index) => `
                <label style="display: flex; align-items: center; padding: 6px 8px; cursor: pointer; border-radius: 4px; transition: background 0.2s;" 
                       onmouseover="this.style.background='var(--bg-medium)'" 
                       onmouseout="this.style.background='transparent'">
                    <input type="checkbox" class="template-sheet-checkbox" value="${sheetName}" checked 
                           style="margin-right: 10px; width: 16px; height: 16px; cursor: pointer;">
                    <span style="flex: 1;">${sheetName}</span>
                    <span style="color: var(--text-muted); font-size: 11px;">Sheet ${index + 1}</span>
                </label>
            `).join('');
            
            elements.createTemplateSheetList.innerHTML = sheetListHtml;
            
            // Modal anzeigen
            elements.createTemplateModal.classList.remove('hidden');
        }
        
        async function confirmCreateTemplate() {
            const lang = localStorage.getItem('excelSyncLanguage') || 'de';
            const isDE = lang === 'de';
            
            // Ausgew√§hlte Sheets sammeln
            const checkboxes = document.querySelectorAll('.template-sheet-checkbox:checked');
            const selectedSheets = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedSheets.length === 0) {
                showStatus(elements.transferStatus, isDE ? '‚ö†Ô∏è Bitte mindestens ein Arbeitsblatt ausw√§hlen' : '‚ö†Ô∏è Please select at least one worksheet', 'error');
                return;
            }
            
            // Extra-Spalten Optionen lesen
            const addFlagColumn = document.getElementById('templateFlagColumn').checked;
            const addCommentColumn = document.getElementById('templateCommentColumn').checked;
            
            // Modal schlie√üen
            elements.createTemplateModal.classList.add('hidden');
            
            // Speicherort f√ºr Template w√§hlen
            const outputPath = await window.electronAPI.saveFileDialog({
                title: isDE ? 'Template speichern als' : 'Save template as',
                defaultPath: createTemplateState.sourcePath.replace('.xlsx', '_Template.xlsx'),
                filters: [{ name: 'Excel', extensions: ['xlsx'] }]
            });
            if (!outputPath) return;
            
            // Template erstellen
            showStatus(elements.transferStatus, isDE ? '‚è≥ Template wird erstellt...' : '‚è≥ Creating template...', 'pending');
            
            const result = await window.electronAPI.createTemplateFromSource({
                sourcePath: createTemplateState.sourcePath,
                outputPath,
                selectedSheets,
                addFlagColumn,
                addCommentColumn
            });
            
            if (!result.success) {
                showStatus(elements.transferStatus, `‚ùå ${isDE ? 'Fehler' : 'Error'}: ${result.error}`, 'error');
                return;
            }
            
            // Erfolgsmeldung mit Stats
            const stats = result.stats;
            const extraInfo = stats.extraColumnsAdded > 0 
                ? (isDE ? `, ${stats.extraColumnsAdded} Extra-Spalte(n)` : `, ${stats.extraColumnsAdded} extra column(s)`)
                : '';
            const msg = isDE 
                ? `‚úì Template erstellt: ${result.fileName}\n   (${stats.sheetsProcessed} Sheet(s), ${stats.cfRulesPreserved} CF-Regeln${extraInfo})`
                : `‚úì Template created: ${result.fileName}\n   (${stats.sheetsProcessed} sheet(s), ${stats.cfRulesPreserved} CF rules${extraInfo})`;
            
            showStatus(elements.transferStatus, msg, 'success');
            
            // Template automatisch laden
            const loadResult = await window.electronAPI.readExcelFile(outputPath);
            if (loadResult.success) {
                state.template.filePath = outputPath;
                state.template.name = loadResult.fileName;
                
                elements.templateInfo.textContent = `‚úì ${loadResult.fileName}`;
                elements.templateInfo.classList.add('loaded');
                elements.btnNewMonth.disabled = false;
            }
        }
        
        function closeCreateTemplateModal() {
            elements.createTemplateModal.classList.add('hidden');
        }
        
        async function applyLoadedConfig(config) {
            state.mapping = config.mapping || state.mapping;
            
            // Extra-Spalten Konfiguration laden
            if (config.extraColumns) {
                const ec = config.extraColumns;
                const flagCheckbox = document.getElementById('enableFlagColumn');
                const commentCheckbox = document.getElementById('enableCommentColumn');
                const flagValuesInput = document.getElementById('flagValues');
                const commentPlaceholderInput = document.getElementById('commentPlaceholder');
                
                if (ec.enableFlag !== undefined && flagCheckbox) {
                    flagCheckbox.checked = ec.enableFlag;
                    localStorage.setItem('excelSyncEnableFlag', String(ec.enableFlag));
                }
                if (ec.enableComment !== undefined && commentCheckbox) {
                    commentCheckbox.checked = ec.enableComment;
                    localStorage.setItem('excelSyncEnableComment', String(ec.enableComment));
                }
                if (ec.flagValues && flagValuesInput) {
                    flagValuesInput.value = ec.flagValues;
                    localStorage.setItem('excelSyncFlagValues', ec.flagValues);
                }
                if (ec.commentPlaceholder && commentPlaceholderInput) {
                    commentPlaceholderInput.value = ec.commentPlaceholder;
                    localStorage.setItem('excelSyncCommentPlaceholder', ec.commentPlaceholder);
                }
                
                // UI aktualisieren
                updateFlagDropdownOptions();
                updateCommentPlaceholders();
                updateFlagCommentVisibility();
                updateColumnDisplays();
            }
            
            // Lade Dateien aus Pfaden
            if (config.file1Path) {
                try {
                    const result = await window.electronAPI.readExcelFile(config.file1Path);
                    if (result.success) {
                        state.file1.name = result.fileName;
                        state.file1.filePath = config.file1Path;
                        state.file1.sheets = result.sheets;
                        state.file1.workbook = { SheetNames: result.sheets };
                        
                        elements.selectSheet1.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
                        elements.selectSheet1.disabled = false;
                        elements.file1Info.textContent = `‚úì ${result.fileName}`;
                        elements.file1Info.classList.add('loaded');
                        
                        const sheetToLoad = config.file1SheetName && result.sheets.includes(config.file1SheetName) 
                            ? config.file1SheetName : result.sheets[0];
                        elements.selectSheet1.value = sheetToLoad;
                        await loadSheet1Electron(sheetToLoad);
                    }
                } catch (e) {
                    console.warn('Konnte Datei 1 nicht laden:', e);
                }
            }
            
            if (config.file2Path) {
                try {
                    const result = await window.electronAPI.readExcelFile(config.file2Path);
                    if (result.success) {
                        state.file2.name = result.fileName;
                        state.file2.filePath = config.file2Path;
                        state.file2.sheets = result.sheets;
                        state.file2.workbook = { SheetNames: result.sheets };
            
                        elements.selectSheet2.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
                        elements.selectSheet2.disabled = false;
                        elements.file2Info.textContent = `‚úì ${result.fileName}`;
                        elements.file2Info.classList.add('loaded');
                        
                        const sheetToLoad = config.file2SheetName && result.sheets.includes(config.file2SheetName) 
                            ? config.file2SheetName : result.sheets[0];
                        elements.selectSheet2.value = sheetToLoad;
                        await loadSheet2Electron(sheetToLoad);
                    }
                } catch (e) {
                    console.warn('Konnte Datei 2 nicht laden:', e);
                }
            }
            
            if (config.templatePath) {
                try {
                    const result = await window.electronAPI.readExcelFile(config.templatePath);
                    if (result.success) {
                        state.template.filePath = config.templatePath;
                        state.template.name = result.fileName;
                        elements.templateInfo.textContent = `‚úì ${result.fileName}`;
                        elements.templateInfo.classList.add('loaded');
                        elements.btnNewMonth.disabled = false;
                    }
                } catch (e) {
                    console.warn('Konnte Template nicht laden:', e);
                }
            }
            
            updateMappingInfo();
            updateMappingPreview();
            saveConfig();
        }
        
        async function loadConfigFromAppDirOrDialog() {
            try {
                // Zuerst Dialog √∂ffnen
                const filePath = await window.electronAPI.openFileDialog({
                    title: 'config.json laden',
                    filters: [{ name: 'JSON', extensions: ['json'] }],
                    defaultPath: getWorkingDirectoryPath()
                });
                
                if (filePath) {
                    const result = await window.electronAPI.loadConfig(filePath);
                    if (result.success && result.config) {
                        await applyLoadedConfig(result.config);
                        // Zeige Computer-spezifische Info
                        let statusMsg = `‚úì config.json geladen: ${filePath}`;
                        if (result.computerName && !result.isLegacyFormat) {
                            statusMsg = result.hasComputerSection 
                                ? `‚úì Config f√ºr "${result.computerName}" geladen`
                                : `‚úì Config geladen (Standard, kein Abschnitt f√ºr "${result.computerName}")`;
                        }
                        showStatus(elements.transferStatus, statusMsg, 'success');
                    } else {
                        showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                    }
                }
            } catch (e) {
                showStatus(elements.transferStatus, `Fehler: ${e.message}`, 'error');
            }
        }
        
        // ==================== Data Explorer Functions ====================
        const EXPLORER_RECOVERY_KEY = 'excelSyncExplorerRecovery';
        let explorerAutoSaveInterval = null;
        
        // Zwischenspeicher f√ºr kopierte Zellen mit Formatierung
        let copiedCellsWithFormat = null;  // { cells: [{row, col, value, style, formula, hyperlink}], minRow, minCol }

        const explorerState = {
            filePath: null,
            fileName: null,
            sheets: [],
            selectedSheet: null,
            headers: [],
            data: [],
            originalData: [],  // Kopie der Originaldaten f√ºr Vorschau-Vergleich
            filteredData: [],  // Enth√§lt jetzt {originalIndex, row} Objekte
            searchTerm: '',
            filters: [],
            visibleColumns: [],
            columnOrder: [],  // Benutzerdefinierte Spaltenreihenfolge
            editedCells: new Map(),  // Speichert editierte Zellen: "rowIndex-colIndex" -> neuer Wert
            // Pagination
            currentPage: 1,
            pageSize: 100, // Zeilen pro Seite (konfigurierbar)
            pageSizeOptions: [50, 100, 250, 500, 1000],
            // Sortierung
            sortColumn: null,
            sortDirection: null,  // 'asc', 'desc' oder null
            sortType: 'auto',  // 'auto', 'alpha-asc', 'alpha-desc', 'num-asc', 'num-desc', 'date-asc', 'date-desc'
            // Zeilen-Markierungen
            rowHighlights: new Map(),  // rowIndex -> 'green'|'yellow'|'orange'|'red'|'blue'|'purple'
            originalRowHighlights: new Map(),  // Original-Highlights beim Laden (f√ºr Erkennung entfernter Markierungen)
            // Zeilen-Auswahl f√ºr Verschiebung
            selectedRows: new Set(),  // Set von originalIndex Werten
            moveMode: false,  // Ob Verschiebe-Modus aktiv ist
            // Drag & Drop State
            draggedColumn: null,
            // Zellen-Auswahl f√ºr Mehrfach-Bearbeitung
            selectedCells: new Set(),  // Set von "rowIndex-colIndex" Strings
            selectionAnchor: null,  // {row, col} - Startpunkt der Auswahl
            isSelecting: false,  // Ob gerade eine Auswahl gezogen wird
            // Cache f√ºr Sheet-√Ñnderungen (bleibt bei Wechsel erhalten)
            sheetDataCache: new Map(),  // sheetName -> { data, editedCells, rowHighlights, originalData }
            // Data Validations (Dropdown-Listen)
            dataValidations: {},  // colIndex -> { type: 'column'|'rows', values: [], rows: {} }
            // Cell Styles (Formatierungen aus Excel)
            cellStyles: {},  // "rowIndex-colIndex" -> { bold, italic, fontColor, fill, fontSize, textAlign, ... }
            // Cell Formulas (Formeln aus Excel)
            cellFormulas: {},  // "rowIndex-colIndex" -> "=FORMULA"
            // Cell Hyperlinks (Links aus Excel)
            cellHyperlinks: {},  // "rowIndex-colIndex" -> "https://..."
            // Rich Text Cells (formatierter Text mit mehreren Styles)
            richTextCells: {},  // "rowIndex-colIndex" -> [{ text, styles: { bold, italic, ... } }, ...]
            // Hidden Rows (ausgeblendete Zeilen)
            hiddenRows: new Set(),  // Set von 0-basierten Zeilen-Indices
            // AutoFilter Range (falls vorhanden)
            autoFilterRange: null,  // z.B. "A1:D10"
            // Merged Cells (verbundene Zellen)
            mergedCells: [],  // Array von { startRow, startCol, endRow, endCol, rowSpan, colSpan }
            // Passwort f√ºr passwortgesch√ºtzte Dateien
            filePassword: null,
            // Pivot-Tabellen Warnung
            hasPivotTables: false
        };
        
        // ==================== Data Join State & Functions ====================
        const dataJoinState = {
            sourceFilePath: null,
            sourceFileName: null,
            sourceSheets: [],
            sourceData: [],
            sourceHeaders: [],
            selectedSourceSheet: null,
            targetKeyColumnIndex: null,
            sourceKeyColumnIndex: null,
            selectedColumns: [],  // Indices der zu kopierenden Spalten
            columnPositions: [],  // Array von {sourceIndex, targetPosition}
            previewCalculated: false,
            matchStats: {
                targetRows: 0,
                sourceRows: 0,
                matches: 0,
                noMatch: 0
            }
        };
        
        function resetDataJoinState() {
            dataJoinState.sourceFilePath = null;
            dataJoinState.sourceFileName = null;
            dataJoinState.sourceSheets = [];
            dataJoinState.sourceData = [];
            dataJoinState.sourceHeaders = [];
            dataJoinState.selectedSourceSheet = null;
            dataJoinState.targetKeyColumnIndex = null;
            dataJoinState.sourceKeyColumnIndex = null;
            dataJoinState.selectedColumns = [];
            dataJoinState.columnPositions = [];
            dataJoinState.previewCalculated = false;
            dataJoinState.matchStats = { targetRows: 0, sourceRows: 0, matches: 0, noMatch: 0 };
        }
        
        function openDataJoinModal() {
            if (!explorerState.filePath || explorerState.data.length === 0) {
                showNotification('Bitte zuerst eine Datei im Datenexplorer laden', 'warning');
                return;
            }
            
            resetDataJoinState();
            
            // Ziel-Spalten (aktuelle Datei) bef√ºllen
            const targetKeySelect = elements.joinTargetKeyColumn;
            targetKeySelect.innerHTML = `<option value="">${t('joinSelectColumn')}</option>`;
            explorerState.headers.forEach((header, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `${getColumnLetter(index)}: ${header || '(leer)'}`;
                targetKeySelect.appendChild(option);
            });
            targetKeySelect.disabled = false;
            
            // Reset andere Felder
            elements.joinSourceFileName.textContent = t('joinNoFileSelected');
            elements.joinSourceSheet.innerHTML = `<option value="">${t('joinLoadFile')}</option>`;
            elements.joinSourceSheet.disabled = true;
            elements.joinSourceKeyColumn.innerHTML = `<option value="">${t('joinSelectColumn')}</option>`;
            elements.joinSourceKeyColumn.disabled = true;
            elements.joinColumnsContainer.innerHTML = `<div style="color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px;">${t('joinLoadSourceFirst')}</div>`;
            elements.joinPreviewContainer.style.display = 'none';
            elements.btnPreviewDataJoin.disabled = true;
            elements.btnExecuteDataJoin.disabled = true;
            
            // Modal √∂ffnen
            elements.dataJoinModal.classList.remove('hidden');
            document.body.classList.add('modal-open');
        }
        
        function closeDataJoinModal() {
            elements.dataJoinModal.classList.add('hidden');
            document.body.classList.remove('modal-open');
        }
        
        // Hilfsfunktion: Quelldatei laden (von Pfad)
        async function loadDataJoinSourceFromPath(filePath) {
            try {
                const fileName = filePath.split(/[/\\]/).pop();
                
                // Datei laden um Sheets zu bekommen
                const fileResult = await window.electronAPI.readExcelFile(filePath);
                
                if (!fileResult.success) {
                    showNotification('Fehler beim Laden: ' + fileResult.error, 'error');
                    return;
                }
                
                dataJoinState.sourceFilePath = filePath;
                dataJoinState.sourceFileName = fileName;
                dataJoinState.sourceSheets = fileResult.sheets;
                
                elements.joinSourceFileName.textContent = fileName;
                elements.joinSourceFileName.style.color = 'var(--success)';
                
                // Sheets-Dropdown bef√ºllen
                elements.joinSourceSheet.innerHTML = '';
                fileResult.sheets.forEach(sheetName => {
                    const option = document.createElement('option');
                    option.value = sheetName;
                    option.textContent = sheetName;
                    elements.joinSourceSheet.appendChild(option);
                });
                elements.joinSourceSheet.disabled = false;
                
                // Erstes Sheet automatisch laden
                if (fileResult.sheets.length > 0) {
                    await loadDataJoinSourceSheet(fileResult.sheets[0]);
                }
                
            } catch (error) {
                console.error('Fehler beim Laden der Quelldatei:', error);
                showNotification('Fehler beim Laden: ' + error.message, 'error');
            }
        }
        
        async function loadDataJoinSourceFile() {
            try {
                const filePath = await window.electronAPI.openFileDialog({
                    title: 'Quelldatei f√ºr Spalten-Join ausw√§hlen',
                    filters: [{ name: 'Excel-Dateien', extensions: ['xlsx', 'xls'] }]
                });
                
                if (!filePath) {
                    return;
                }
                
                await loadDataJoinSourceFromPath(filePath);
                
            } catch (error) {
                console.error('Fehler beim Laden der Quelldatei:', error);
                showNotification('Fehler beim Laden: ' + error.message, 'error');
            }
        }
        
        async function loadDataJoinSourceSheet(sheetName) {
            if (!dataJoinState.sourceFilePath || !sheetName) return;
            
            try {
                const sheetResult = await window.electronAPI.readExcelSheet(
                    dataJoinState.sourceFilePath, 
                    sheetName, 
                    null
                );
                
                if (!sheetResult.success) {
                    showNotification('Fehler beim Laden des Sheets: ' + sheetResult.error, 'error');
                    return;
                }
                
                dataJoinState.selectedSourceSheet = sheetName;
                dataJoinState.sourceHeaders = sheetResult.headers || [];
                dataJoinState.sourceData = sheetResult.data || [];
                
                // Schl√ºsselspalten-Dropdown bef√ºllen
                const sourceKeySelect = elements.joinSourceKeyColumn;
                sourceKeySelect.innerHTML = `<option value="">${t('joinSelectColumn')}</option>`;
                dataJoinState.sourceHeaders.forEach((header, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${getColumnLetter(index)}: ${header || '(leer)'}`;
                    sourceKeySelect.appendChild(option);
                });
                sourceKeySelect.disabled = false;
                
                // Spalten-Auswahl bef√ºllen
                updateJoinColumnsSelection();
                
                // Preview zur√ºcksetzen
                dataJoinState.previewCalculated = false;
                elements.joinPreviewContainer.style.display = 'none';
                updateJoinButtons();
                
            } catch (error) {
                console.error('Fehler beim Laden des Source-Sheets:', error);
                showNotification('Fehler beim Laden: ' + error.message, 'error');
            }
        }
        
        function updateJoinColumnsSelection() {
            const container = elements.joinColumnsContainer;
            container.innerHTML = '';
            
            if (dataJoinState.sourceHeaders.length === 0) {
                container.innerHTML = '<div style="color: var(--text-muted); font-size: 13px; text-align: center; padding: 20px;">Keine Spalten gefunden</div>';
                return;
            }
            
            // Erstelle Optionen f√ºr Ziel-Positionen
            const targetPositionOptions = explorerState.headers.map((h, idx) => 
                `<option value="${idx}">nach ${getColumnLetter(idx)}: ${h || '(leer)'}</option>`
            ).join('');
            
            dataJoinState.sourceHeaders.forEach((header, index) => {
                const row = document.createElement('div');
                row.className = 'join-column-row';
                row.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: var(--bg-light); border-radius: 4px; transition: background 0.2s;';
                row.innerHTML = `
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; flex: 0 0 auto;">
                        <input type="checkbox" class="green-checkbox join-column-checkbox" data-index="${index}">
                        <span style="font-weight: 500; color: var(--primary-light); min-width: 30px;">${getColumnLetter(index)}</span>
                        <span style="color: var(--text); min-width: 120px; max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${header || '(leer)'}">${header || '(leer)'}</span>
                    </label>
                    <span style="color: var(--text-muted); font-size: 12px;">‚Üí</span>
                    <select class="config-select join-target-position" data-source-index="${index}" style="flex: 1; min-width: 150px; font-size: 12px;" disabled>
                        <option value="end">Am Ende einf√ºgen</option>
                        ${targetPositionOptions}
                    </select>
                `;
                row.onmouseenter = () => row.style.background = 'var(--bg-lighter)';
                row.onmouseleave = () => row.style.background = 'var(--bg-light)';
                
                const checkbox = row.querySelector('.join-column-checkbox');
                const positionSelect = row.querySelector('.join-target-position');
                
                checkbox.onchange = () => {
                    positionSelect.disabled = !checkbox.checked;
                    updateSelectedJoinColumns();
                    dataJoinState.previewCalculated = false;
                    elements.joinPreviewContainer.style.display = 'none';
                    updateJoinButtons();
                };
                
                positionSelect.onchange = () => {
                    updateSelectedJoinColumns();
                    dataJoinState.previewCalculated = false;
                    elements.joinPreviewContainer.style.display = 'none';
                };
                
                container.appendChild(row);
            });
        }
        
        function updateSelectedJoinColumns() {
            const checkboxes = document.querySelectorAll('.join-column-checkbox:checked');
            const positionSelects = document.querySelectorAll('.join-target-position');
            
            // Speichere ausgew√§hlte Spalten mit ihren Zielpositionen
            dataJoinState.selectedColumns = [];
            dataJoinState.columnPositions = []; // Array von {sourceIndex, targetPosition}
            
            checkboxes.forEach(cb => {
                const sourceIndex = parseInt(cb.dataset.index);
                const positionSelect = document.querySelector(`.join-target-position[data-source-index="${sourceIndex}"]`);
                const targetPosition = positionSelect ? positionSelect.value : 'end';
                
                dataJoinState.selectedColumns.push(sourceIndex);
                dataJoinState.columnPositions.push({
                    sourceIndex: sourceIndex,
                    targetPosition: targetPosition === 'end' ? 'end' : parseInt(targetPosition)
                });
            });
        }
        
        function updateJoinButtons() {
            const hasTargetKey = elements.joinTargetKeyColumn.value !== '';
            const hasSourceKey = elements.joinSourceKeyColumn.value !== '';
            const hasSelectedColumns = dataJoinState.selectedColumns.length > 0;
            
            elements.btnPreviewDataJoin.disabled = !(hasTargetKey && hasSourceKey && hasSelectedColumns);
            elements.btnExecuteDataJoin.disabled = !dataJoinState.previewCalculated;
        }
        
        function calculateDataJoinPreview() {
            const targetKeyIndex = parseInt(elements.joinTargetKeyColumn.value);
            const sourceKeyIndex = parseInt(elements.joinSourceKeyColumn.value);
            
            if (isNaN(targetKeyIndex) || isNaN(sourceKeyIndex)) {
                showNotification('Bitte Schl√ºsselspalten ausw√§hlen', 'warning');
                return;
            }
            
            dataJoinState.targetKeyColumnIndex = targetKeyIndex;
            dataJoinState.sourceKeyColumnIndex = sourceKeyIndex;
            
            // Source-Daten in Map f√ºr schnellen Lookup
            const sourceMap = new Map();
            dataJoinState.sourceData.forEach((row, idx) => {
                const keyValue = String(row[sourceKeyIndex] || '').trim();
                if (keyValue) {
                    sourceMap.set(keyValue, row);
                }
            });
            
            // Matches z√§hlen
            let matches = 0;
            let noMatch = 0;
            
            explorerState.data.forEach((row, idx) => {
                const keyValue = String(row[targetKeyIndex] || '').trim();
                if (keyValue && sourceMap.has(keyValue)) {
                    matches++;
                } else if (keyValue) {
                    noMatch++;
                }
            });
            
            // Stats speichern und anzeigen
            dataJoinState.matchStats = {
                targetRows: explorerState.data.length,
                sourceRows: dataJoinState.sourceData.length,
                matches: matches,
                noMatch: noMatch
            };
            
            elements.joinStatTargetRows.textContent = dataJoinState.matchStats.targetRows;
            elements.joinStatSourceRows.textContent = dataJoinState.matchStats.sourceRows;
            elements.joinStatMatches.textContent = dataJoinState.matchStats.matches;
            elements.joinStatNoMatch.textContent = dataJoinState.matchStats.noMatch;
            
            elements.joinPreviewContainer.style.display = 'block';
            dataJoinState.previewCalculated = true;
            updateJoinButtons();
            
            showNotification(`Vorschau berechnet: ${matches} Matches, ${noMatch} ohne Match`, 'success');
        }
        
        function executeDataJoin() {
            if (!dataJoinState.previewCalculated) {
                showNotification('Bitte zuerst Vorschau berechnen', 'warning');
                return;
            }
            
            const originalTargetKeyIndex = dataJoinState.targetKeyColumnIndex;
            const sourceKeyIndex = dataJoinState.sourceKeyColumnIndex;
            const columnPositions = dataJoinState.columnPositions || [];
            const markNotFound = elements.joinMarkNotFound.checked;
            
            if (columnPositions.length === 0) {
                showNotification('Bitte mindestens eine Spalte ausw√§hlen', 'warning');
                return;
            }
            
            // Source-Daten in Map f√ºr schnellen Lookup
            const sourceMap = new Map();
            dataJoinState.sourceData.forEach(row => {
                const keyValue = String(row[sourceKeyIndex] || '').trim();
                if (keyValue) {
                    sourceMap.set(keyValue, row);
                }
            });
            
            // Gruppiere Spalten nach Zielposition und sortiere absteigend
            // (von hinten nach vorne einf√ºgen, damit Indices nicht durcheinander kommen)
            const positionGroups = new Map();
            
            columnPositions.forEach(cp => {
                const pos = cp.targetPosition === 'end' ? Infinity : cp.targetPosition + 1; // +1 weil "nach Spalte X"
                if (!positionGroups.has(pos)) {
                    positionGroups.set(pos, []);
                }
                positionGroups.get(pos).push(cp.sourceIndex);
            });
            
            // Sortiere Positionen absteigend (h√∂chste zuerst)
            const sortedPositions = Array.from(positionGroups.keys()).sort((a, b) => b - a);
            
            // Strukturelle √Ñnderungen f√ºr Export sammeln
            const insertOperations = [];
            let totalInsertCount = 0;
            
            // Berechne Original-Positionen BEVOR wir etwas einf√ºgen
            // (f√ºr den Export - die Positionen m√ºssen die Original-Indizes sein)
            const originalHeaderCount = explorerState.headers.length;
            const originalPositions = new Map();
            sortedPositions.forEach(insertPos => {
                const sourceIndices = positionGroups.get(insertPos);
                const count = sourceIndices.length;
                // Original-Position ist entweder die konkrete Position oder "am Ende"
                const origPos = insertPos === Infinity ? originalHeaderCount : insertPos;
                originalPositions.set(insertPos, origPos);
            });
            
            // Dynamischer Key-Index: Wird angepasst wenn Spalten VOR der Schl√ºsselspalte eingef√ºgt werden
            let currentKeyIndex = originalTargetKeyIndex;
            
            // F√ºr jede Position (von hinten nach vorne)
            sortedPositions.forEach(insertPos => {
                const sourceIndices = positionGroups.get(insertPos);
                
                // Tats√§chliche Einf√ºgeposition (ber√ºcksichtige Infinity f√ºr "am Ende")
                let actualInsertPos = insertPos === Infinity ? explorerState.headers.length : insertPos;
                
                // Neue Header f√ºr diese Position
                const newHeaders = sourceIndices.map(idx => 
                    dataJoinState.sourceHeaders[idx] || `Spalte ${getColumnLetter(idx)}`
                );
                
                // Header einf√ºgen
                explorerState.headers.splice(actualInsertPos, 0, ...newHeaders);
                
                // Visible Columns aktualisieren
                explorerState.visibleColumns = explorerState.visibleColumns.map(idx => 
                    idx >= actualInsertPos ? idx + newHeaders.length : idx
                );
                for (let i = 0; i < newHeaders.length; i++) {
                    let arrayPos = 0;
                    while (arrayPos < explorerState.visibleColumns.length && 
                           explorerState.visibleColumns[arrayPos] < actualInsertPos + i) {
                        arrayPos++;
                    }
                    explorerState.visibleColumns.splice(arrayPos, 0, actualInsertPos + i);
                }
                
                // Column Order aktualisieren wenn vorhanden
                if (explorerState.columnOrder.length > 0) {
                    explorerState.columnOrder = explorerState.columnOrder.map(idx => 
                        idx >= actualInsertPos ? idx + newHeaders.length : idx
                    );
                    for (let i = 0; i < newHeaders.length; i++) {
                        let arrayPos = 0;
                        while (arrayPos < explorerState.columnOrder.length && 
                               explorerState.columnOrder[arrayPos] < actualInsertPos + i) {
                            arrayPos++;
                        }
                        explorerState.columnOrder.splice(arrayPos, 0, actualInsertPos + i);
                    }
                }
                
                // Daten f√ºr jede Zeile hinzuf√ºgen
                // WICHTIG: currentKeyIndex verwenden, da sich der Index nach jeder Einf√ºgung verschieben kann
                explorerState.data.forEach((row, rowIndex) => {
                    const keyValue = String(row[currentKeyIndex] || '').trim();
                    const sourceRow = sourceMap.get(keyValue);
                    
                    const newValues = sourceIndices.map(colIdx => {
                        if (sourceRow) {
                            return sourceRow[colIdx] || '';
                        } else {
                            return '';
                        }
                    });
                    
                    row.splice(actualInsertPos, 0, ...newValues);
                    
                    // Als bearbeitet markieren
                    newValues.forEach((val, i) => {
                        const cellKey = `${rowIndex}-${actualInsertPos + i}`;
                        explorerState.editedCells.set(cellKey, val);
                    });
                });
                
                // Original-Daten auch aktualisieren
                explorerState.originalData.forEach((row, rowIndex) => {
                    const keyValue = String(row[currentKeyIndex] || '').trim();
                    const sourceRow = sourceMap.get(keyValue);
                    
                    const newValues = sourceIndices.map(colIdx => {
                        return sourceRow ? (sourceRow[colIdx] || '') : '';
                    });
                    
                    row.splice(actualInsertPos, 0, ...newValues);
                });
                
                // CellStyles, Formulas, Hyperlinks, RichText anpassen (Spalten-Indizes verschieben)
                const shiftColumnIndices = (obj) => {
                    const newObj = {};
                    for (const [key, value] of Object.entries(obj)) {
                        const [rowStr, colStr] = key.split('-');
                        const colIdx = parseInt(colStr);
                        if (colIdx >= actualInsertPos) {
                            // Spalte verschieben
                            newObj[`${rowStr}-${colIdx + newHeaders.length}`] = value;
                        } else {
                            newObj[key] = value;
                        }
                    }
                    return newObj;
                };
                
                explorerState.cellStyles = shiftColumnIndices(explorerState.cellStyles);
                explorerState.cellFormulas = shiftColumnIndices(explorerState.cellFormulas);
                explorerState.cellHyperlinks = shiftColumnIndices(explorerState.cellHyperlinks);
                explorerState.richTextCells = shiftColumnIndices(explorerState.richTextCells);
                
                // DataValidations anpassen (Keys sind Spalten-Indizes)
                const newValidations = {};
                for (const [colStr, validation] of Object.entries(explorerState.dataValidations)) {
                    const colIdx = parseInt(colStr);
                    if (colIdx >= actualInsertPos) {
                        newValidations[colIdx + newHeaders.length] = validation;
                    } else {
                        newValidations[colIdx] = validation;
                    }
                }
                explorerState.dataValidations = newValidations;
                
                // Key-Index anpassen wenn Spalten VOR der Schl√ºsselspalte eingef√ºgt wurden
                if (actualInsertPos <= currentKeyIndex) {
                    currentKeyIndex += newHeaders.length;
                }
                
                // Operation f√ºr Export speichern mit ORIGINAL-Position (vor allen Einf√ºgungen)
                insertOperations.push({
                    position: originalPositions.get(insertPos),
                    count: newHeaders.length,
                    headers: newHeaders
                });
                
                totalInsertCount += newHeaders.length;
            });
            
            // Strukturelle √Ñnderung markieren f√ºr korrekten Export (mit allen Operationen)
            // Sortiere aufsteigend nach Position f√ºr den Export
            explorerState.editedCells.set('_columnInserted', {
                operations: insertOperations.sort((a, b) => a.position - b.position),
                totalCount: totalInsertCount
            });
            
            // Markierung f√ºr nicht gefundene Zeilen
            // WICHTIG: currentKeyIndex enth√§lt den korrekten Index nach allen Einf√ºgungen!
            if (markNotFound) {
                explorerState.data.forEach((row, rowIndex) => {
                    const keyValue = String(row[currentKeyIndex] || '').trim();
                    if (keyValue && !sourceMap.has(keyValue)) {
                        explorerState.rowHighlights.set(rowIndex, 'yellow');
                    }
                });
            }
            
            // UI aktualisieren
            filterExplorerData();
            closeDataJoinModal();
            
            // Matches z√§hlen
            let matchCount = 0;
            explorerState.data.forEach(row => {
                const keyValue = String(row[currentKeyIndex] || '').trim();
                if (keyValue && sourceMap.has(keyValue)) matchCount++;
            });
            
            showNotification(
                `‚úì ${totalInsertCount} Spalte(n) hinzugef√ºgt! ${matchCount} von ${explorerState.data.length} Zeilen mit Daten gef√ºllt.`,
                'success',
                5000
            );
        }
        
        // ==================== Sheet Management Functions ====================
        let selectedSheetForManagement = null;
        
        function openSheetManageModal() {
            if (!explorerState.filePath || explorerState.sheets.length === 0) {
                showNotification('Bitte zuerst eine Datei laden', 'warning');
                return;
            }
            
            selectedSheetForManagement = null;
            updateSheetManageList();
            updateSheetManageButtons();
            document.getElementById('sheetManageModal').classList.remove('hidden');
        }
        
        function closeSheetManageModal() {
            document.getElementById('sheetManageModal').classList.add('hidden');
        }
        
        function updateSheetManageList() {
            const listContainer = document.getElementById('sheetManageList');
            if (!listContainer) return;
            
            if (explorerState.sheets.length === 0) {
                listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted);">Keine Arbeitsbl√§tter vorhanden</div>';
                return;
            }
            
            listContainer.innerHTML = explorerState.sheets.map((sheetName, index) => {
                const isSelected = sheetName === selectedSheetForManagement;
                const isActive = sheetName === explorerState.selectedSheet;
                return `<div class="sheet-list-item${isSelected ? ' selected' : ''}" data-sheet="${escapeHtml(sheetName)}" data-index="${index}">
                    <span class="sheet-index">${index + 1}.</span>
                    <span class="sheet-name">${escapeHtml(sheetName)}</span>
                    ${isActive ? '<span class="sheet-active-badge">Aktiv</span>' : ''}
                </div>`;
            }).join('');
            
            // Event-Listener f√ºr Klick auf Sheet-Items
            listContainer.querySelectorAll('.sheet-list-item').forEach(item => {
                item.addEventListener('click', () => {
                    selectedSheetForManagement = item.dataset.sheet;
                    updateSheetManageList();
                    updateSheetManageButtons();
                });
            });
        }
        
        function updateSheetManageButtons() {
            const hasSelection = selectedSheetForManagement !== null;
            const selectedIndex = explorerState.sheets.indexOf(selectedSheetForManagement);
            const isFirst = selectedIndex === 0;
            const isLast = selectedIndex === explorerState.sheets.length - 1;
            const canDelete = explorerState.sheets.length > 1;
            
            document.getElementById('btnSheetRename').disabled = !hasSelection;
            document.getElementById('btnSheetClone').disabled = !hasSelection;
            document.getElementById('btnSheetDelete').disabled = !hasSelection || !canDelete;
            document.getElementById('btnSheetMoveUp').disabled = !hasSelection || isFirst;
            document.getElementById('btnSheetMoveDown').disabled = !hasSelection || isLast;
        }
        
        async function addNewSheet() {
            const name = await showPromptDialog('Neues Arbeitsblatt', 'Name f√ºr das neue Arbeitsblatt:', 'Neues Blatt');
            if (!name) return;
            
            try {
                const result = await window.electronAPI.addSheet({
                    filePath: explorerState.filePath,
                    sheetName: name
                });
                
                if (result.success) {
                    explorerState.sheets = result.sheets;
                    updateSheetDropdown();
                    updateSheetManageList();
                    showNotification(`Arbeitsblatt "${name}" hinzugef√ºgt`, 'success');
                } else {
                    showNotification(result.error, 'error');
                }
            } catch (error) {
                showNotification('Fehler beim Hinzuf√ºgen: ' + error.message, 'error');
            }
        }
        
        async function renameSelectedSheet() {
            if (!selectedSheetForManagement) return;
            
            const newName = await showPromptDialog('Arbeitsblatt umbenennen', `Neuer Name f√ºr "${selectedSheetForManagement}":`, selectedSheetForManagement);
            if (!newName || newName === selectedSheetForManagement) return;
            
            try {
                const result = await window.electronAPI.renameSheet({
                    filePath: explorerState.filePath,
                    oldName: selectedSheetForManagement,
                    newName: newName
                });
                
                if (result.success) {
                    const wasActive = explorerState.selectedSheet === selectedSheetForManagement;
                    explorerState.sheets = result.sheets;
                    if (wasActive) {
                        explorerState.selectedSheet = newName;
                    }
                    selectedSheetForManagement = newName;
                    updateSheetDropdown();
                    updateSheetManageList();
                    showNotification(`Arbeitsblatt umbenannt zu "${newName}"`, 'success');
                } else {
                    showNotification(result.error, 'error');
                }
            } catch (error) {
                showNotification('Fehler beim Umbenennen: ' + error.message, 'error');
            }
        }
        
        async function cloneSelectedSheet() {
            if (!selectedSheetForManagement) return;
            
            const newName = await showPromptDialog('Arbeitsblatt kopieren', `Name f√ºr die Kopie von "${selectedSheetForManagement}":`, selectedSheetForManagement + ' (Kopie)');
            if (!newName) return;
            
            try {
                const result = await window.electronAPI.cloneSheet({
                    filePath: explorerState.filePath,
                    sheetName: selectedSheetForManagement,
                    newName: newName
                });
                
                if (result.success) {
                    explorerState.sheets = result.sheets;
                    updateSheetDropdown();
                    updateSheetManageList();
                    showNotification(`Arbeitsblatt kopiert als "${newName}"`, 'success');
                } else {
                    showNotification(result.error, 'error');
                }
            } catch (error) {
                showNotification('Fehler beim Kopieren: ' + error.message, 'error');
            }
        }
        
        async function moveSelectedSheet(direction) {
            if (!selectedSheetForManagement) return;
            
            const currentIndex = explorerState.sheets.indexOf(selectedSheetForManagement);
            const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
            
            if (newIndex < 0 || newIndex >= explorerState.sheets.length) return;
            
            try {
                const result = await window.electronAPI.moveSheet({
                    filePath: explorerState.filePath,
                    sheetName: selectedSheetForManagement,
                    newIndex: newIndex
                });
                
                if (result.success) {
                    explorerState.sheets = result.sheets;
                    updateSheetDropdown();
                    updateSheetManageList();
                    updateSheetManageButtons();
                    showNotification(`Arbeitsblatt verschoben`, 'success');
                } else {
                    showNotification(result.error, 'error');
                }
            } catch (error) {
                showNotification('Fehler beim Verschieben: ' + error.message, 'error');
            }
        }
        
        async function deleteSelectedSheet() {
            if (!selectedSheetForManagement) return;
            if (explorerState.sheets.length <= 1) {
                showNotification('Das letzte Arbeitsblatt kann nicht gel√∂scht werden', 'warning');
                return;
            }
            
            const confirmed = await showConfirmDialog('Arbeitsblatt l√∂schen', `M√∂chten Sie das Arbeitsblatt "${selectedSheetForManagement}" wirklich l√∂schen?\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden!`);
            if (!confirmed) return;
            
            try {
                const wasActive = explorerState.selectedSheet === selectedSheetForManagement;
                
                const result = await window.electronAPI.deleteSheet({
                    filePath: explorerState.filePath,
                    sheetName: selectedSheetForManagement
                });
                
                if (result.success) {
                    explorerState.sheets = result.sheets;
                    selectedSheetForManagement = null;
                    
                    // Wenn das aktive Sheet gel√∂scht wurde, das erste laden
                    if (wasActive && explorerState.sheets.length > 0) {
                        explorerState.selectedSheet = explorerState.sheets[0];
                        await loadExplorerSheet(explorerState.sheets[0]);
                    }
                    
                    updateSheetDropdown();
                    updateSheetManageList();
                    updateSheetManageButtons();
                    showNotification(`Arbeitsblatt gel√∂scht`, 'success');
                } else {
                    showNotification(result.error, 'error');
                }
            } catch (error) {
                showNotification('Fehler beim L√∂schen: ' + error.message, 'error');
            }
        }
        
        function updateSheetDropdown() {
            if (elements.explorerSheetSelect) {
                elements.explorerSheetSelect.innerHTML = explorerState.sheets.map(s => 
                    `<option value="${escapeHtml(s)}"${s === explorerState.selectedSheet ? ' selected' : ''}>${escapeHtml(s)}</option>`
                ).join('');
            }
        }
        
        // Explorer-State komplett zur√ºcksetzen
        function resetExplorerState() {
            explorerState.filePath = null;
            explorerState.fileName = null;
            explorerState.sheets = [];
            explorerState.selectedSheet = null;
            explorerState.headers = [];
            explorerState.data = [];
            explorerState.originalData = [];
            explorerState.filteredData = [];
            explorerState.searchTerm = '';
            explorerState.filters = [];
            explorerState.visibleColumns = [];
            explorerState.columnOrder = [];
            explorerState.editedCells.clear();
            explorerState.currentPage = 1;
            explorerState.sortColumn = null;
            explorerState.sortDirection = null;
            explorerState.sortType = 'auto';
            explorerState.rowHighlights.clear();
            explorerState.selectedRows.clear();
            explorerState.moveMode = false;
            explorerState.draggedColumn = null;
            explorerState.selectedCells.clear();
            explorerState.selectionAnchor = null;
            explorerState.isSelecting = false;
            explorerState.sheetDataCache.clear();
            explorerState.dataValidations = {};
            explorerState.cellStyles = {};
            explorerState.cellFormulas = {};

            explorerState.cellHyperlinks = {};
            explorerState.richTextCells = {};
            explorerState.hiddenRows.clear();
            explorerState.autoFilterRange = null;
            explorerState.mergedCells = [];
            explorerState.filePassword = null;
            explorerState.rowMapping = null;  // Mapping: neue Position -> Original Excel-Zeile
            
            // UI zur√ºcksetzen
            if (elements.explorerSheetSelect) {
                elements.explorerSheetSelect.innerHTML = '<option value="">-- Sheet w√§hlen --</option>';
            }
            if (elements.explorerSearch) {
                elements.explorerSearch.value = '';
            }
            const explorerFileName = document.getElementById('explorerFileName');
            if (explorerFileName) {
                explorerFileName.textContent = currentLanguage === 'en' ? 'No file loaded' : 'Keine Datei geladen';
            }
            // Nur thead und tbody leeren, nicht die gesamte Tabelle (sonst werden die Element-Referenzen ung√ºltig)
            if (elements.explorerTableHead) {
                elements.explorerTableHead.innerHTML = '';
            }
            if (elements.explorerTableBody) {
                elements.explorerTableBody.innerHTML = '';
            }
            // Drop-Zone wieder anzeigen
            showExplorerDropZone(true);
            
            const explorerResultCount = document.getElementById('explorerResultCount');
            if (explorerResultCount) {
                explorerResultCount.textContent = currentLanguage === 'en' ? 'No data loaded.' : 'Keine Daten geladen.';
            }
            
            // Indikatoren zur√ºcksetzen (verstecken statt entfernen)
            const hiddenRowsIndicator = document.getElementById('hiddenRowsIndicator');
            if (hiddenRowsIndicator) hiddenRowsIndicator.remove();
            const hiddenColumnsIndicator = document.getElementById('hiddenColumnsIndicator');
            if (hiddenColumnsIndicator) hiddenColumnsIndicator.remove();
            const autoFilterIndicator = document.getElementById('autoFilterIndicator');
            if (autoFilterIndicator) autoFilterIndicator.style.display = 'none';
            const passwordIndicator = document.getElementById('passwordIndicator');
            if (passwordIndicator) passwordIndicator.remove();
            
            // Filter-UI zur√ºcksetzen
            const explorerFiltersEl = document.getElementById('explorerFilters');
            if (explorerFiltersEl) explorerFiltersEl.innerHTML = '';
            const btnClearFilters = document.getElementById('btnClearExplorerFilters');
            if (btnClearFilters) btnClearFilters.disabled = true;
            
            // Spalten-Panel zur√ºcksetzen und schlie√üen
            const columnToggles = document.getElementById('columnToggles');
            if (columnToggles) columnToggles.innerHTML = '';
            const columnTogglePanel = document.getElementById('columnTogglePanel');
            if (columnTogglePanel) columnTogglePanel.style.display = 'none';
            
            // Status zur√ºcksetzen
            if (elements.explorerStatus) {
                elements.explorerStatus.textContent = '';
                elements.explorerStatus.style.color = '#ff9800';
            }
            
            // Pagination zur√ºcksetzen
            const explorerPagination = document.getElementById('explorerPagination');
            if (explorerPagination) explorerPagination.style.display = 'none';
            
            // Auto-Save Intervall stoppen
            stopExplorerAutoSave();
        }
        
        // Auto-Save f√ºr Crash-Recovery starten
        function startExplorerAutoSave() {
            // Alle 30 Sekunden speichern
            if (explorerAutoSaveInterval) {
                clearInterval(explorerAutoSaveInterval);
            }
            explorerAutoSaveInterval = setInterval(saveExplorerRecoveryData, 30000);
            // Sofort einmal speichern
            saveExplorerRecoveryData();
        }
        
        // Auto-Save stoppen
        function stopExplorerAutoSave() {
            if (explorerAutoSaveInterval) {
                clearInterval(explorerAutoSaveInterval);
                explorerAutoSaveInterval = null;
            }
        }
        
        // Recovery-Daten speichern
        function saveExplorerRecoveryData() {
            if (!explorerState.filePath || explorerState.data.length === 0) {
                return;
            }
            
            try {
                // Aktuelles Sheet im Cache speichern
                saveCurrentSheetToCache();
                
                // Nur speichern wenn es √Ñnderungen gibt
                const totalChanges = countAllChanges();
                if (totalChanges === 0) {
                    // Keine √Ñnderungen - Recovery-Daten l√∂schen
                    localStorage.removeItem(EXPLORER_RECOVERY_KEY);
                    return;
                }
                
                // Map/Set zu Arrays konvertieren f√ºr JSON
                const editedCellsArray = Array.from(explorerState.editedCells.entries());
                const rowHighlightsArray = Array.from(explorerState.rowHighlights.entries());
                
                // Sheet-Cache konvertieren
                const sheetCacheArray = [];
                for (const [sheetName, cached] of explorerState.sheetDataCache) {
                    sheetCacheArray.push({
                        sheetName,
                        headers: cached.headers,
                        data: cached.data,
                        originalData: cached.originalData,
                        visibleColumns: cached.visibleColumns,
                        editedCells: Array.from(cached.editedCells.entries()),
                        rowHighlights: Array.from(cached.rowHighlights.entries())
                    });
                }
                
                const recoveryData = {
                    timestamp: Date.now(),
                    filePath: explorerState.filePath,
                    fileName: explorerState.fileName,
                    sheets: explorerState.sheets,
                    selectedSheet: explorerState.selectedSheet,
                    headers: explorerState.headers,
                    data: explorerState.data,
                    originalData: explorerState.originalData,
                    visibleColumns: explorerState.visibleColumns,
                    columnOrder: explorerState.columnOrder,
                    editedCells: editedCellsArray,
                    rowHighlights: rowHighlightsArray,
                    sheetDataCache: sheetCacheArray
                };
                
                localStorage.setItem(EXPLORER_RECOVERY_KEY, JSON.stringify(recoveryData));
            } catch (e) {
                console.warn('Explorer Recovery-Speicherung fehlgeschlagen:', e);
            }
        }
        
        // Recovery-Daten laden
        function loadExplorerRecoveryData() {
            try {
                const saved = localStorage.getItem(EXPLORER_RECOVERY_KEY);
                if (!saved) return null;
                
                const data = JSON.parse(saved);
                
                // Pr√ºfe ob Daten nicht √§lter als 24 Stunden sind
                const maxAge = 24 * 60 * 60 * 1000; // 24 Stunden
                if (Date.now() - data.timestamp > maxAge) {
                    localStorage.removeItem(EXPLORER_RECOVERY_KEY);
                    return null;
                }
                
                return data;
            } catch (e) {
                console.warn('Explorer Recovery-Laden fehlgeschlagen:', e);
                localStorage.removeItem(EXPLORER_RECOVERY_KEY);
                return null;
            }
        }
        
        // Recovery-Daten anwenden
        function applyExplorerRecoveryData(data) {
            explorerState.filePath = data.filePath;
            explorerState.fileName = data.fileName;
            explorerState.sheets = data.sheets || [];
            explorerState.selectedSheet = data.selectedSheet;
            explorerState.headers = data.headers;
            explorerState.data = data.data;
            explorerState.originalData = data.originalData || data.data.map(row => [...row]);
            explorerState.visibleColumns = data.visibleColumns;
            explorerState.columnOrder = data.columnOrder || [];
            
            // Map/Set aus Arrays wiederherstellen
            explorerState.editedCells = new Map(data.editedCells || []);
            explorerState.rowHighlights = new Map(data.rowHighlights || []);
            
            // Sheet-Cache wiederherstellen
            explorerState.sheetDataCache.clear();
            if (data.sheetDataCache) {
                for (const cached of data.sheetDataCache) {
                    explorerState.sheetDataCache.set(cached.sheetName, {
                        headers: cached.headers,
                        data: cached.data,
                        originalData: cached.originalData || cached.data.map(row => [...row]),
                        visibleColumns: cached.visibleColumns,
                        editedCells: new Map(cached.editedCells || []),
                        rowHighlights: new Map(cached.rowHighlights || []),
                        hiddenRows: new Set(cached.hiddenRows || [])
                    });
                }
            }
            
            // UI aktualisieren
            const explorerFileName = document.getElementById('explorerFileName');
            if (explorerFileName) {
                explorerFileName.textContent = explorerState.fileName || '';
            }
            
            // Sheet-Dropdown f√ºllen
            if (elements.explorerSheetSelect && explorerState.sheets.length > 0) {
                elements.explorerSheetSelect.innerHTML = explorerState.sheets.map(s => 
                    `<option value="${s}" ${s === explorerState.selectedSheet ? 'selected' : ''}>${s}</option>`
                ).join('');
            }
            
            // Daten filtern und anzeigen
            filterExplorerData();
            
            // Auto-Save starten
            startExplorerAutoSave();
        }
        
        // Recovery-Daten l√∂schen
        function clearExplorerRecoveryData() {
            localStorage.removeItem(EXPLORER_RECOVERY_KEY);
        }
        
        // Kontextmen√º f√ºr Zeilen-Markierung
        const highlightColors = [
            { name: 'Gr√ºn', value: 'green', hex: '#4CAF50' },
            { name: 'Gelb', value: 'yellow', hex: '#FFEB3B' },
            { name: 'Orange', value: 'orange', hex: '#FF9800' },
            { name: 'Rot', value: 'red', hex: '#F44336' },
            { name: 'Blau', value: 'blue', hex: '#2196F3' },
            { name: 'Lila', value: 'purple', hex: '#9C27B0' }
        ];
        
        function showRowContextMenu(e, rowIndex) {
            e.preventDefault();
            
            // Altes Zeilen-Men√º entfernen (nur row-context-menu, nicht das column-context-menu)
            const oldMenu = document.querySelector('.row-context-menu');
            if (oldMenu) oldMenu.remove();
            
            const currentColor = explorerState.rowHighlights.get(rowIndex);
            
            let menuHtml = '<div class="context-menu row-context-menu">';
            menuHtml += '<div class="context-menu-item" style="font-weight: 600; color: var(--text-muted); cursor: default;">üé® Zeile markieren</div>';
            menuHtml += '<div class="context-menu-divider"></div>';
            
            highlightColors.forEach(color => {
                const selected = currentColor === color.value ? ' ‚úì' : '';
                menuHtml += `
                    <div class="context-menu-item" data-action="highlight" data-color="${color.value}" data-row="${rowIndex}">
                        <span class="color-dot" style="background: ${color.hex};"></span>
                        <span>${color.name}${selected}</span>
                    </div>
                `;
            });
            
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="clear" data-row="${rowIndex}">üö´ Markierung entfernen</div>`;
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="insert-row-above" data-row="${rowIndex}">‚¨ÜÔ∏è Zeile oberhalb einf√ºgen</div>`;
            menuHtml += `<div class="context-menu-item" data-action="insert-row-below" data-row="${rowIndex}">‚¨áÔ∏è Zeile unterhalb einf√ºgen</div>`;
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="hide-row" data-row="${rowIndex}">üëÅÔ∏è‚Äçüó®Ô∏è Zeile ausblenden</div>`;
            menuHtml += `<div class="context-menu-item" data-action="delete-row" data-row="${rowIndex}" style="color: #F44336;">üóëÔ∏è Zeile l√∂schen</div>`;
            menuHtml += '</div>';
            
            const menu = document.createElement('div');
            menu.innerHTML = menuHtml;
            document.body.appendChild(menu.firstElementChild);
            
            const menuEl = document.querySelector('.row-context-menu');
            
            // Positionierung
            let x = e.clientX;
            let y = e.clientY;
            
            // Sicherstellen, dass das Men√º im Viewport bleibt
            const menuRect = menuEl.getBoundingClientRect();
            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 5;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 5;
            }
            
            menuEl.style.left = x + 'px';
            menuEl.style.top = y + 'px';
            
            // Event-Handler
            menuEl.querySelectorAll('[data-action="highlight"]').forEach(item => {
                item.addEventListener('click', () => {
                    const color = item.dataset.color;
                    const row = parseInt(item.dataset.row);
                    setRowHighlight(row, color);
                    menuEl.remove();
                });
            });
            
            menuEl.querySelector('[data-action="clear"]').addEventListener('click', () => {
                const row = parseInt(menuEl.querySelector('[data-action="clear"]').dataset.row);
                clearRowHighlight(row);
                menuEl.remove();
            });
            
            // Neue Zeilen-Aktionen
            menuEl.querySelector('[data-action="insert-row-above"]')?.addEventListener('click', () => {
                const row = parseInt(menuEl.querySelector('[data-action="insert-row-above"]').dataset.row);
                insertExplorerRow(row, 'above');
                menuEl.remove();
            });
            
            menuEl.querySelector('[data-action="insert-row-below"]')?.addEventListener('click', () => {
                const row = parseInt(menuEl.querySelector('[data-action="insert-row-below"]').dataset.row);
                insertExplorerRow(row, 'below');
                menuEl.remove();
            });
            
            menuEl.querySelector('[data-action="delete-row"]')?.addEventListener('click', () => {
                const row = parseInt(menuEl.querySelector('[data-action="delete-row"]').dataset.row);
                deleteExplorerRow(row);
                menuEl.remove();
            });
            
            menuEl.querySelector('[data-action="hide-row"]')?.addEventListener('click', () => {
                const row = parseInt(menuEl.querySelector('[data-action="hide-row"]').dataset.row);
                hideExplorerRow(row);
                menuEl.remove();
            });
            
            // Men√º bei Klick au√üerhalb schlie√üen
            const closeHandler = (event) => {
                if (!menuEl.contains(event.target)) {
                    menuEl.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            setTimeout(() => document.addEventListener('click', closeHandler), 10);
        }
        
        function setRowHighlight(rowIndex, color) {
            explorerState.rowHighlights.set(rowIndex, color);
            // Strukturelle √Ñnderung markieren f√ºr Export
            explorerState.editedCells.set('_rowHighlightChanged', true);
            applyRowHighlights();
        }
        
        function clearRowHighlight(rowIndex) {
            explorerState.rowHighlights.delete(rowIndex);
            // Strukturelle √Ñnderung markieren f√ºr Export
            explorerState.editedCells.set('_rowHighlightChanged', true);
            
            // Fill aus cellStyles f√ºr alle Zellen dieser Zeile entfernen
            // (damit die inline-Styles nicht die Entfernung √ºberschreiben)
            // WICHTIG: cellStyles verwendet 1-basierte rowIndex Keys!
            const colCount = explorerState.headers.length;
            for (let colIdx = 0; colIdx < colCount; colIdx++) {
                const cellKey = `${rowIndex + 1}-${colIdx}`;
                if (explorerState.cellStyles[cellKey] && explorerState.cellStyles[cellKey].fill) {
                    delete explorerState.cellStyles[cellKey].fill;
                }
            }
            
            applyRowHighlights();
            // Tabelle neu rendern um die Styles zu aktualisieren
            renderExplorerTable();
        }
        
        function applyRowHighlights() {
            // Alle Highlights entfernen
            document.querySelectorAll('#explorerTableBody tr').forEach(tr => {
                tr.classList.remove('row-highlight-green', 'row-highlight-yellow', 'row-highlight-orange', 
                                   'row-highlight-red', 'row-highlight-blue', 'row-highlight-purple');
            });
            
            // Neue Highlights setzen
            explorerState.rowHighlights.forEach((color, rowIndex) => {
                const tr = document.querySelector(`#explorerTableBody tr[data-original-index="${rowIndex}"]`);
                if (tr) {
                    tr.classList.add(`row-highlight-${color}`);
                }
            });
        }
        
        // ==================== Zeilen/Spalten Einf√ºgen/L√∂schen ====================
        
        // Neue Zeile einf√ºgen
        function insertExplorerRow(rowIndex, position = 'below') {
            const insertIndex = position === 'above' ? rowIndex : rowIndex + 1;
            
            // Leere Zeile erstellen mit gleicher Anzahl Spalten
            const emptyRow = new Array(explorerState.headers.length).fill('');
            
            // Zeile in data einf√ºgen
            explorerState.data.splice(insertIndex, 0, emptyRow);
            explorerState.originalData.splice(insertIndex, 0, [...emptyRow]);
            
            // Highlights anpassen (Indizes verschieben)
            const newHighlights = new Map();
            explorerState.rowHighlights.forEach((color, idx) => {
                if (idx >= insertIndex) {
                    newHighlights.set(idx + 1, color);
                } else {
                    newHighlights.set(idx, color);
                }
            });
            explorerState.rowHighlights = newHighlights;
            
            // EditedCells anpassen
            const newEditedCells = new Map();
            explorerState.editedCells.forEach((value, key) => {
                if (key.startsWith('_')) {
                    newEditedCells.set(key, value);
                    return;
                }
                const [rowStr, colStr] = key.split('-');
                const row = parseInt(rowStr);
                const col = parseInt(colStr);
                if (row >= insertIndex) {
                    newEditedCells.set(`${row + 1}-${col}`, value);
                } else {
                    newEditedCells.set(key, value);
                }
            });
            explorerState.editedCells = newEditedCells;
            
            // Alle Zellen der neuen Zeile als bearbeitet markieren
            for (let col = 0; col < explorerState.headers.length; col++) {
                explorerState.editedCells.set(`${insertIndex}-${col}`, '');
            }
            
            // WICHTIG: Strukturelle √Ñnderung markieren f√ºr Export (Full Rewrite n√∂tig)
            explorerState.editedCells.set('_rowInserted', true);
            
            // UI aktualisieren
            filterExplorerData();
            showFloatingStatus(t('rowInserted'));
        }
        
        // Zeile l√∂schen
        async function deleteExplorerRow(rowIndex) {
            // Best√§tigung bei einzelner Zeile
            const rowPreview = explorerState.data[rowIndex]?.slice(0, 3).join(', ') || '';
            const rowLabel = currentLanguage === 'en' ? 'Row' : 'Zeile';
            const confirmed = await showConfirmDialog(
                t('deleteRowTitle'),
                `${t('deleteRowConfirm')}\n\n${rowLabel} ${rowIndex + 1}: ${rowPreview}...`,
                currentLanguage === 'en' ? 'Delete' : 'L√∂schen',
                t('cancel')
            );
            
            if (!confirmed) return;
            
            // Zeile aus data entfernen
            explorerState.data.splice(rowIndex, 1);
            explorerState.originalData.splice(rowIndex, 1);
            
            // Highlights anpassen
            const newHighlights = new Map();
            explorerState.rowHighlights.forEach((color, idx) => {
                if (idx > rowIndex) {
                    newHighlights.set(idx - 1, color);
                } else if (idx < rowIndex) {
                    newHighlights.set(idx, color);
                }
                // idx === rowIndex wird nicht √ºbernommen (gel√∂scht)
            });
            explorerState.rowHighlights = newHighlights;
            
            // EditedCells anpassen
            const newEditedCells = new Map();
            explorerState.editedCells.forEach((value, key) => {
                if (key.startsWith('_')) {
                    newEditedCells.set(key, value);
                    return;
                }
                const [rowStr, colStr] = key.split('-');
                const row = parseInt(rowStr);
                const col = parseInt(colStr);
                if (row > rowIndex) {
                    newEditedCells.set(`${row - 1}-${col}`, value);
                } else if (row < rowIndex) {
                    newEditedCells.set(key, value);
                }
                // row === rowIndex wird nicht √ºbernommen
            });
            explorerState.editedCells = newEditedCells;
            
            // Markierung, dass etwas gel√∂scht wurde (f√ºr √Ñnderungsz√§hlung)
            explorerState.editedCells.set('_rowDeleted', true);
            
            // UI aktualisieren
            filterExplorerData();
            showFloatingStatus(t('rowDeleted'));
        }
        
        // Zeile ausblenden
        function hideExplorerRow(rowIndex) {
            explorerState.hiddenRows.add(rowIndex);
            // Markierung, dass Zeilen-Sichtbarkeit ge√§ndert wurde
            explorerState.editedCells.set('_rowVisibilityChanged', true);
            filterExplorerData();
            updateExplorerEditStatus();
            updateHiddenRowsIndicator();
            showFloatingStatus(currentLanguage === 'en' ? 'Row hidden' : 'Zeile ausgeblendet');
        }
        
        // Zeile wieder einblenden
        function showExplorerRow(rowIndex) {
            explorerState.hiddenRows.delete(rowIndex);
            // Markierung, dass Zeilen-Sichtbarkeit ge√§ndert wurde
            explorerState.editedCells.set('_rowVisibilityChanged', true);
            filterExplorerData();
            updateExplorerEditStatus();
            updateHiddenRowsIndicator();
            showFloatingStatus(currentLanguage === 'en' ? 'Row shown' : 'Zeile eingeblendet');
        }
        
        // Alle versteckten Zeilen einblenden
        function showAllHiddenRows() {
            explorerState.hiddenRows.clear();
            explorerState.editedCells.set('_rowVisibilityChanged', true);
            filterExplorerData();
            updateExplorerEditStatus();
            updateHiddenRowsIndicator();
            showFloatingStatus(currentLanguage === 'en' ? 'All rows shown' : 'Alle Zeilen eingeblendet');
        }
        
        // Indikator f√ºr versteckte Zeilen aktualisieren
        function updateHiddenRowsIndicator() {
            let indicator = document.getElementById('hiddenRowsIndicator');
            const count = explorerState.hiddenRows.size;
            
            if (count === 0) {
                if (indicator) indicator.remove();
                return;
            }
            
            if (!indicator) {
                // Erstelle Indikator-Button
                indicator = document.createElement('button');
                indicator.id = 'hiddenRowsIndicator';
                indicator.className = 'btn btn-warning btn-sm';
                indicator.title = currentLanguage === 'en' ? 'Click to show hidden rows' : 'Klicken um versteckte Zeilen anzuzeigen';
                
                // F√ºge in den festen Container ein
                const container = document.getElementById('hiddenIndicatorsContainer');
                if (container) {
                    container.appendChild(indicator);
                }
            }
            
            indicator.innerHTML = `‚ò∞ ${count} ${currentLanguage === 'en' ? 'rows hidden' : 'Zeilen ausgeblendet'}`;
            indicator.onclick = showHiddenRowsMenu;
        }
        
        // Men√º f√ºr versteckte Zeilen anzeigen
        function showHiddenRowsMenu(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Altes Men√º entfernen
            const oldMenu = document.querySelector('.hidden-rows-menu');
            if (oldMenu) oldMenu.remove();
            
            let menuHtml = '<div class="context-menu hidden-rows-menu">';
            menuHtml += `<div class="context-menu-item" style="font-weight: 600; color: var(--text-muted); cursor: default;">‚ò∞ ${currentLanguage === 'en' ? 'Hidden Rows' : 'Versteckte Zeilen'}</div>`;
            menuHtml += '<div class="context-menu-divider"></div>';
            
            // Liste der versteckten Zeilen (max 20 anzeigen)
            const hiddenArray = Array.from(explorerState.hiddenRows).sort((a, b) => a - b);
            const displayLimit = 20;
            
            hiddenArray.slice(0, displayLimit).forEach(rowIndex => {
                const rowPreview = explorerState.data[rowIndex]?.slice(0, 2).join(', ').substring(0, 30) || '...';
                menuHtml += `<div class="context-menu-item" data-action="show-row" data-row="${rowIndex}">
                    üëÅÔ∏è ${currentLanguage === 'en' ? 'Row' : 'Zeile'} ${rowIndex + 1}: ${escapeHtml(rowPreview)}...
                </div>`;
            });
            
            if (hiddenArray.length > displayLimit) {
                menuHtml += `<div class="context-menu-item" style="color: var(--text-muted); cursor: default;">... und ${hiddenArray.length - displayLimit} weitere</div>`;
            }
            
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += '<div class="context-menu-item" data-action="show-all" style="color: var(--primary);">‚úÖ Alle einblenden</div>';
            menuHtml += '</div>';
            
            const menu = document.createElement('div');
            menu.innerHTML = menuHtml;
            document.body.appendChild(menu.firstElementChild);
            
            const menuEl = document.querySelector('.hidden-rows-menu');
            
            // Positionierung
            const rect = e.target.getBoundingClientRect();
            menuEl.style.left = rect.left + 'px';
            menuEl.style.top = (rect.bottom + 5) + 'px';
            
            // Event-Handler
            menuEl.querySelectorAll('[data-action="show-row"]').forEach(item => {
                item.addEventListener('click', () => {
                    const row = parseInt(item.dataset.row);
                    showExplorerRow(row);
                    menuEl.remove();
                });
            });
            
            menuEl.querySelector('[data-action="show-all"]')?.addEventListener('click', () => {
                showAllHiddenRows();
                menuEl.remove();
            });
            
            // Men√º bei Klick au√üerhalb schlie√üen
            const closeHandler = (event) => {
                if (!menuEl.contains(event.target)) {
                    menuEl.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            setTimeout(() => document.addEventListener('click', closeHandler), 10);
        }
        
        // Indikator f√ºr versteckte Spalten aktualisieren
        function updateHiddenColumnsIndicator() {
            let indicator = document.getElementById('hiddenColumnsIndicator');
            // Berechne Anzahl versteckter Spalten (alle Spalten die nicht in visibleColumns sind)
            const totalColumns = explorerState.headers.length;
            const hiddenCount = totalColumns - explorerState.visibleColumns.length;
            
            if (hiddenCount === 0) {
                if (indicator) indicator.remove();
                return;
            }
            
            if (!indicator) {
                // Erstelle Indikator-Button
                indicator = document.createElement('button');
                indicator.id = 'hiddenColumnsIndicator';
                indicator.className = 'btn btn-warning btn-sm';
                indicator.title = currentLanguage === 'en' ? 'Click to show hidden columns' : 'Klicken um versteckte Spalten anzuzeigen';
                
                // F√ºge in den festen Container ein
                const container = document.getElementById('hiddenIndicatorsContainer');
                if (container) {
                    container.appendChild(indicator);
                }
            }
            
            indicator.innerHTML = `üìä ${hiddenCount} ${currentLanguage === 'en' ? 'hidden' : 'ausgeblendet'}`;
            indicator.onclick = showHiddenColumnsMenu;
        }
        
        // Men√º f√ºr versteckte Spalten anzeigen
        function showHiddenColumnsMenu(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Altes Men√º entfernen
            const oldMenu = document.querySelector('.hidden-columns-menu');
            if (oldMenu) oldMenu.remove();
            
            // Versteckte Spalten ermitteln (alle die nicht in visibleColumns sind)
            const hiddenColumns = explorerState.headers
                .map((header, i) => ({ index: i, header }))
                .filter(({ index }) => !explorerState.visibleColumns.includes(index));
            
            let menuHtml = '<div class="context-menu hidden-columns-menu">';
            menuHtml += `<div class="context-menu-item" style="font-weight: 600; color: var(--text-muted); cursor: default;">üìä ${currentLanguage === 'en' ? 'Hidden Columns' : 'Versteckte Spalten'}</div>`;
            menuHtml += '<div class="context-menu-divider"></div>';
            
            // Liste der versteckten Spalten (max 20 anzeigen)
            const displayLimit = 20;
            
            hiddenColumns.slice(0, displayLimit).forEach(({ index, header }) => {
                const displayHeader = header ? header.substring(0, 30) : `Spalte ${index + 1}`;
                menuHtml += `<div class="context-menu-item" data-action="show-column" data-col="${index}">
                    üëÅÔ∏è ${escapeHtml(displayHeader)}${header && header.length > 30 ? '...' : ''}
                </div>`;
            });
            
            if (hiddenColumns.length > displayLimit) {
                menuHtml += `<div class="context-menu-item" style="color: var(--text-muted); cursor: default;">... ${currentLanguage === 'en' ? 'and' : 'und'} ${hiddenColumns.length - displayLimit} ${currentLanguage === 'en' ? 'more' : 'weitere'}</div>`;
            }
            
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="show-all" style="color: var(--primary);">‚úÖ ${currentLanguage === 'en' ? 'Show all' : 'Alle einblenden'}</div>`;
            menuHtml += '</div>';
            
            const menu = document.createElement('div');
            menu.innerHTML = menuHtml;
            document.body.appendChild(menu.firstElementChild);
            
            const menuEl = document.querySelector('.hidden-columns-menu');
            
            // Positionierung
            const rect = e.target.getBoundingClientRect();
            menuEl.style.left = rect.left + 'px';
            menuEl.style.top = (rect.bottom + 5) + 'px';
            
            // Event-Handler f√ºr einzelne Spalten
            menuEl.querySelectorAll('[data-action="show-column"]').forEach(item => {
                item.addEventListener('click', () => {
                    const col = parseInt(item.dataset.col);
                    showExplorerColumn(col);
                    menuEl.remove();
                });
            });
            
            menuEl.querySelector('[data-action="show-all"]')?.addEventListener('click', () => {
                showAllExplorerColumns();
                menuEl.remove();
            });
            
            // Men√º bei Klick au√üerhalb schlie√üen
            const closeHandler = (event) => {
                if (!menuEl.contains(event.target)) {
                    menuEl.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            setTimeout(() => document.addEventListener('click', closeHandler), 10);
        }
        
        // Einzelne Spalte wieder einblenden
        function showExplorerColumn(colIndex) {
            if (!explorerState.visibleColumns.includes(colIndex)) {
                explorerState.visibleColumns.push(colIndex);
                explorerState.visibleColumns.sort((a, b) => a - b);
            }
            // Markierung, dass Spalten-Sichtbarkeit ge√§ndert wurde
            explorerState.editedCells.set('_columnVisibilityChanged', true);
            renderExplorerTable();
            updateColumnToggles();
            updateHiddenColumnsIndicator();
            updateExplorerEditStatus();
            showFloatingStatus(currentLanguage === 'en' ? 'Column shown' : 'Spalte eingeblendet');
        }
        
        // Indikator f√ºr AutoFilter aktualisieren
        function updateAutoFilterIndicator() {
            const indicator = document.getElementById('autoFilterIndicator');
            if (!indicator) return;
            
            if (!explorerState.autoFilterRange) {
                indicator.style.display = 'none';
                return;
            }
            
            // Zeige Indikator
            let displayText = `‚ñº AutoFilter: ${explorerState.autoFilterRange}`;
            indicator.textContent = displayText;
            indicator.title = `AutoFilter aktiv: ${explorerState.autoFilterRange}\n(wird beim Speichern erhalten)`;
            indicator.style.display = 'inline-flex';
        }
        
        // Indikator f√ºr Passwortschutz aktualisieren
        function updatePasswordIndicator() {
            let indicator = document.getElementById('passwordIndicator');
            
            if (!explorerState.filePassword) {
                if (indicator) indicator.remove();
                return;
            }
            
            if (!indicator) {
                // Erstelle Indikator-Badge
                indicator = document.createElement('span');
                indicator.id = 'passwordIndicator';
                indicator.style.cssText = 'margin-left: 8px; background: #FF9800; color: white; font-size: 11px; padding: 3px 8px; border-radius: 4px; display: inline-flex; align-items: center; gap: 4px; vertical-align: middle;';
                
                // F√ºge nach dem Dateinamen ein
                const fileNameElement = document.getElementById('explorerFileName');
                if (fileNameElement && fileNameElement.parentElement) {
                    fileNameElement.parentElement.appendChild(indicator);
                }
            }
            
            indicator.innerHTML = `üîê Passwortgesch√ºtzt`;
            indicator.title = 'Diese Datei ist passwortgesch√ºtzt.\nDas Passwort wird beim Speichern beibehalten.';
        }
        
        // Neue Spalte einf√ºgen
        async function insertExplorerColumn(colIndex, position = 'after') {
            const insertIndex = position === 'before' ? colIndex : colIndex + 1;
            
            // Header-Namen abfragen
            const headerName = await showPromptDialog(
                t('newColumn'),
                t('enterColumnName'),
                t('newColumn')
            );
            
            if (headerName === null) return; // Abgebrochen
            
            // Header einf√ºgen
            explorerState.headers.splice(insertIndex, 0, headerName || t('newColumn'));
            
            // Alle Zeilen erweitern
            explorerState.data.forEach(row => {
                row.splice(insertIndex, 0, '');
            });
            explorerState.originalData.forEach(row => {
                row.splice(insertIndex, 0, '');
            });
            
            // VisibleColumns anpassen
            const newVisibleColumns = [];
            explorerState.visibleColumns.forEach(idx => {
                if (idx >= insertIndex) {
                    newVisibleColumns.push(idx + 1);
                } else {
                    newVisibleColumns.push(idx);
                }
            });
            newVisibleColumns.push(insertIndex); // Neue Spalte ist sichtbar
            newVisibleColumns.sort((a, b) => a - b);
            explorerState.visibleColumns = newVisibleColumns;
            
            // EditedCells anpassen
            const newEditedCells = new Map();
            explorerState.editedCells.forEach((value, key) => {
                if (key.startsWith('_')) {
                    newEditedCells.set(key, value);
                    return;
                }
                const [rowStr, colStr] = key.split('-');
                const row = parseInt(rowStr);
                const col = parseInt(colStr);
                if (col >= insertIndex) {
                    newEditedCells.set(`${row}-${col + 1}`, value);
                } else {
                    newEditedCells.set(key, value);
                }
            });
            explorerState.editedCells = newEditedCells;
            
            // Markierung dass Spalte hinzugef√ºgt wurde
            // Pr√ºfe ob bereits eine insertedColumns-Info existiert (z.B. von Data Join)
            const existingInsert = explorerState.editedCells.get('_columnInserted');
            if (existingInsert && existingInsert.operations) {
                // F√ºge neue Operation hinzu
                existingInsert.operations.push({
                    position: insertIndex,
                    count: 1,
                    headers: [headerName || t('newColumn')],
                    sourceColumn: colIndex  // Referenzspalte f√ºr Formatierung
                });
                existingInsert.totalCount = (existingInsert.totalCount || 0) + 1;
                explorerState.editedCells.set('_columnInserted', existingInsert);
            } else {
                // Neue insertedColumns-Info mit korrektem Format
                explorerState.editedCells.set('_columnInserted', { 
                    operations: [{
                        position: insertIndex,
                        count: 1,
                        headers: [headerName || t('newColumn')],
                        sourceColumn: colIndex  // Referenzspalte f√ºr Formatierung
                    }],
                    totalCount: 1
                });
            }
            
            // UI aktualisieren
            filterExplorerData();
            updateColumnToggles();
            showFloatingStatus(t('columnInserted'));
        }
        
        // Spalte l√∂schen
        async function deleteExplorerColumn(colIndex) {
            const columnName = explorerState.headers[colIndex] || `${currentLanguage === 'en' ? 'Column' : 'Spalte'} ${colIndex + 1}`;
            const columnLabel = currentLanguage === 'en' ? 'Column' : 'Spalte';
            
            const confirmed = await showConfirmDialog(
                t('deleteColumnTitle'),
                `${t('deleteColumnConfirm')}\n\n${columnLabel}: "${columnName}"\n\n${t('deleteColumnWarning')}`,
                currentLanguage === 'en' ? 'Delete' : 'L√∂schen',
                t('cancel')
            );
            
            if (!confirmed) return;
            
            // Header entfernen
            explorerState.headers.splice(colIndex, 1);
            
            // Alle Zeilen anpassen
            explorerState.data.forEach(row => {
                row.splice(colIndex, 1);
            });
            explorerState.originalData.forEach(row => {
                row.splice(colIndex, 1);
            });
            
            // VisibleColumns anpassen
            explorerState.visibleColumns = explorerState.visibleColumns
                .filter(idx => idx !== colIndex)
                .map(idx => idx > colIndex ? idx - 1 : idx);
            
            // EditedCells anpassen
            const newEditedCells = new Map();
            explorerState.editedCells.forEach((value, key) => {
                if (key.startsWith('_')) {
                    newEditedCells.set(key, value);
                    return;
                }
                const [rowStr, colStr] = key.split('-');
                const row = parseInt(rowStr);
                const col = parseInt(colStr);
                if (col > colIndex) {
                    newEditedCells.set(`${row}-${col - 1}`, value);
                } else if (col < colIndex) {
                    newEditedCells.set(key, value);
                }
                // col === colIndex wird nicht √ºbernommen
            });
            explorerState.editedCells = newEditedCells;
            
            // CellStyles anpassen
            const newCellStyles = {};
            for (const [key, value] of Object.entries(explorerState.cellStyles || {})) {
                const [rowStr, colStr] = key.split('-');
                const row = parseInt(rowStr);
                const col = parseInt(colStr);
                if (col > colIndex) {
                    newCellStyles[`${row}-${col - 1}`] = value;
                } else if (col < colIndex) {
                    newCellStyles[key] = value;
                }
            }
            explorerState.cellStyles = newCellStyles;
            
            // CellFormulas anpassen
            const newCellFormulas = {};
            for (const [key, value] of Object.entries(explorerState.cellFormulas || {})) {
                const [rowStr, colStr] = key.split('-');
                const row = parseInt(rowStr);
                const col = parseInt(colStr);
                if (col > colIndex) {
                    newCellFormulas[`${row}-${col - 1}`] = value;
                } else if (col < colIndex) {
                    newCellFormulas[key] = value;
                }
            }
            explorerState.cellFormulas = newCellFormulas;
            
            // CellHyperlinks anpassen
            const newCellHyperlinks = {};
            for (const [key, value] of Object.entries(explorerState.cellHyperlinks || {})) {
                const [rowStr, colStr] = key.split('-');
                const row = parseInt(rowStr);
                const col = parseInt(colStr);
                if (col > colIndex) {
                    newCellHyperlinks[`${row}-${col - 1}`] = value;
                } else if (col < colIndex) {
                    newCellHyperlinks[key] = value;
                }
            }
            explorerState.cellHyperlinks = newCellHyperlinks;
            
            // RichTextCells anpassen
            const newRichTextCells = {};
            for (const [key, value] of Object.entries(explorerState.richTextCells || {})) {
                const [rowStr, colStr] = key.split('-');
                const row = parseInt(rowStr);
                const col = parseInt(colStr);
                if (col > colIndex) {
                    newRichTextCells[`${row}-${col - 1}`] = value;
                } else if (col < colIndex) {
                    newRichTextCells[key] = value;
                }
            }
            explorerState.richTextCells = newRichTextCells;
            
            // Markierung dass Spalte gel√∂scht wurde - speichere als Array f√ºr mehrere L√∂schungen
            // WICHTIG: Wir speichern die ORIGINAL-Spaltenindizes (bezogen auf die urspr√ºngliche Datei)
            // colIndex ist der aktuelle Index nach vorherigen L√∂schungen im Frontend
            // Wir m√ºssen den Original-Index berechnen
            const existingDeleted = explorerState.editedCells.get('_columnDeleted');
            let deletedOriginalIndices = [];
            if (existingDeleted && Array.isArray(existingDeleted.originalIndices)) {
                deletedOriginalIndices = existingDeleted.originalIndices.slice();
            }
            
            // Berechne den Original-Index: 
            // F√ºr jeden vorherigen gel√∂schten Original-Index, der <= aktuellem+Offset war, erh√∂he den Offset
            let originalIndex = colIndex;
            for (const prevOrigIdx of deletedOriginalIndices.sort((a, b) => a - b)) {
                if (prevOrigIdx <= originalIndex) {
                    originalIndex++;
                }
            }
            
            deletedOriginalIndices.push(originalIndex);
            
            explorerState.editedCells.set('_columnDeleted', { 
                originalIndices: deletedOriginalIndices,  // Array der ORIGINAL-Spalten-Indices (0-basiert)
                count: deletedOriginalIndices.length,
                originalHeaderCount: (existingDeleted?.originalHeaderCount) || (explorerState.headers.length + 1)
            });
            
            // UI aktualisieren
            filterExplorerData();
            updateColumnToggles();
            showFloatingStatus(t('columnDeleted'));
        }
        
        // Prompt-Dialog f√ºr Texteingabe
        function showPromptDialog(title, message, defaultValue = '', inputType = 'text') {
            return new Promise((resolve) => {
                const existingDialog = document.querySelector('.prompt-dialog-overlay');
                if (existingDialog) existingDialog.remove();
                
                const overlay = document.createElement('div');
                overlay.className = 'prompt-dialog-overlay modal-overlay';
                overlay.style.zIndex = '99999';
                
                const closeDialog = (result) => {
                    overlay.remove();
                    resolve(result);
                };
                
                overlay.innerHTML = `
                    <div class="modal" style="max-width: 400px; width: 90%; min-width: 300px; min-height: auto;">
                        <div class="modal-header">
                            <div class="modal-title">${title}</div>
                        </div>
                        <div class="modal-body" style="padding: 20px;">
                            <p style="margin: 0 0 15px 0; color: var(--text-muted); white-space: pre-line;">${message}</p>
                            <input type="${inputType}" id="promptInput" value="${defaultValue}" style="width: 100%; padding: 12px; box-sizing: border-box; font-size: 14px; background: var(--bg-dark); border: 2px solid var(--border); border-radius: 6px; color: var(--text);">
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" id="promptCancel">${currentLanguage === 'en' ? 'Cancel' : 'Abbrechen'}</button>
                            <button class="btn btn-primary" id="promptConfirm">${currentLanguage === 'en' ? 'OK' : 'OK'}</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                const input = document.getElementById('promptInput');
                input.focus();
                input.select();
                
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        closeDialog(input.value);
                    } else if (e.key === 'Escape') {
                        closeDialog(null);
                    }
                });
                
                document.getElementById('promptCancel').onclick = () => closeDialog(null);
                document.getElementById('promptConfirm').onclick = () => closeDialog(input.value);
            });
        }
        
        // ==================== Zellen-Auswahl Funktionen ====================
        
        // Zellen-Auswahl visuell aktualisieren
        function updateCellSelectionUI() {
            // Alle Auswahl-Markierungen entfernen
            document.querySelectorAll('#explorerTableBody td.cell-selected').forEach(td => {
                td.classList.remove('cell-selected', 'cell-selection-anchor');
            });
            
            // Ausgew√§hlte Zellen markieren
            explorerState.selectedCells.forEach(cellKey => {
                const [rowIndex, colIndex] = cellKey.split('-').map(Number);
                const td = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                if (td) {
                    td.classList.add('cell-selected');
                }
            });
            
            // Anker-Zelle hervorheben
            if (explorerState.selectionAnchor) {
                const anchorTd = document.querySelector(
                    `#explorerTableBody td[data-row="${explorerState.selectionAnchor.row}"][data-col="${explorerState.selectionAnchor.col}"]`
                );
                if (anchorTd) {
                    anchorTd.classList.add('cell-selection-anchor');
                }
            }
        }
        
        // Zellen-Auswahl leeren
        function clearCellSelection() {
            explorerState.selectedCells.clear();
            explorerState.selectionAnchor = null;
            explorerState.isSelecting = false;
            updateCellSelectionUI();
        }
        
        // Zelle zur Auswahl hinzuf√ºgen/entfernen
        function toggleCellSelection(rowIndex, colIndex, addToSelection = false) {
            const cellKey = `${rowIndex}-${colIndex}`;
            
            if (!addToSelection) {
                // Ohne Modifier: Alte Auswahl leeren
                explorerState.selectedCells.clear();
            }
            
            if (explorerState.selectedCells.has(cellKey)) {
                explorerState.selectedCells.delete(cellKey);
            } else {
                explorerState.selectedCells.add(cellKey);
            }
            
            explorerState.selectionAnchor = { row: rowIndex, col: colIndex };
            updateCellSelectionUI();
        }
        
        // Bereich von Zellen ausw√§hlen (Shift-Klick)
        function selectCellRange(toRow, toCol) {
            if (!explorerState.selectionAnchor) {
                explorerState.selectionAnchor = { row: toRow, col: toCol };
            }
            
            const fromRow = explorerState.selectionAnchor.row;
            const fromCol = explorerState.selectionAnchor.col;
            
            const minRow = Math.min(fromRow, toRow);
            const maxRow = Math.max(fromRow, toRow);
            const minCol = Math.min(fromCol, toCol);
            const maxCol = Math.max(fromCol, toCol);
            
            // Alte Auswahl leeren und neuen Bereich ausw√§hlen
            explorerState.selectedCells.clear();
            
            // Nur sichtbare Spalten ber√ºcksichtigen
            const displayColumns = explorerState.columnOrder.length > 0 
                ? explorerState.columnOrder.filter(col => explorerState.visibleColumns.includes(col))
                : explorerState.visibleColumns;
            
            // Alle Zeilen im Bereich finden
            for (let r = minRow; r <= maxRow; r++) {
                for (let c = minCol; c <= maxCol; c++) {
                    // Nur ausw√§hlen wenn die Spalte sichtbar ist
                    if (displayColumns.includes(c)) {
                        explorerState.selectedCells.add(`${r}-${c}`);
                    }
                }
            }
            
            updateCellSelectionUI();
        }
        
        // Kontextmen√º f√ºr Zellen-Auswahl
        function showCellContextMenu(e, rowIndex, colIndex) {
            e.preventDefault();
            e.stopPropagation();
            
            // Altes Men√º entfernen (nur cell-context-menu, nicht das column-context-menu)
            const oldMenu = document.querySelector('.cell-context-menu');
            if (oldMenu) oldMenu.remove();
            
            const cellKey = `${rowIndex}-${colIndex}`;
            
            // Wenn die angeklickte Zelle nicht in der Auswahl ist, diese zur Auswahl machen
            if (!explorerState.selectedCells.has(cellKey)) {
                explorerState.selectedCells.clear();
                explorerState.selectedCells.add(cellKey);
                explorerState.selectionAnchor = { row: rowIndex, col: colIndex };
                updateCellSelectionUI();
            }
            
            const selectedCount = explorerState.selectedCells.size;
            const cellLabel = selectedCount === 1 ? 'Zelle' : `${selectedCount} Zellen`;
            
            let menuHtml = '<div class="context-menu cell-context-menu">';
            menuHtml += `<div class="context-menu-item" style="font-weight: 600; color: var(--text-muted); cursor: default;">üìã ${cellLabel} ausgew√§hlt</div>`;
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="copy-content">üìã Kopieren</div>`;
            menuHtml += `<div class="context-menu-item" data-action="copy-with-format">üé® Kopieren mit Formatierung</div>`;
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="paste-content">üì• Einf√ºgen</div>`;
            const hasFormatClipboard = copiedCellsWithFormat !== null;
            menuHtml += `<div class="context-menu-item${hasFormatClipboard ? '' : ' disabled'}" data-action="paste-with-format" style="${hasFormatClipboard ? '' : 'opacity: 0.5; cursor: not-allowed;'}">üé® Einf√ºgen mit Formatierung${hasFormatClipboard ? '' : ' (leer)'}</div>`;
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="delete-content">üóëÔ∏è Inhalt l√∂schen</div>`;
            menuHtml += '<div class="context-menu-divider"></div>';
            menuHtml += `<div class="context-menu-item" data-action="clear-selection">‚ùå Auswahl aufheben</div>`;
            menuHtml += '</div>';
            
            const menu = document.createElement('div');
            menu.innerHTML = menuHtml;
            document.body.appendChild(menu.firstElementChild);
            
            const menuEl = document.querySelector('.cell-context-menu');
            
            // Positionierung
            let x = e.clientX;
            let y = e.clientY;
            
            // Sicherstellen, dass das Men√º im Viewport bleibt
            const menuRect = menuEl.getBoundingClientRect();
            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 5;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 5;
            }
            
            menuEl.style.left = x + 'px';
            menuEl.style.top = y + 'px';
            
            // Event-Handler: Inhalt l√∂schen
            menuEl.querySelector('[data-action="delete-content"]').addEventListener('click', () => {
                deleteSelectedCellsContent();
                menuEl.remove();
            });
            
            // Event-Handler: Kopieren
            menuEl.querySelector('[data-action="copy-content"]').addEventListener('click', () => {
                copySelectedCellsContent();
                menuEl.remove();
            });
            
            // Event-Handler: Kopieren mit Formatierung
            menuEl.querySelector('[data-action="copy-with-format"]').addEventListener('click', () => {
                copySelectedCellsWithFormat();
                menuEl.remove();
            });
            
            // Event-Handler: Einf√ºgen
            menuEl.querySelector('[data-action="paste-content"]').addEventListener('click', async () => {
                await pasteToSelectedCells();
                menuEl.remove();
            });
            
            // Event-Handler: Einf√ºgen mit Formatierung
            const pasteFormatItem = menuEl.querySelector('[data-action="paste-with-format"]');
            if (pasteFormatItem && copiedCellsWithFormat !== null) {
                pasteFormatItem.addEventListener('click', () => {
                    pasteSelectedCellsWithFormat();
                    menuEl.remove();
                });
            }
            
            // Event-Handler: Auswahl aufheben
            menuEl.querySelector('[data-action="clear-selection"]').addEventListener('click', () => {
                clearCellSelection();
                menuEl.remove();
            });
            
            // Men√º bei Klick au√üerhalb schlie√üen
            const closeHandler = (event) => {
                if (!menuEl.contains(event.target)) {
                    menuEl.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            setTimeout(() => document.addEventListener('click', closeHandler), 10);
        }
        
        // Ausgew√§hlte Zelleninhalte l√∂schen
        function deleteSelectedCellsContent() {
            if (explorerState.selectedCells.size === 0) return;
            
            const undoActions = [];
            
            explorerState.selectedCells.forEach(cellKey => {
                const [rowIndex, colIndex] = cellKey.split('-').map(Number);
                const td = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                
                if (td) {
                    const oldValue = explorerState.data[rowIndex][colIndex];
                    const originalValue = td.dataset.original;
                    
                    // Undo-Aktion speichern
                    undoActions.push({
                        rowIndex,
                        colIndex,
                        oldValue: String(oldValue ?? ''),
                        newValue: '',
                        originalValue
                    });
                    
                    // Daten aktualisieren
                    explorerState.data[rowIndex][colIndex] = '';
                    explorerState.editedCells.set(cellKey, '');
                    
                    // UI aktualisieren
                    td.textContent = '';
                    td.dataset.lastValue = '';
                    td.classList.add('edited');
                }
            });
            
            // Alle √Ñnderungen als eine Undo-Aktion speichern
            if (undoActions.length > 0) {
                pushExplorerUndo({
                    type: 'multi',
                    actions: undoActions
                });
            }
            
            // Status aktualisieren
            updateExplorerEditStatus();
            
            // Auswahl leeren
            clearCellSelection();
            
            // Info anzeigen
            showFloatingStatus(`${undoActions.length} Zelle(n) gel√∂scht`);
        }
        
        // Ausgew√§hlte Zelleninhalte kopieren
        function copySelectedCellsContent() {
            if (explorerState.selectedCells.size === 0) return;
            
            // Zellen nach Position sortieren
            const cells = Array.from(explorerState.selectedCells).map(key => {
                const [row, col] = key.split('-').map(Number);
                return { row, col, value: explorerState.data[row][col] ?? '' };
            }).sort((a, b) => a.row - b.row || a.col - b.col);
            
            // Nach Zeilen gruppieren
            const rows = new Map();
            cells.forEach(cell => {
                if (!rows.has(cell.row)) {
                    rows.set(cell.row, []);
                }
                rows.get(cell.row).push(String(cell.value));
            });
            
            // Als Tab-getrennten Text formatieren
            const text = Array.from(rows.values())
                .map(rowCells => rowCells.join('\t'))
                .join('\n');
            
            navigator.clipboard.writeText(text).then(() => {
                showFloatingStatus(`${explorerState.selectedCells.size} Zelle(n) kopiert`);
            }).catch(err => {
                console.error('Kopieren fehlgeschlagen:', err);
                showFloatingStatus('Kopieren fehlgeschlagen', true);
            });
        }
        
        // Ausgew√§hlte Zelleninhalte MIT Formatierung kopieren
        function copySelectedCellsWithFormat() {
            if (explorerState.selectedCells.size === 0) return;
            
            // Zellen nach Position sortieren und mit Formatierung erfassen
            const cells = Array.from(explorerState.selectedCells).map(key => {
                const [row, col] = key.split('-').map(Number);
                // WICHTIG: cellStyles, cellFormulas etc. verwenden "originalIndex+1"-Format (1-basiert wegen Header)
                const styleKey = `${row + 1}-${col}`;
                return {
                    row,
                    col,
                    value: explorerState.data[row][col] ?? '',
                    style: explorerState.cellStyles[styleKey] || null,
                    formula: explorerState.cellFormulas[styleKey] || null,
                    hyperlink: explorerState.cellHyperlinks[styleKey] || null,
                    richText: explorerState.richTextCells[styleKey] || null
                };
            }).sort((a, b) => a.row - b.row || a.col - b.col);
            
            // Debug: Ausgabe was kopiert wurde
            const stylesFound = cells.filter(c => c.style !== null).length;
            console.log(`Kopiert: ${cells.length} Zellen, davon ${stylesFound} mit Style`);
            if (stylesFound > 0) {
                console.log('Gefundene Styles:', cells.filter(c => c.style).map(c => ({ key: `${c.row+1}-${c.col}`, style: c.style })));
            }
            
            // Minimale Position ermitteln (f√ºr relatives Einf√ºgen)
            const minRow = Math.min(...cells.map(c => c.row));
            const minCol = Math.min(...cells.map(c => c.col));
            
            // Relative Positionen berechnen
            copiedCellsWithFormat = {
                cells: cells.map(c => ({
                    ...c,
                    relRow: c.row - minRow,
                    relCol: c.col - minCol
                })),
                minRow,
                minCol,
                sourceSheet: explorerState.selectedSheet
            };
            
            // Auch als Text in Zwischenablage kopieren
            const rows = new Map();
            cells.forEach(cell => {
                if (!rows.has(cell.row)) {
                    rows.set(cell.row, []);
                }
                rows.get(cell.row).push(String(cell.value));
            });
            
            const text = Array.from(rows.values())
                .map(rowCells => rowCells.join('\t'))
                .join('\n');
            
            navigator.clipboard.writeText(text).then(() => {
                showFloatingStatus(`${explorerState.selectedCells.size} Zelle(n) mit Formatierung kopiert üé®`);
            }).catch(err => {
                console.error('Kopieren fehlgeschlagen:', err);
                showFloatingStatus('Kopieren fehlgeschlagen', true);
            });
        }
        
        // Zellen MIT Formatierung einf√ºgen
        function pasteSelectedCellsWithFormat() {
            if (!copiedCellsWithFormat || copiedCellsWithFormat.cells.length === 0) {
                showFloatingStatus('Keine formatierten Zellen zum Einf√ºgen', true);
                return;
            }
            
            // Zielposition ermitteln (erste ausgew√§hlte Zelle oder Anker)
            let targetRow, targetCol;
            if (explorerState.selectedCells.size > 0) {
                const firstCell = explorerState.selectedCells.values().next().value;
                [targetRow, targetCol] = firstCell.split('-').map(Number);
            } else if (explorerState.selectionAnchor) {
                targetRow = explorerState.selectionAnchor.row;
                targetCol = explorerState.selectionAnchor.col;
            } else {
                showFloatingStatus('Keine Zielzelle ausgew√§hlt', true);
                return;
            }
            
            const undoActions = [];
            let pastedCount = 0;
            
            copiedCellsWithFormat.cells.forEach(cell => {
                const newRow = targetRow + cell.relRow;
                const newCol = targetCol + cell.relCol;
                const cellKey = `${newRow}-${newCol}`;  // F√ºr editedCells (0-basiert)
                const styleKey = `${newRow + 1}-${newCol}`;  // F√ºr Styles (1-basiert wegen Header)
                
                // Pr√ºfen ob Zielzelle existiert
                if (newRow >= 0 && newRow < explorerState.data.length && 
                    newCol >= 0 && newCol < explorerState.headers.length) {
                    
                    const oldValue = explorerState.data[newRow][newCol];
                    const oldStyle = explorerState.cellStyles[styleKey];
                    const oldFormula = explorerState.cellFormulas[styleKey];
                    const oldHyperlink = explorerState.cellHyperlinks[styleKey];
                    const oldRichText = explorerState.richTextCells[styleKey];
                    
                    // Undo-Aktion speichern
                    undoActions.push({
                        rowIndex: newRow,
                        colIndex: newCol,
                        oldValue: oldValue ?? '',
                        newValue: cell.value,
                        oldStyle: oldStyle ? { ...oldStyle } : null,
                        newStyle: cell.style ? { ...cell.style } : null,
                        oldFormula,
                        newFormula: cell.formula,
                        oldHyperlink,
                        newHyperlink: cell.hyperlink,
                        oldRichText: oldRichText ? [...oldRichText] : null,
                        newRichText: cell.richText ? [...cell.richText] : null
                    });
                    
                    // Wert setzen
                    explorerState.data[newRow][newCol] = cell.value;
                    explorerState.editedCells.set(cellKey, cell.value);
                    
                    // Style kopieren (mit styleKey = 1-basiert)
                    if (cell.style) {
                        explorerState.cellStyles[styleKey] = { ...cell.style };
                    } else {
                        delete explorerState.cellStyles[styleKey];
                    }
                    
                    // Formel kopieren
                    if (cell.formula) {
                        explorerState.cellFormulas[styleKey] = cell.formula;
                    } else {
                        delete explorerState.cellFormulas[styleKey];
                    }
                    
                    // Hyperlink kopieren
                    if (cell.hyperlink) {
                        explorerState.cellHyperlinks[styleKey] = cell.hyperlink;
                    } else {
                        delete explorerState.cellHyperlinks[styleKey];
                    }
                    
                    // Rich Text kopieren
                    if (cell.richText) {
                        explorerState.richTextCells[styleKey] = [...cell.richText];
                    } else {
                        delete explorerState.richTextCells[styleKey];
                    }
                    
                    pastedCount++;
                }
            });
            
            // Debug
            console.log(`Eingef√ºgt: ${pastedCount} Zellen mit Formatierung`);
            
            // Undo speichern
            if (undoActions.length > 0) {
                pushExplorerUndo({
                    type: 'multi-format',
                    actions: undoActions
                });
            }
            
            // Tabelle neu rendern um Formatierung anzuzeigen
            renderExplorerTable();
            updateExplorerEditStatus();
            
            showFloatingStatus(`${pastedCount} Zelle(n) mit Formatierung eingef√ºgt üé®`);
        }
        
        // Aus Zwischenablage in ausgew√§hlte Zelle(n) einf√ºgen
        async function pasteToSelectedCells() {
            try {
                const text = await navigator.clipboard.readText();
                if (!text) {
                    showFloatingStatus('Zwischenablage ist leer', true);
                    return;
                }
                
                // Wenn nur eine Zelle ausgew√§hlt ist, dort einf√ºgen
                if (explorerState.selectedCells.size === 1) {
                    const cellKey = explorerState.selectedCells.values().next().value;
                    const [rowIndex, colIndex] = cellKey.split('-').map(Number);
                    const td = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                    
                    if (td) {
                        const original = td.dataset.original;
                        const oldValue = explorerState.data[rowIndex][colIndex];
                        
                        // Wert setzen
                        explorerState.data[rowIndex][colIndex] = text;
                        explorerState.editedCells.set(cellKey, text);
                        
                        // UI aktualisieren
                        const contentSpan = td.querySelector('.cell-content');
                        if (contentSpan) {
                            contentSpan.textContent = text;
                        } else {
                            td.textContent = text;
                        }
                        
                        if (text !== original) {
                            td.classList.add('edited');
                        } else {
                            td.classList.remove('edited');
                        }
                        
                        // Undo speichern
                        pushExplorerUndo({
                            rowIndex,
                            colIndex,
                            oldValue: oldValue,
                            newValue: text,
                            originalValue: original
                        });
                        
                        updateExplorerEditStatus();
                        showFloatingStatus('Eingef√ºgt');
                    }
                } else if (explorerState.selectedCells.size > 1) {
                    // Bei mehreren Zellen: gleichen Wert in alle einf√ºgen
                    let count = 0;
                    explorerState.selectedCells.forEach(cellKey => {
                        const [rowIndex, colIndex] = cellKey.split('-').map(Number);
                        const td = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
                        
                        if (td) {
                            const original = td.dataset.original;
                            explorerState.data[rowIndex][colIndex] = text;
                            explorerState.editedCells.set(cellKey, text);
                            
                            const contentSpan = td.querySelector('.cell-content');
                            if (contentSpan) {
                                contentSpan.textContent = text;
                            } else {
                                td.textContent = text;
                            }
                            
                            if (text !== original) {
                                td.classList.add('edited');
                            }
                            count++;
                        }
                    });
                    
                    updateExplorerEditStatus();
                    showFloatingStatus(`In ${count} Zelle(n) eingef√ºgt`);
                } else {
                    showFloatingStatus('Keine Zelle ausgew√§hlt', true);
                }
            } catch (err) {
                console.error('Einf√ºgen fehlgeschlagen:', err);
                showFloatingStatus('Einf√ºgen fehlgeschlagen', true);
            }
        }
        
        // ============ SUCHEN & ERSETZEN (Find & Replace) ============
        
        // Find & Replace State
        const findReplaceState = {
            matches: [],
            currentMatchIndex: -1,
            lastSearchTerm: '',
            isOpen: false
        };
        
        // Toggle Find & Replace Panel
        function toggleFindReplacePanel() {
            const panel = document.getElementById('findReplacePanel');
            findReplaceState.isOpen = !findReplaceState.isOpen;
            panel.style.display = findReplaceState.isOpen ? 'flex' : 'none';
            
            if (findReplaceState.isOpen) {
                document.getElementById('findText').focus();
            } else {
                clearFindHighlights();
            }
        }
        
        // Find-Highlights entfernen
        function clearFindHighlights() {
            document.querySelectorAll('#explorerTableBody td.find-match').forEach(td => {
                td.classList.remove('find-match', 'find-current');
            });
            findReplaceState.matches = [];
            findReplaceState.currentMatchIndex = -1;
            updateFindMatchCounter();
        }
        
        // Match-Counter aktualisieren
        function updateFindMatchCounter() {
            const counter = document.getElementById('findMatchCounter');
            if (!counter) return;
            if (findReplaceState.matches.length === 0) {
                counter.textContent = '';
            } else {
                counter.textContent = `${findReplaceState.currentMatchIndex + 1}/${findReplaceState.matches.length}`;
            }
        }
        
        // Suche durchf√ºhren
        function performFind() {
            const searchTerm = document.getElementById('findText').value;
            if (!searchTerm) {
                clearFindHighlights();
                return;
            }
            
            const caseSensitive = document.getElementById('findCaseSensitive').checked;
            const wholeWord = document.getElementById('findWholeWord').checked;
            const useRegex = document.getElementById('findRegex').checked;
            
            // Alte Highlights entfernen
            clearFindHighlights();
            
            // Pattern erstellen
            let pattern;
            try {
                if (useRegex) {
                    pattern = new RegExp(searchTerm, caseSensitive ? 'g' : 'gi');
                } else {
                    const escaped = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const term = wholeWord ? `\\b${escaped}\\b` : escaped;
                    pattern = new RegExp(term, caseSensitive ? 'g' : 'gi');
                }
            } catch (e) {
                showFloatingStatus('Ung√ºltiger regul√§rer Ausdruck', true);
                return;
            }
            
            // ALLE Daten durchsuchen (nicht nur sichtbare Zeilen!)
            const matches = [];
            
            // explorerState.data enth√§lt die Rohdaten als 2D-Array
            const dataToSearch = explorerState.data || [];
            
            dataToSearch.forEach((row, rowIndex) => {
                if (!row || !Array.isArray(row)) return;
                row.forEach((cellValue, colIndex) => {
                    const cellText = String(cellValue ?? '');
                    if (pattern.test(cellText)) {
                        matches.push({ rowIndex, colIndex, td: null }); // td wird sp√§ter gesetzt
                    }
                    // Reset pattern lastIndex f√ºr globales Matching
                    pattern.lastIndex = 0;
                });
            });
            
            findReplaceState.matches = matches;
            findReplaceState.lastSearchTerm = searchTerm;
            
            if (matches.length > 0) {
                findReplaceState.currentMatchIndex = 0;
                highlightCurrentMatch();
                showFloatingStatus(`${matches.length} Treffer gefunden`);
            } else {
                showFloatingStatus('Keine Treffer gefunden', true);
            }
            
            updateFindMatchCounter();
        }
        
        // Aktuellen Treffer hervorheben und scrollen
        function highlightCurrentMatch() {
            // Vorherigen aktuellen Treffer zur√ºcksetzen
            document.querySelectorAll('#explorerTableBody td.find-current, #explorerTableBody td.find-match').forEach(td => {
                td.classList.remove('find-current', 'find-match');
            });
            
            if (findReplaceState.matches.length === 0 || findReplaceState.currentMatchIndex < 0) return;
            
            const match = findReplaceState.matches[findReplaceState.currentMatchIndex];
            
            // Berechne auf welcher Seite diese Zeile ist und navigiere dorthin
            const pageForRow = Math.floor(match.rowIndex / explorerState.pageSize) + 1;
            if (explorerState.currentPage !== pageForRow) {
                explorerState.currentPage = pageForRow;
                renderExplorerTable();
            }
            
            // Jetzt nach dem Rendern die TD-Zelle finden und markieren
            setTimeout(() => {
                const td = document.querySelector(`#explorerTableBody td[data-row="${match.rowIndex}"][data-col="${match.colIndex}"]`);
                if (td) {
                    // Alle Treffer auf der aktuellen Seite markieren
                    const pageStart = (explorerState.currentPage - 1) * explorerState.pageSize;
                    const pageEnd = pageStart + explorerState.pageSize;
                    findReplaceState.matches.forEach(m => {
                        if (m.rowIndex >= pageStart && m.rowIndex < pageEnd) {
                            const mtd = document.querySelector(`#explorerTableBody td[data-row="${m.rowIndex}"][data-col="${m.colIndex}"]`);
                            if (mtd) mtd.classList.add('find-match');
                        }
                    });
                    
                    td.classList.add('find-current');
                    td.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                }
                updateFindMatchCounter();
            }, 50);
        }
        
        // N√§chsten Treffer finden
        function findNext() {
            const searchTerm = document.getElementById('findText').value;
            
            // Wenn Suchbegriff ge√§ndert wurde, neu suchen
            if (searchTerm !== findReplaceState.lastSearchTerm) {
                performFind();
                return;
            }
            
            if (findReplaceState.matches.length === 0) {
                performFind();
                return;
            }
            
            // Zum n√§chsten Treffer
            findReplaceState.currentMatchIndex = 
                (findReplaceState.currentMatchIndex + 1) % findReplaceState.matches.length;
            highlightCurrentMatch();
        }
        
        // Vorherigen Treffer finden
        function findPrevious() {
            if (findReplaceState.matches.length === 0) return;
            
            findReplaceState.currentMatchIndex = 
                (findReplaceState.currentMatchIndex - 1 + findReplaceState.matches.length) % findReplaceState.matches.length;
            highlightCurrentMatch();
        }
        
        // Einzelne Ersetzung
        function replaceOne() {
            if (findReplaceState.matches.length === 0 || findReplaceState.currentMatchIndex < 0) {
                findNext();
                return;
            }
            
            const replaceText = document.getElementById('replaceText').value;
            const match = findReplaceState.matches[findReplaceState.currentMatchIndex];
            
            // Zelle ersetzen
            replaceCellContent(match.rowIndex, match.colIndex, replaceText);
            
            // Treffer aus Liste entfernen
            findReplaceState.matches.splice(findReplaceState.currentMatchIndex, 1);
            
            // Index anpassen
            if (findReplaceState.matches.length === 0) {
                findReplaceState.currentMatchIndex = -1;
                updateFindMatchCounter();
                showFloatingStatus('Alle Treffer ersetzt');
            } else {
                if (findReplaceState.currentMatchIndex >= findReplaceState.matches.length) {
                    findReplaceState.currentMatchIndex = 0;
                }
                highlightCurrentMatch();
            }
        }
        
        // Alle ersetzen
        function replaceAll() {
            const searchTerm = document.getElementById('findText').value;
            if (!searchTerm) return;
            
            // Erst suchen falls n√∂tig
            if (findReplaceState.matches.length === 0 || searchTerm !== findReplaceState.lastSearchTerm) {
                performFind();
            }
            
            if (findReplaceState.matches.length === 0) return;
            
            const replaceText = document.getElementById('replaceText').value;
            const caseSensitive = document.getElementById('findCaseSensitive').checked;
            const wholeWord = document.getElementById('findWholeWord').checked;
            const useRegex = document.getElementById('findRegex').checked;
            
            // Pattern erstellen
            let pattern;
            try {
                if (useRegex) {
                    pattern = new RegExp(searchTerm, caseSensitive ? 'g' : 'gi');
                } else {
                    const escaped = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const term = wholeWord ? `\\b${escaped}\\b` : escaped;
                    pattern = new RegExp(term, caseSensitive ? 'g' : 'gi');
                }
            } catch (e) {
                showFloatingStatus('Ung√ºltiger regul√§rer Ausdruck', true);
                return;
            }
            
            const undoActions = [];
            let replacedCount = 0;
            
            // Alle Treffer ersetzen (arbeitet √ºber Daten, nicht DOM)
            findReplaceState.matches.forEach(match => {
                const oldValue = String(explorerState.data[match.rowIndex]?.[match.colIndex] ?? '');
                const newValue = oldValue.replace(pattern, replaceText);
                
                if (oldValue !== newValue) {
                    // Original-Wert merken (f√ºr Undo)
                    const originalValue = explorerState.data[match.rowIndex]?.[match.colIndex];
                    
                    undoActions.push({
                        rowIndex: match.rowIndex,
                        colIndex: match.colIndex,
                        oldValue,
                        newValue,
                        originalValue: originalValue
                    });
                    
                    // Daten aktualisieren
                    if (explorerState.data[match.rowIndex]) {
                        explorerState.data[match.rowIndex][match.colIndex] = newValue;
                    }
                    explorerState.editedCells.set(`${match.rowIndex}-${match.colIndex}`, newValue);
                    
                    replacedCount++;
                }
            });
            
            // Undo-Aktion speichern
            if (undoActions.length > 0) {
                pushExplorerUndo({
                    type: 'multi',
                    actions: undoActions
                });
            }
            
            // Tabelle neu rendern und Status aktualisieren
            clearFindHighlights();
            renderExplorerTable();
            updateExplorerEditStatus();
            
            showFloatingStatus(`${replacedCount} Ersetzung(en) durchgef√ºhrt`);
        }
        
        // Zelleninhalt mit Regex ersetzen
        function replaceCellContent(rowIndex, colIndex, replaceText) {
            const searchTerm = document.getElementById('findText').value;
            const caseSensitive = document.getElementById('findCaseSensitive').checked;
            const wholeWord = document.getElementById('findWholeWord').checked;
            const useRegex = document.getElementById('findRegex').checked;
            
            let pattern;
            if (useRegex) {
                pattern = new RegExp(searchTerm, caseSensitive ? '' : 'i');
            } else {
                const escaped = searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const term = wholeWord ? `\\b${escaped}\\b` : escaped;
                pattern = new RegExp(term, caseSensitive ? '' : 'i');
            }
            
            const cellKey = `${rowIndex}-${colIndex}`;
            
            // Immer explorerState.data verwenden (enth√§lt die rohen Daten-Arrays)
            if (!explorerState.data[rowIndex]) return;
            
            const oldValue = String(explorerState.data[rowIndex][colIndex] ?? '');
            const newValue = oldValue.replace(pattern, replaceText);
            
            // Undo-Aktion speichern
            pushExplorerUndo({
                type: 'single',
                rowIndex,
                colIndex,
                oldValue,
                newValue,
                originalValue: oldValue
            });
            
            // Daten aktualisieren
            explorerState.data[rowIndex][colIndex] = newValue;
            explorerState.editedCells.set(cellKey, newValue);
            
            // Falls Zelle sichtbar ist, UI aktualisieren
            const td = document.querySelector(`#explorerTableBody td[data-row="${rowIndex}"][data-col="${colIndex}"]`);
            if (td) {
                td.textContent = newValue;
                td.dataset.lastValue = newValue;
                td.classList.add('edited');
                td.classList.remove('find-match', 'find-current');
            }
            
            updateExplorerEditStatus();
        }
        
        // Event Listeners f√ºr Find & Replace
        document.addEventListener('DOMContentLoaded', () => {
            // Toggle Button
            document.getElementById('btnToggleFindReplace')?.addEventListener('click', toggleFindReplacePanel);
            
            // Close Button
            document.getElementById('btnCloseFindReplace')?.addEventListener('click', toggleFindReplacePanel);
            
            // Find Next Button
            document.getElementById('btnFindNext')?.addEventListener('click', findNext);
            
            // Replace One Button
            document.getElementById('btnReplaceOne')?.addEventListener('click', replaceOne);
            
            // Replace All Button
            document.getElementById('btnReplaceAll')?.addEventListener('click', replaceAll);
            
            // Undo Button
            document.getElementById('btnFindReplaceUndo')?.addEventListener('click', () => {
                if (undoExplorer()) {
                    showFloatingStatus('R√ºckg√§ngig gemacht');
                } else {
                    showFloatingStatus('Nichts zum R√ºckg√§ngigmachen', true);
                }
            });
            
            // Enter-Taste im Suchfeld
            document.getElementById('findText')?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    if (e.shiftKey) {
                        findPrevious();
                    } else {
                        findNext();
                    }
                }
            });
            
            // Escape zum Schlie√üen
            document.getElementById('findReplacePanel')?.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    toggleFindReplacePanel();
                }
            });
        });
        
        // Keyboard Shortcut: Ctrl+H f√ºr Find & Replace
        document.addEventListener('keydown', (e) => {
            // F11 f√ºr Vollbild im Datenexplorer
            if (e.key === 'F11' && !elements.dataExplorerModal.classList.contains('hidden')) {
                e.preventDefault();
                toggleExplorerFullscreen();
            }
            // Escape beendet Vollbild
            if (e.key === 'Escape' && !elements.dataExplorerModal.classList.contains('hidden')) {
                const modal = document.querySelector('#dataExplorerModal .modal');
                if (modal.classList.contains('modal-fullscreen')) {
                    e.preventDefault();
                    toggleExplorerFullscreen();
                    return;
                }
            }
            if (e.ctrlKey && e.key === 'h' && !elements.dataExplorerModal.classList.contains('hidden')) {
                e.preventDefault();
                if (!findReplaceState.isOpen) {
                    toggleFindReplacePanel();
                }
            }
            // F3 f√ºr n√§chsten Treffer
            if (e.key === 'F3' && findReplaceState.isOpen) {
                e.preventDefault();
                if (e.shiftKey) {
                    findPrevious();
                } else {
                    findNext();
                }
            }
        });
        
        // ============ ENDE SUCHEN & ERSETZEN ============
        
        // Floating Status Nachricht anzeigen
        function showFloatingStatus(message, isError = false) {
            // Alte Nachricht entfernen
            const oldStatus = document.querySelector('.floating-status');
            if (oldStatus) oldStatus.remove();
            
            const status = document.createElement('div');
            status.className = 'floating-status';
            status.style.cssText = `
                position: fixed;
                bottom: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: ${isError ? '#F44336' : 'var(--primary)'};
                color: white;
                padding: 10px 20px;
                border-radius: 6px;
                z-index: 10001;
                font-size: 13px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: fadeInUp 0.3s ease;
            `;
            status.textContent = message;
            document.body.appendChild(status);
            
            setTimeout(() => {
                status.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => status.remove(), 300);
            }, 2000);
        }

        async function openDataExplorer() {
            // State immer zur√ºcksetzen beim √ñffnen (au√üer bei Recovery)
            const recoveryData = loadExplorerRecoveryData();
            if (!recoveryData) {
                resetExplorerState();
            }
            
            elements.dataExplorerModal.classList.remove('hidden');
            document.body.classList.add('modal-open');
            
            // Pr√ºfe auf Recovery-Daten (von vorherigem Crash)
            if (recoveryData && !explorerState.filePath) {
                const totalRecoveryChanges = (recoveryData.editedCells?.length || 0);
                
                // Pr√ºfe ob die Datei noch existiert
                let fileExists = false;
                try {
                    const checkResult = await window.electronAPI.checkFileExists(recoveryData.filePath);
                    fileExists = checkResult.exists;
                } catch (e) {
                    fileExists = false;
                }
                
                if (fileExists && totalRecoveryChanges > 0) {
                    const restore = await showConfirmDialog(
                        currentLanguage === 'en' ? 'Restore Data?' : 'Daten wiederherstellen?',
                        currentLanguage === 'en' 
                            ? `Recovery data found from a previous session:\n\nFile: ${recoveryData.fileName}\nChanges: ${totalRecoveryChanges}\nTime: ${new Date(recoveryData.timestamp).toLocaleString()}\n\nDo you want to restore these changes?`
                            : `Es wurden Wiederherstellungsdaten aus einer vorherigen Sitzung gefunden:\n\nDatei: ${recoveryData.fileName}\n√Ñnderungen: ${totalRecoveryChanges}\nZeitpunkt: ${new Date(recoveryData.timestamp).toLocaleString()}\n\nM√∂chten Sie diese √Ñnderungen wiederherstellen?`,
                        currentLanguage === 'en' ? 'Restore' : 'Wiederherstellen',
                        currentLanguage === 'en' ? 'Discard' : 'Verwerfen'
                    );
                    
                    if (restore) {
                        applyExplorerRecoveryData(recoveryData);
                        showNotification(
                            currentLanguage === 'en' ? 'Data restored successfully' : 'Daten erfolgreich wiederhergestellt', 
                            'success'
                        );
                    } else {
                        clearExplorerRecoveryData();
                    }
                } else {
                    // Datei existiert nicht mehr oder keine √Ñnderungen - Recovery-Daten l√∂schen
                    clearExplorerRecoveryData();
                }
            }
        }
        
        async function closeDataExplorer() {
            // Pr√ºfe auf ungespeicherte √Ñnderungen
            const totalChanges = countAllChanges();
            if (totalChanges > 0) {
                const confirmed = await showConfirmDialog(
                    currentLanguage === 'en' ? 'Unsaved Changes' : 'Ungespeicherte √Ñnderungen',
                    currentLanguage === 'en' 
                        ? `You have ${totalChanges} unsaved change(s).\n\nDo you really want to close the Data Explorer without saving?`
                        : `Sie haben ${totalChanges} ungespeicherte √Ñnderung(en).\n\nM√∂chten Sie den Datenexplorer wirklich ohne Speichern schlie√üen?`,
                    currentLanguage === 'en' ? 'Close without saving' : 'Ohne Speichern schlie√üen',
                    currentLanguage === 'en' ? 'Cancel' : 'Abbrechen'
                );
                
                if (!confirmed) {
                    return; // Abbruch - Datenexplorer bleibt offen
                }
            }
            
            // State komplett zur√ºcksetzen
            resetExplorerState();
            
            // Recovery-Daten l√∂schen (normales Schlie√üen)
            clearExplorerRecoveryData();
            
            elements.dataExplorerModal.classList.add('hidden');
            document.body.classList.remove('modal-open');
        }
        
        // Explorer-Vorschau zeigen (zeigt genau das was exportiert wird)
        function showExplorerPreview() {
            if (!explorerState.filteredData || explorerState.filteredData.length === 0) {
                return;
            }
            
            const modal = document.getElementById('explorerPreviewModal');
            const tableContainer = document.getElementById('previewTableContainer');
            
            // Gleiche Daten wie beim Export verwenden
            const exportData = explorerState.filteredData.map(item => item.row);
            const visibleColumns = explorerState.visibleColumns;
            
            // Info aktualisieren
            document.getElementById('previewFileName').textContent = explorerState.fileName || 'Unbekannt';
            document.getElementById('previewSheetName').textContent = explorerState.selectedSheet || 'Sheet1';
            document.getElementById('previewRowCount').textContent = exportData.length;
            document.getElementById('previewColCount').textContent = visibleColumns.length;
            document.getElementById('previewEditCount').textContent = explorerState.editedCells.size;
            
            // Header erstellen (nur sichtbare Spalten)
            let headerHtml = '<tr><th style="width: 50px; text-align: center; position: sticky; left: 0; background: var(--bg-medium); z-index: 2;">#</th>';
            visibleColumns.forEach(colIdx => {
                const colLetter = String.fromCharCode(65 + colIdx);
                const header = explorerState.headers[colIdx] || '-';
                headerHtml += `<th style="min-width: 120px;"><small style="color: var(--text-muted);">${colLetter}</small><br>${escapeHtml(header)}</th>`;
            });
            headerHtml += '</tr>';
            
            // Zeilen erstellen (mit bearbeiteten Werten - genau wie beim Export)
            let rowsHtml = '';
            explorerState.filteredData.forEach((item, displayIdx) => {
                const originalIndex = item.originalIndex;
                const row = item.row;
                
                // Pr√ºfe ob diese Zeile bearbeitete Zellen hat
                let hasEdits = false;
                for (const colIdx of visibleColumns) {
                    if (explorerState.editedCells.has(`${originalIndex}-${colIdx}`)) {
                        hasEdits = true;
                        break;
                    }
                }
                
                const rowStyle = hasEdits ? 'background: rgba(255, 193, 7, 0.05);' : '';
                rowsHtml += `<tr style="${rowStyle}">`;
                rowsHtml += `<td style="text-align: center; font-weight: bold; color: var(--text-muted); position: sticky; left: 0; background: var(--bg-dark); z-index: 1;">${displayIdx + 1}</td>`;
                
                visibleColumns.forEach(colIdx => {
                    const cellKey = `${originalIndex}-${colIdx}`;
                    const isEdited = explorerState.editedCells.has(cellKey);
                    
                    // Hole den Wert direkt aus der Zeile (enth√§lt bereits Bearbeitungen)
                    const cellValue = row[colIdx] !== undefined ? String(row[colIdx]) : '';
                    
                    const cellStyle = isEdited 
                        ? 'background: rgba(255, 193, 7, 0.3); border: 2px solid #FFC107;' 
                        : '';
                    
                    rowsHtml += `<td style="${cellStyle}">${escapeHtml(cellValue)}</td>`;
                });
                
                rowsHtml += '</tr>';
            });
            
            tableContainer.innerHTML = `
                <table class="results-table" style="width: max-content; min-width: 100%;">
                    <thead style="position: sticky; top: 0; z-index: 3;">${headerHtml}</thead>
                    <tbody>${rowsHtml}</tbody>
                </table>
            `;
            
            // Modal anzeigen
            modal.classList.remove('hidden');
        }
        
        function closeExplorerPreview() {
            document.getElementById('explorerPreviewModal').classList.add('hidden');
        }
        
        // Vollbild-Modus f√ºr Datenexplorer umschalten
        function toggleExplorerFullscreen() {
            const modal = document.querySelector('#dataExplorerModal .modal');
            const btn = document.getElementById('btnExplorerFullscreen');
            
            if (modal.classList.contains('modal-fullscreen')) {
                modal.classList.remove('modal-fullscreen');
                btn.innerHTML = '‚õ∂';
                btn.title = 'Vollbild (F11)';
            } else {
                modal.classList.add('modal-fullscreen');
                btn.innerHTML = '‚õ∂';
                btn.title = 'Vollbild beenden (F11 oder Esc)';
            }
        }
        
        // Drop-Zone anzeigen/verstecken
        function showExplorerDropZone(show) {
            const dropZone = elements.explorerDropZone;
            if (dropZone) {
                dropZone.style.display = show ? 'flex' : 'none';
            }
        }
        
        // Setup Drag & Drop Zone for Explorer
        function setupExplorerDropZone() {
            const dropZone = elements.explorerDropZone;
            if (!dropZone) return;
            
            // Klick √∂ffnet Datei-Dialog
            dropZone.onclick = loadExplorerFile;
            
            // Drag-Events f√ºr die Drop-Zone
            dropZone.ondragover = (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.style.background = 'rgba(0, 122, 204, 0.15)';
                dropZone.style.borderColor = 'var(--primary)';
            };
            
            dropZone.ondragleave = (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.style.background = 'transparent';
                dropZone.style.borderColor = 'transparent';
            };
            
            dropZone.ondrop = async (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Styling zur√ºcksetzen
                dropZone.style.background = 'transparent';
                dropZone.style.borderColor = 'transparent';
                
                const files = e.dataTransfer.files;
                if (files.length === 0) return;
                
                const file = files[0];
                const fileName = file.name.toLowerCase();
                
                // Nur Excel-Dateien erlauben
                if (!fileName.endsWith('.xlsx') && !fileName.endsWith('.xls')) {
                    showFloatingStatus('‚ùå Nur Excel-Dateien (.xlsx, .xls) werden unterst√ºtzt', 'error');
                    return;
                }
                
                // Dateipfad √ºber Electron API abrufen (contextIsolation-sicher)
                const filePath = window.electronAPI.getPathForFile(file);
                if (!filePath) {
                    showFloatingStatus('‚ùå Dateipfad konnte nicht ermittelt werden', 'error');
                    return;
                }
                
                // Datei laden
                await loadExplorerFileByPath(filePath);
            };
        }
        
        // Datei √ºber Pfad laden (f√ºr Drag & Drop)
        async function loadExplorerFileByPath(filePath) {
            if (!filePath) return;
            
            // Pr√ºfe auf ungespeicherte √Ñnderungen
            if (hasUnsavedChanges()) {
                const totalChanges = countAllChanges();
                const confirmed = await showConfirmDialog(
                    'Ungespeicherte √Ñnderungen',
                    `Sie haben ${totalChanges} ungespeicherte √Ñnderung(en).\n\n` +
                    `M√∂chten Sie trotzdem eine neue Datei √∂ffnen?\n\n` +
                    `‚ö†Ô∏è Alle √Ñnderungen gehen verloren!`,
                    'Neue Datei √∂ffnen',
                    'Abbrechen'
                );
                if (!confirmed) return;
            }
            
            // State komplett zur√ºcksetzen bevor neue Datei geladen wird
            resetExplorerState();
            
            elements.explorerStatus.textContent = 'Lade Datei...';
            
            // Versuche Datei zu √∂ffnen
            let result = await window.electronAPI.readExcelFile(filePath);
            
            // Passwortgesch√ºtzte Datei?
            if (!result.success && result.needsPassword) {
                const password = await showPromptDialog(
                    'üîê Passwort erforderlich',
                    'Diese Excel-Datei ist passwortgesch√ºtzt.\nBitte geben Sie das Passwort ein:',
                    '',
                    'password'
                );
                
                if (password === null) return;
                
                result = await window.electronAPI.readExcelFile(filePath, password);
                
                if (!result.success) {
                    if (result.needsPassword) {
                        showFloatingStatus('‚ùå Falsches Passwort', 'error');
                    } else {
                        elements.explorerStatus.textContent = `Fehler: ${result.error}`;
                    }
                    return;
                }
                
                explorerState.filePassword = password;
                showFloatingStatus('üîì Datei entsperrt');
            } else if (!result.success) {
                elements.explorerStatus.textContent = `Fehler: ${result.error}`;
                return;
            } else {
                explorerState.filePassword = null;
            }
            
            // Cache leeren bei neuer Datei
            explorerState.sheetDataCache.clear();
            explorerState.editedCells.clear();
            explorerState.rowHighlights.clear();
            
            explorerState.filePath = filePath;
            explorerState.fileName = result.fileName;
            explorerState.sheets = result.sheets;
            explorerState.hasPivotTables = result.hasPivotTables || false;
            
            // Warnung bei Pivot-Tabellen
            if (result.hasPivotTables) {
                await showConfirmDialog(
                    '‚ö†Ô∏è Pivot-Tabellen erkannt',
                    'Diese Datei enth√§lt Pivot-Tabellen!\n\n' +
                    'Pivot-Tabellen k√∂nnen beim Speichern verloren gehen oder besch√§digt werden.\n\n' +
                    'Empfehlung: Erstellen Sie eine Sicherheitskopie der Datei.',
                    'Verstanden',
                    null
                );
            }
            
            // UI aktualisieren
            document.getElementById('explorerFileName').textContent = explorerState.fileName;
            
            // Sheet-Dropdown f√ºllen
            elements.explorerSheetSelect.innerHTML = explorerState.sheets
                .map(s => `<option value="${s}">${s}</option>`)
                .join('');
            
            // Erstes Sheet laden
            if (explorerState.sheets.length > 0) {
                await loadExplorerSheet(explorerState.sheets[0]);
            }
            
            showFloatingStatus(`üìÇ ${result.fileName} geladen`);
        }
        
        async function loadExplorerFile() {
            // Pr√ºfe auf ungespeicherte √Ñnderungen
            if (hasUnsavedChanges()) {
                const totalChanges = countAllChanges();
                const confirmed = await showConfirmDialog(
                    'Ungespeicherte √Ñnderungen',
                    `Sie haben ${totalChanges} ungespeicherte √Ñnderung(en).\n\n` +
                    `M√∂chten Sie trotzdem eine neue Datei √∂ffnen?\n\n` +
                    `‚ö†Ô∏è Alle √Ñnderungen gehen verloren!`,
                    'Neue Datei √∂ffnen',
                    'Abbrechen'
                );
                if (!confirmed) return;
            }
            
            // State komplett zur√ºcksetzen bevor neue Datei geladen wird
            resetExplorerState();
            
            const filePath = await window.electronAPI.openFileDialog({
                title: 'Excel-Datei √∂ffnen',
                filters: [{ name: 'Excel', extensions: ['xlsx', 'xls'] }],
                defaultPath: getWorkingDirectoryPath()
            });
            if (!filePath) return;
            
            // Versuche Datei zu √∂ffnen (mit Passwort-Retry bei gesch√ºtzten Dateien)
            let result = await window.electronAPI.readExcelFile(filePath);
            
            // Passwortgesch√ºtzte Datei?
            if (!result.success && result.needsPassword) {
                const password = await showPromptDialog(
                    'üîê Passwort erforderlich',
                    'Diese Excel-Datei ist passwortgesch√ºtzt.\nBitte geben Sie das Passwort ein:',
                    '',
                    'password'
                );
                
                if (password === null) {
                    // Abgebrochen
                    return;
                }
                
                // Erneut mit Passwort versuchen
                result = await window.electronAPI.readExcelFile(filePath, password);
                
                if (!result.success) {
                    if (result.needsPassword) {
                        showFloatingStatus('‚ùå Falsches Passwort', 'error');
                    } else {
                        elements.explorerStatus.textContent = `Fehler: ${result.error}`;
                    }
                    return;
                }
                
                // Passwort f√ºr sp√§teres Speichern merken
                explorerState.filePassword = password;
                showFloatingStatus('üîì Datei entsperrt');
            } else if (!result.success) {
                elements.explorerStatus.textContent = `Fehler: ${result.error}`;
                return;
            } else {
                // Kein Passwort n√∂tig
                explorerState.filePassword = null;
            }
            
            // Cache leeren bei neuer Datei
            explorerState.sheetDataCache.clear();
            explorerState.editedCells.clear();
            explorerState.rowHighlights.clear();
            
            explorerState.filePath = filePath;
            explorerState.fileName = result.fileName;
            explorerState.sheets = result.sheets;
            explorerState.hasPivotTables = result.hasPivotTables || false;
            
            // Warnung bei Pivot-Tabellen
            if (result.hasPivotTables) {
                await showConfirmDialog(
                    '‚ö†Ô∏è Pivot-Tabellen erkannt',
                    'Diese Datei enth√§lt Pivot-Tabellen!\n\n' +
                    'Pivot-Tabellen k√∂nnen beim Speichern verloren gehen oder besch√§digt werden.\n\n' +
                    'Empfehlung: Erstellen Sie eine Sicherheitskopie der Datei.',
                    'Verstanden',
                    null  // Kein Abbrechen-Button
                );
            }
            
            // Element frisch abfragen (kann durch setLanguage ersetzt worden sein)
            const explorerFileNameEl = document.getElementById('explorerFileName');
            if (explorerFileNameEl) explorerFileNameEl.textContent = result.fileName;
            elements.explorerSheetSelect.innerHTML = result.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
            
            // Passwort-Indikator aktualisieren
            updatePasswordIndicator();
            
            await loadExplorerSheet(result.sheets[0]);
            
            // Auto-Save f√ºr Crash-Recovery starten
            startExplorerAutoSave();
        }
        
        async function loadExplorerSheet(sheetName) {
            if (!explorerState.filePath || !sheetName) return;
            
            // VOR dem Wechsel: Aktuelles Sheet im Cache speichern wenn es √Ñnderungen gibt
            // ABER NICHT wenn editedCells leer ist (z.B. nach Export/Reload)
            if (explorerState.selectedSheet && explorerState.data.length > 0 && explorerState.editedCells.size > 0) {
                saveCurrentSheetToCache();
            }
            
            // Loading-Status anzeigen
            elements.explorerStatus.textContent = 'Lade Daten...';
            
            // Pr√ºfe ob dieses Sheet bereits im Cache ist
            const cachedSheet = explorerState.sheetDataCache.get(sheetName);
            
            if (cachedSheet) {
                // Aus Cache laden
                explorerState.selectedSheet = sheetName;
                explorerState.headers = cachedSheet.headers;
                explorerState.data = cachedSheet.data.map(row => [...row]); // Deep copy
                explorerState.originalData = cachedSheet.originalData.map(row => [...row]);
                explorerState.editedCells = new Map(cachedSheet.editedCells);
                explorerState.rowHighlights = new Map(cachedSheet.rowHighlights);
                explorerState.visibleColumns = [...cachedSheet.visibleColumns];
                explorerState.columnOrder = [...(cachedSheet.columnOrder || [])];
                explorerState.dataValidations = { ...(cachedSheet.dataValidations || {}) };
                explorerState.cellStyles = { ...(cachedSheet.cellStyles || {}) };
                explorerState.cellFormulas = { ...(cachedSheet.cellFormulas || {}) };
                explorerState.cellHyperlinks = { ...(cachedSheet.cellHyperlinks || {}) };
                explorerState.richTextCells = { ...(cachedSheet.richTextCells || {}) };
                explorerState.hiddenRows = new Set(cachedSheet.hiddenRows || []);
                explorerState.autoFilterRange = cachedSheet.autoFilterRange || null;
                explorerState.mergedCells = [...(cachedSheet.mergedCells || [])];
                
                // UI-State zur√ºcksetzen
                explorerState.filteredData = explorerState.data.map((row, index) => ({ originalIndex: index, row: row }));
                explorerState.currentPage = 1;
                explorerState.searchTerm = '';
                explorerState.sortColumn = null;
                explorerState.sortDirection = null;
                elements.explorerSearch.value = '';
                
                const editCount = explorerState.editedCells.size;
                if (editCount > 0) {
                    elements.explorerStatus.textContent = `Aus Cache geladen (${editCount} √Ñnderungen)`;
                } else {
                    elements.explorerStatus.textContent = '';
                }
                
                renderExplorerTable();
                updateColumnToggles();
                updateExplorerEditStatus();
                updateHiddenRowsIndicator();
                updateHiddenColumnsIndicator();
                updateAutoFilterIndicator();
                return;
            }
            
            // ExcelJS zum Lesen (xlwings wird nur zum Schreiben verwendet)
            const result = await window.electronAPI.readExcelSheet(explorerState.filePath, sheetName, explorerState.filePassword);
            
            if (!result.success) {
                elements.explorerStatus.textContent = `Fehler: ${result.error}`;
                return;
            }
            
            explorerState.selectedSheet = sheetName;
            explorerState.headers = result.headers;
            explorerState.data = result.data.slice(1);
            // Kopie der Originaldaten speichern (deep copy)
            explorerState.originalData = explorerState.data.map(row => [...row]);
            // Spalten-Sichtbarkeit: Ber√ºcksichtige hiddenColumns aus Excel
            if (result.hiddenColumns && result.hiddenColumns.length > 0) {
                // Nur Spalten anzeigen, die nicht in hiddenColumns sind
                const hiddenSet = new Set(result.hiddenColumns);
                explorerState.visibleColumns = explorerState.headers
                    .map((_, i) => i)
                    .filter(i => !hiddenSet.has(i));
            } else {
                // Alle Spalten standardm√§√üig sichtbar machen
                explorerState.visibleColumns = explorerState.headers.map((_, i) => i);
            }
            explorerState.columnOrder = []; // Reset column order
            // filteredData mit originalIndex initialisieren
            explorerState.filteredData = explorerState.data.map((row, index) => ({ originalIndex: index, row: row }));
            explorerState.currentPage = 1; // Pagination zur√ºcksetzen
            explorerState.searchTerm = ''; // Suche zur√ºcksetzen
            explorerState.sortColumn = null; // Sortierung zur√ºcksetzen
            explorerState.sortDirection = null;
            explorerState.editedCells.clear(); // Bearbeitungen zur√ºcksetzen
            // Zeilenfarben aus Excel laden (oder leeren wenn keine vorhanden)
            explorerState.rowHighlights.clear();
            explorerState.originalRowHighlights.clear();
            if (result.rowHighlights && result.rowHighlights.length > 0) {
                for (const [rowIdx, colorName] of result.rowHighlights) {
                    explorerState.rowHighlights.set(rowIdx, colorName);
                    explorerState.originalRowHighlights.set(rowIdx, colorName);  // Original-Zustand merken
                }
                console.log(`[Explorer] ${result.rowHighlights.length} Zeilenfarben aus Excel geladen`);
            }
            // Data Validations (Dropdown-Listen) laden
            explorerState.dataValidations = result.dataValidations || {};
            // Cell Styles (Formatierungen) laden
            explorerState.cellStyles = result.cellStyles || {};
            // Cell Formulas (Formeln) laden
            explorerState.cellFormulas = result.cellFormulas || {};
            // Cell Hyperlinks (Links) laden
            explorerState.cellHyperlinks = result.cellHyperlinks || {};
            // Rich Text Cells (formatierter Text) laden
            explorerState.richTextCells = result.richTextCells || {};
            // Hidden Rows (ausgeblendete Zeilen) laden
            explorerState.hiddenRows = new Set(result.hiddenRows || []);
            // AutoFilter Range laden
            explorerState.autoFilterRange = result.autoFilterRange || null;
            // Row Mapping initialisieren: [0, 1, 2, ...] = Identity
            // Bedeutet: Position 0 im Frontend = Excel-Zeile 2 (erste Datenzeile)
            explorerState.rowMapping = explorerState.data.map((_, i) => i);
            // Merged Cells laden
            explorerState.mergedCells = result.mergedCells || [];
            elements.explorerSearch.value = '';
            
            // Pr√ºfe ob es gespeicherte Bearbeitungen gibt (Auto-Save Recovery)
            if (window._pendingExplorerRestore && 
                window._pendingExplorerRestore.filePath === explorerState.filePath &&
                window._pendingExplorerRestore.selectedSheet === sheetName) {
                
                const restore = window._pendingExplorerRestore;
                let restoredCount = 0;
                
                restore.editedCells.forEach(([key, value]) => {
                    const [rowStr, colStr] = key.split('-');
                    const rowIndex = parseInt(rowStr);
                    const colIndex = parseInt(colStr);
                    
                    if (rowIndex < explorerState.data.length && colIndex < explorerState.headers.length) {
                        explorerState.editedCells.set(key, value);
                        explorerState.data[rowIndex][colIndex] = value;
                        restoredCount++;
                    }
                });
                
                if (restoredCount > 0) {
                    showUndoRedoFeedback(`${restoredCount} Bearbeitungen wiederhergestellt`);
                }
                
                delete window._pendingExplorerRestore;
            }
            
            // Status-Meldung f√ºr gro√üe Dateien
            if (explorerState.data.length > 1000) {
                elements.explorerStatus.textContent = `${explorerState.data.length} Zeilen geladen (Pagination aktiv)`;
            } else {
                elements.explorerStatus.textContent = '';
            }
            
            // WICHTIG: filterExplorerData() statt renderExplorerTable() verwenden,
            // damit versteckte Zeilen (hiddenRows) korrekt ausgefiltert werden!
            filterExplorerData();
            updateColumnToggles();
            updateHiddenRowsIndicator();
            updateHiddenColumnsIndicator();
            updateAutoFilterIndicator();
        }
        
        // Speichert das aktuelle Sheet im Cache
        function saveCurrentSheetToCache() {
            if (!explorerState.selectedSheet) return;
            
            explorerState.sheetDataCache.set(explorerState.selectedSheet, {
                headers: [...explorerState.headers],
                data: explorerState.data.map(row => [...row]),
                originalData: explorerState.originalData.map(row => [...row]),
                editedCells: new Map(explorerState.editedCells),
                rowHighlights: new Map(explorerState.rowHighlights),
                visibleColumns: [...explorerState.visibleColumns],
                columnOrder: [...explorerState.columnOrder],
                dataValidations: { ...explorerState.dataValidations },
                cellStyles: { ...explorerState.cellStyles },
                cellFormulas: { ...explorerState.cellFormulas },
                cellHyperlinks: { ...explorerState.cellHyperlinks },
                richTextCells: { ...explorerState.richTextCells },
                hiddenRows: new Set(explorerState.hiddenRows),
                autoFilterRange: explorerState.autoFilterRange,
                mergedCells: [...explorerState.mergedCells]
            });
        }
        
        // Pr√ºft ob es ungespeicherte √Ñnderungen in irgendeinem Sheet gibt
        function hasUnsavedChanges() {
            // Aktuelles Sheet pr√ºfen
            if (explorerState.editedCells.size > 0) return true;
            
            // Cache pr√ºfen
            for (const [sheetName, cached] of explorerState.sheetDataCache) {
                if (cached.editedCells.size > 0) return true;
            }
            
            return false;
        }
        
        // Z√§hlt alle √Ñnderungen √ºber alle Sheets
        function countAllChanges() {
            let total = explorerState.editedCells.size;
            
            for (const [sheetName, cached] of explorerState.sheetDataCache) {
                if (sheetName !== explorerState.selectedSheet) {
                    total += cached.editedCells.size;
                }
            }
            
            return total;
        }
        
        /**
         * Parst einen Datumswert aus verschiedenen Formaten
         * Unterst√ºtzt: Excel-Seriennummern, ISO-Daten, deutsche Datumsformate
         */
        function parseDateValue(value) {
            if (!value) return null;
            
            // Bereits ein Date-Objekt
            if (value instanceof Date && !isNaN(value)) return value;
            
            // Excel-Seriennummer (Zahl zwischen 1 und 100000)
            if (typeof value === 'number' && value > 0 && value < 100000) {
                // Excel-Datum: Tage seit 1899-12-30 (mit dem ber√ºhmten Leap-Year-Bug)
                const excelEpoch = new Date(1899, 11, 30);
                const date = new Date(excelEpoch.getTime() + value * 24 * 60 * 60 * 1000);
                if (!isNaN(date)) return date;
            }
            
            const str = String(value).trim();
            if (!str) return null;
            
            // ISO-Format: 2026-01-08
            const isoMatch = str.match(/^(\d{4})-(\d{2})-(\d{2})/);
            if (isoMatch) {
                const date = new Date(parseInt(isoMatch[1]), parseInt(isoMatch[2]) - 1, parseInt(isoMatch[3]));
                if (!isNaN(date)) return date;
            }
            
            // Deutsches Format: 08.01.2026 oder 8.1.2026
            const deMatch = str.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})/);
            if (deMatch) {
                const date = new Date(parseInt(deMatch[3]), parseInt(deMatch[2]) - 1, parseInt(deMatch[1]));
                if (!isNaN(date)) return date;
            }
            
            // US-Format: 01/08/2026 oder 1/8/2026
            const usMatch = str.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
            if (usMatch) {
                const date = new Date(parseInt(usMatch[3]), parseInt(usMatch[1]) - 1, parseInt(usMatch[2]));
                if (!isNaN(date)) return date;
            }
            
            // Fallback: JavaScript Date-Parser
            const fallback = new Date(str);
            if (!isNaN(fallback)) return fallback;
            
            return null;
        }
        
        /**
         * Pr√ºft ob ein Datum den Filter-Bedingungen entspricht
         */
        function matchDateFilter(cellValue, operator, days = 0) {
            const cellDate = parseDateValue(cellValue);
            if (!cellDate) return false;
            
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            cellDate.setHours(0, 0, 0, 0);
            
            const diffMs = cellDate.getTime() - today.getTime();
            const diffDays = Math.round(diffMs / (24 * 60 * 60 * 1000));
            
            switch (operator) {
                case 'dateInDays':
                    // Datum liegt in der Zeitspanne von heute bis +X Tage
                    // Beispiel: days=7 zeigt alles was heute bis in 7 Tagen f√§llig wird
                    return diffDays >= 0 && diffDays <= days;
                    
                case 'dateOverdueDays':
                    // Datum liegt in der Zeitspanne von heute bis -X Tage
                    // Beispiel: days=7 zeigt alles was in den letzten 7 Tagen √ºberf√§llig wurde
                    return diffDays < 0 && Math.abs(diffDays) <= days;
                    
                case 'dateToday':
                    return diffDays === 0;
                    
                case 'datePast':
                    return diffDays < 0;
                    
                case 'dateFuture':
                    return diffDays > 0;
                    
                case 'dateThisWeek':
                    // Diese Woche = 0 bis 6 Tage in der Zukunft oder Vergangenheit ab Montag
                    const dayOfWeek = today.getDay(); // 0=So, 1=Mo, ..., 6=Sa
                    const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                    const monday = new Date(today);
                    monday.setDate(today.getDate() + mondayOffset);
                    const sunday = new Date(monday);
                    sunday.setDate(monday.getDate() + 6);
                    return cellDate >= monday && cellDate <= sunday;
                    
                case 'dateThisMonth':
                    return cellDate.getMonth() === today.getMonth() && 
                           cellDate.getFullYear() === today.getFullYear();
                    
                default:
                    return false;
            }
        }
        
        function filterExplorerData() {
            // Erstelle Array mit originalem Index f√ºr jede Zeile
            let filtered = explorerState.data.map((row, index) => ({ originalIndex: index, row: row }));
            
            // Versteckte Zeilen ausfiltern
            if (explorerState.hiddenRows.size > 0) {
                filtered = filtered.filter(item => !explorerState.hiddenRows.has(item.originalIndex));
            }
            
            // Volltextsuche mit Platzhalter-Unterst√ºtzung (* und ?)
            if (explorerState.searchTerm) {
                const term = explorerState.searchTerm;
                const hasWildcards = term.includes('*') || term.includes('?');
                
                if (hasWildcards) {
                    // Platzhalter-Suche: * = beliebig viele Zeichen, ? = ein Zeichen
                    const regex = wildcardToRegex(term);
                    filtered = filtered.filter(item => 
                        item.row.some(cell => cell && regex.test(String(cell)))
                    );
                } else {
                    // Normale Suche (case-insensitive, enth√§lt)
                    const lowerTerm = term.toLowerCase();
                    filtered = filtered.filter(item => 
                        item.row.some(cell => cell && String(cell).toLowerCase().includes(lowerTerm))
                    );
                }
            }
            
            // Spaltenfilter
            explorerState.filters.forEach(filter => {
                if (!filter.column) return;
                const colIndex = parseInt(filter.column);
                const value = (filter.value || '').toLowerCase();
                
                filtered = filtered.filter(item => {
                    const cellValue = String(item.row[colIndex] || '').toLowerCase();
                    const rawCellValue = item.row[colIndex];
                    
                    switch (filter.operator) {
                        // Text-Filter
                        case 'contains': return cellValue.includes(value);
                        case 'equals': return cellValue === value;
                        case 'startsWith': return cellValue.startsWith(value);
                        case 'endsWith': return cellValue.endsWith(value);
                        case 'notContains': return !cellValue.includes(value);
                        case 'isEmpty': return !rawCellValue || String(rawCellValue).trim() === '';
                        case 'isNotEmpty': return rawCellValue && String(rawCellValue).trim() !== '';
                        
                        // Datum-Filter
                        case 'dateInDays':
                        case 'dateOverdueDays':
                        case 'dateToday':
                        case 'datePast':
                        case 'dateFuture':
                        case 'dateThisWeek':
                        case 'dateThisMonth':
                            return matchDateFilter(rawCellValue, filter.operator, parseInt(filter.value) || 0);
                        
                        default: return true;
                    }
                });
            });
            
            explorerState.filteredData = filtered;
            explorerState.currentPage = 1; // Bei Filter√§nderung zur√ºck zur ersten Seite
            
            // Sortierung anwenden, wenn eine gesetzt ist
            if (explorerState.sortColumn !== null && explorerState.sortDirection !== null) {
                applyExplorerSort();
            }
            
            renderExplorerTable();
        }
        
        /**
         * Sortiert die Explorer-Daten nach einer Spalte
         */
        function sortExplorerByColumn(colIndex, sortType = 'auto') {
            // Toggle Sortierrichtung bei 'auto'
            if (sortType === 'auto') {
                if (explorerState.sortColumn === colIndex) {
                    if (explorerState.sortDirection === 'asc') {
                        explorerState.sortDirection = 'desc';
                    } else if (explorerState.sortDirection === 'desc') {
                        // Dritter Klick: Sortierung aufheben
                        explorerState.sortColumn = null;
                        explorerState.sortDirection = null;
                        explorerState.sortType = 'auto';
                        filterExplorerData(); // Neu filtern ohne Sortierung
                        return;
                    }
                } else {
                    explorerState.sortColumn = colIndex;
                    explorerState.sortDirection = 'asc';
                }
                explorerState.sortType = 'auto';
            } else {
                // Expliziter Sortiertyp vom Kontextmen√º
                explorerState.sortColumn = colIndex;
                explorerState.sortType = sortType;
                // Direction aus dem sortType ableiten
                explorerState.sortDirection = sortType.endsWith('-asc') ? 'asc' : 'desc';
            }
            
            applyExplorerSort();
            renderExplorerTable();
        }
        
        /**
         * Wendet die aktuelle Sortierung auf filteredData an
         */
        function applyExplorerSort() {
            if (explorerState.sortColumn === null) return;
            
            const colIndex = explorerState.sortColumn;
            const direction = explorerState.sortDirection;
            const sortType = explorerState.sortType || 'auto';
            
            explorerState.filteredData.sort((a, b) => {
                const valA = a.row[colIndex];
                const valB = b.row[colIndex];
                
                // Null-Werte ans Ende
                if (valA == null && valB == null) return 0;
                if (valA == null) return 1;
                if (valB == null) return -1;
                
                let comparison = 0;
                
                if (sortType === 'alpha-asc' || sortType === 'alpha-desc') {
                    // Alphabetische Sortierung
                    const strA = String(valA).toLowerCase();
                    const strB = String(valB).toLowerCase();
                    comparison = strA.localeCompare(strB, 'de');
                } else if (sortType === 'num-asc' || sortType === 'num-desc') {
                    // Numerische Sortierung
                    const numA = parseNumericValue(valA);
                    const numB = parseNumericValue(valB);
                    if (isNaN(numA) && isNaN(numB)) comparison = 0;
                    else if (isNaN(numA)) comparison = 1;
                    else if (isNaN(numB)) comparison = -1;
                    else comparison = numA - numB;
                } else if (sortType === 'date-asc' || sortType === 'date-desc') {
                    // Datums-Sortierung
                    const dateA = parseDateValue(valA);
                    const dateB = parseDateValue(valB);
                    if (!dateA && !dateB) comparison = 0;
                    else if (!dateA) comparison = 1;
                    else if (!dateB) comparison = -1;
                    else comparison = dateA.getTime() - dateB.getTime();
                } else {
                    // Auto: Numerisch wenn m√∂glich, sonst alphabetisch
                    const numA = parseFloat(valA);
                    const numB = parseFloat(valB);
                    
                    if (!isNaN(numA) && !isNaN(numB)) {
                        comparison = numA - numB;
                    } else {
                        const strA = String(valA).toLowerCase();
                        const strB = String(valB).toLowerCase();
                        if (strA < strB) comparison = -1;
                        else if (strA > strB) comparison = 1;
                        else comparison = 0;
                    }
                }
                
                return direction === 'asc' ? comparison : -comparison;
            });
        }
        
        /**
         * Parst einen Wert als Zahl (ber√ºcksichtigt deutsche Zahlenformate)
         */
        function parseNumericValue(value) {
            if (typeof value === 'number') return value;
            if (value == null) return NaN;
            const str = String(value).trim();
            // Deutsche Zahlen: 1.234,56 ‚Üí 1234.56
            const normalized = str.replace(/\./g, '').replace(',', '.');
            return parseFloat(normalized);
        }
        
        // ==================== Column Context Menu ====================
        let contextMenuColumn = null;
        
        function showColumnContextMenu(e, colIndex) {
            e.preventDefault();
            
            const menu = document.getElementById('columnContextMenu');
            const columnName = explorerState.headers[colIndex] || `Spalte ${colIndex + 1}`;
            
            document.getElementById('contextMenuColumnName').textContent = columnName;
            contextMenuColumn = colIndex;
            
            // Positionierung
            let x = e.clientX;
            let y = e.clientY;
            
            // Sicherstellen, dass das Men√º im Viewport bleibt
            menu.classList.remove('hidden');
            menu.style.display = 'block';
            const menuRect = menu.getBoundingClientRect();
            
            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }
            
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
        }
        
        function hideColumnContextMenu() {
            const menu = document.getElementById('columnContextMenu');
            if (menu) {
                menu.classList.add('hidden');
                menu.style.display = 'none';
            }
            contextMenuColumn = null;
        }
        
        function handleContextMenuAction(action) {
            if (contextMenuColumn === null) return;
            
            switch (action) {
                case 'sort-alpha-asc':
                    sortExplorerByColumn(contextMenuColumn, 'alpha-asc');
                    break;
                case 'sort-alpha-desc':
                    sortExplorerByColumn(contextMenuColumn, 'alpha-desc');
                    break;
                case 'sort-num-asc':
                    sortExplorerByColumn(contextMenuColumn, 'num-asc');
                    break;
                case 'sort-num-desc':
                    sortExplorerByColumn(contextMenuColumn, 'num-desc');
                    break;
                case 'sort-date-asc':
                    sortExplorerByColumn(contextMenuColumn, 'date-asc');
                    break;
                case 'sort-date-desc':
                    sortExplorerByColumn(contextMenuColumn, 'date-desc');
                    break;
                case 'filter-date-soon':
                    showDateFilterDialog(contextMenuColumn, 'dateInDays');
                    break;
                case 'filter-date-overdue':
                    showDateFilterDialog(contextMenuColumn, 'dateOverdueDays');
                    break;
                case 'hide-column':
                    toggleExplorerColumn(contextMenuColumn, false);
                    break;
                case 'delete-column':
                    deleteExplorerColumn(contextMenuColumn);
                    break;
                case 'insert-column-before':
                    insertExplorerColumn(contextMenuColumn, 'before');
                    break;
                case 'insert-column-after':
                    insertExplorerColumn(contextMenuColumn, 'after');
                    break;
            }
            
            hideColumnContextMenu();
        }
        
        /**
         * Zeigt Dialog f√ºr Datum-Filter mit Tage-Eingabe
         */
        function showDateFilterDialog(colIndex, filterType) {
            const columnName = explorerState.headers[colIndex] || `Spalte ${colIndex + 1}`;
            const title = filterType === 'dateInDays' 
                ? `‚è∞ F√§llig in X Tagen - ${columnName}`
                : `‚ö†Ô∏è √úberf√§llig seit X Tagen - ${columnName}`;
            const placeholder = filterType === 'dateInDays'
                ? 'Zeige Eintr√§ge die in den n√§chsten X Tagen f√§llig werden'
                : 'Zeige Eintr√§ge die seit X Tagen √ºberf√§llig sind';
            
            const days = prompt(title + '\n\n' + placeholder + '\n\nAnzahl Tage eingeben:', '7');
            
            if (days !== null && !isNaN(parseInt(days))) {
                // Filter hinzuf√ºgen
                addDateFilterForColumn(colIndex, filterType, parseInt(days));
            }
        }
        
        /**
         * F√ºgt einen Datum-Filter f√ºr eine Spalte hinzu
         */
        function addDateFilterForColumn(colIndex, operator, days) {
            // Filter-Panel √∂ffnen falls nicht sichtbar
            const filterPanel = document.getElementById('explorerFilterPanel');
            if (filterPanel && filterPanel.style.display === 'none') {
                filterPanel.style.display = 'block';
            }
            
            // Neuen Filter erstellen
            const template = document.getElementById('explorerFilterTemplate');
            const clone = template.content.cloneNode(true);
            const row = clone.querySelector('.explorer-filter-row');
            
            // Spalten-Dropdown bef√ºllen und ausw√§hlen
            const colSelect = row.querySelector('.filter-column');
            colSelect.innerHTML = `<option value="">${t('selectColumn')}</option>` + 
                explorerState.headers.map((h, i) => `<option value="${i}">${escapeHtml(h || `Spalte ${i + 1}`)}</option>`).join('');
            colSelect.value = colIndex;
            
            // Operator setzen
            const operatorSelect = row.querySelector('.filter-operator');
            operatorSelect.value = operator;
            
            // Tage-Feld konfigurieren
            const valueInput = row.querySelector('.filter-value');
            const daysInput = row.querySelector('.filter-days');
            valueInput.style.display = 'none';
            daysInput.style.display = 'block';
            daysInput.value = days;
            
            // Event-Listener
            operatorSelect.onchange = () => {
                const op = operatorSelect.value;
                const needsDays = op === 'dateInDays' || op === 'dateOverdueDays';
                const needsNoValue = ['dateToday', 'datePast', 'dateFuture', 'dateThisWeek', 'dateThisMonth', 'isEmpty', 'isNotEmpty'].includes(op);
                
                daysInput.style.display = needsDays ? 'block' : 'none';
                valueInput.style.display = needsNoValue ? 'none' : (needsDays ? 'none' : 'block');
                
                if (needsNoValue) {
                    valueInput.value = '_no_value_required_';
                } else if (needsDays) {
                    valueInput.value = '';
                }
                
                updateFiltersFromDOM();
            };
            
            row.querySelector('.remove-filter').onclick = () => {
                row.remove();
                updateFiltersFromDOM();
            };
            row.querySelector('.filter-column').onchange = updateFiltersFromDOM;
            daysInput.oninput = updateFiltersFromDOM;
            valueInput.oninput = updateFiltersFromDOM;
            
            document.getElementById('explorerFilters').appendChild(row);
            document.getElementById('btnClearExplorerFilters').disabled = false;
            
            // Filter anwenden
            updateFiltersFromDOM();
        }
        
        // Event-Listener f√ºr Kontextmen√º
        document.addEventListener('DOMContentLoaded', () => {
            // Kontextmen√º-Items
            document.querySelectorAll('#columnContextMenu .context-menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    handleContextMenuAction(item.dataset.action);
                });
            });
            
            // Klick au√üerhalb schlie√üt Men√º
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#columnContextMenu')) {
                    hideColumnContextMenu();
                }
            });
            
            // Escape schlie√üt Men√º
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hideColumnContextMenu();
                }
            });
            
            // Event-Delegation f√ºr Spalten-Kontextmen√º (robuster als pro-Element Listener)
            const explorerTableHead = document.getElementById('explorerTableHead');
            if (explorerTableHead) {
                explorerTableHead.addEventListener('contextmenu', (e) => {
                    const th = e.target.closest('.sortable-header');
                    if (th && th.dataset.col !== undefined) {
                        e.preventDefault();
                        e.stopPropagation();
                        const colIndex = parseInt(th.dataset.col);
                        showColumnContextMenu(e, colIndex);
                    }
                });
            }
        });
        
        /**
         * Verschiebt eine Spalte per Drag & Drop
         */
        function moveExplorerColumn(fromColIndex, toColIndex) {
            // Initialisiere columnOrder wenn n√∂tig - mit ALLEN Spalten (auch versteckte)
            if (explorerState.columnOrder.length === 0) {
                // Start mit allen Spalten in Original-Reihenfolge
                explorerState.columnOrder = explorerState.headers.map((_, i) => i);
            }
            
            // Finde die Positionen in columnOrder
            const fromPos = explorerState.columnOrder.indexOf(fromColIndex);
            const toPos = explorerState.columnOrder.indexOf(toColIndex);
            
            if (fromPos === -1 || toPos === -1) return;
            
            // Entferne die Spalte von der alten Position
            explorerState.columnOrder.splice(fromPos, 1);
            
            // F√ºge sie an der neuen Position ein
            explorerState.columnOrder.splice(toPos, 0, fromColIndex);
            
            // Markiere als strukturelle √Ñnderung
            const existingMoves = explorerState.editedCells.get('_columnMoved') || [];
            existingMoves.push({ from: fromColIndex, to: toColIndex });
            explorerState.editedCells.set('_columnMoved', existingMoves);
            
            // Tabelle neu rendern
            renderExplorerTable();
        }
        
        /**
         * Setzt die Spaltenreihenfolge zur√ºck
         */
        function resetExplorerColumnOrder() {
            explorerState.columnOrder = [];
            renderExplorerTable();
        }
        
        // Hilfsfunktion: Pr√ºft ob eine Zelle Teil eines Merged-Bereichs ist
        // Gibt zur√ºck: null (nicht merged), 'master' (Hauptzelle), 'hidden' (Teil eines Merges, ausblenden)
        function getMergedCellInfo(rowIndex, colIndex) {
            for (const merge of explorerState.mergedCells) {
                // rowIndex ist der Index im data-Array (0 = erste Datenzeile = Excel-Zeile 2)
                // merge.startRow ist 0-basierter Excel-Zeilen-Index (0 = Excel-Zeile 1)
                // Datenzeile 0 entspricht Excel-Zeile 2 ‚Üí 0-basierter Index 1
                const excelRowIndex0Based = rowIndex + 1;
                
                if (excelRowIndex0Based >= merge.startRow && excelRowIndex0Based <= merge.endRow &&
                    colIndex >= merge.startCol && colIndex <= merge.endCol) {
                    // Diese Zelle ist Teil eines Merges
                    if (excelRowIndex0Based === merge.startRow && colIndex === merge.startCol) {
                        // Master-Zelle (oben links)
                        return {
                            type: 'master',
                            rowSpan: merge.rowSpan,
                            colSpan: merge.colSpan
                        };
                    } else {
                        // Versteckte Zelle
                        return { type: 'hidden' };
                    }
                }
            }
            return null; // Nicht Teil eines Merges
        }
        
        // Hilfsfunktion: Pr√ºft ob eine Header-Zelle (Excel-Zeile 1) Teil eines Merged-Bereichs ist
        // excelRow0Based = 0 f√ºr Header (Excel-Zeile 1)
        function getHeaderMergedCellInfo(colIndex) {
            const excelRowIndex0Based = 0; // Header = Excel-Zeile 1 = 0-basiert Index 0
            for (const merge of explorerState.mergedCells) {
                if (excelRowIndex0Based >= merge.startRow && excelRowIndex0Based <= merge.endRow &&
                    colIndex >= merge.startCol && colIndex <= merge.endCol) {
                    // Diese Zelle ist Teil eines Merges
                    if (excelRowIndex0Based === merge.startRow && colIndex === merge.startCol) {
                        // Master-Zelle (oben links)
                        return {
                            type: 'master',
                            rowSpan: merge.rowSpan,
                            colSpan: merge.colSpan
                        };
                    } else {
                        // Versteckte Zelle
                        return { type: 'hidden' };
                    }
                }
            }
            return null; // Nicht Teil eines Merges
        }
        
        function renderExplorerTable() {
            const btnPreview = document.getElementById('btnExplorerPreview');
            const btnDataJoin = document.getElementById('btnDataJoin');
            
            if (!explorerState.headers.length) {
                elements.explorerTableHead.innerHTML = '';
                elements.explorerTableBody.innerHTML = '';
                elements.explorerResultCount.textContent = t('noDataLoaded');
                document.getElementById('explorerPagination').style.display = 'none';
                if (btnPreview) btnPreview.disabled = true;
                if (btnDataJoin) btnDataJoin.disabled = true;
                // Drop-Zone anzeigen wenn keine Daten
                showExplorerDropZone(true);
                return;
            }
            
            // Drop-Zone ausblenden wenn Daten vorhanden
            showExplorerDropZone(false);
            
            // Preview-Button aktivieren, wenn Daten vorhanden sind
            if (btnPreview) btnPreview.disabled = false;
            // Data Join Button aktivieren
            if (btnDataJoin) btnDataJoin.disabled = false;
            
            // Pagination berechnen
            const totalRows = explorerState.filteredData.length;
            const totalPages = Math.max(1, Math.ceil(totalRows / explorerState.pageSize));
            
            // Sicherstellen, dass currentPage g√ºltig ist
            if (explorerState.currentPage > totalPages) {
                explorerState.currentPage = totalPages;
            }
            if (explorerState.currentPage < 1) {
                explorerState.currentPage = 1;
            }
            
            const startIndex = (explorerState.currentPage - 1) * explorerState.pageSize;
            const endIndex = Math.min(startIndex + explorerState.pageSize, totalRows);
            const pageData = explorerState.filteredData.slice(startIndex, endIndex);
            
            // Header mit Sortierung und Drag & Drop
            // Verwende columnOrder wenn gesetzt, sonst visibleColumns
            const displayColumns = explorerState.columnOrder.length > 0 
                ? explorerState.columnOrder.filter(col => explorerState.visibleColumns.includes(col))
                : explorerState.visibleColumns;
            
            // Pr√ºfe ob alle sichtbaren Zeilen ausgew√§hlt sind
            const allVisibleSelected = pageData.length > 0 && pageData.every(item => explorerState.selectedRows.has(item.originalIndex));
            
            // Erste Zeile: Excel-Spaltenbuchstaben (A, B, C, ...)
            let headerHtml = '<tr class="column-letter-row">';
            // Leere Zelle f√ºr Zeilennummer-Spalte
            headerHtml += `<th style="width: 40px; min-width: 40px; max-width: 40px; text-align: center; padding: 2px 4px; background: var(--bg-lighter); color: var(--text-muted); font-size: 10px; font-weight: normal; position: sticky; left: 0; z-index: 2; border-bottom: none;"></th>`;
            // Leere Zelle f√ºr Checkbox-Spalte
            headerHtml += `<th style="width: 40px; min-width: 40px; max-width: 40px; text-align: center; padding: 2px 4px; background: var(--bg-lighter); position: sticky; left: 40px; z-index: 2; border-bottom: none;"></th>`;
            displayColumns.forEach(colIndex => {
                // Pr√ºfe ob dieser Spaltenbuchstabe Teil eines Header-Merges ist
                const headerMergeInfo = getHeaderMergedCellInfo(colIndex);
                if (headerMergeInfo && headerMergeInfo.type === 'hidden') {
                    // Diese Spalte geh√∂rt zu einem Header-Merge, wird nicht gerendert
                    return;
                }
                
                const colLetter = getColumnLetter(colIndex + 1);
                
                // Colspan f√ºr Merged Header berechnen
                let colspanAttr = '';
                if (headerMergeInfo && headerMergeInfo.type === 'master' && headerMergeInfo.colSpan > 1) {
                    let visibleColSpan = 0;
                    for (let i = 0; i < headerMergeInfo.colSpan; i++) {
                        if (displayColumns.includes(colIndex + i)) {
                            visibleColSpan++;
                        }
                    }
                    if (visibleColSpan > 1) {
                        // Zeige Bereich wie A-H
                        const endColLetter = getColumnLetter(colIndex + headerMergeInfo.colSpan);
                        colspanAttr = ` colspan="${visibleColSpan}"`;
                        headerHtml += `<th style="text-align: center; padding: 2px 4px; background: var(--bg-lighter); color: var(--text-muted); font-size: 10px; font-weight: normal; border-bottom: none;"${colspanAttr} title="Excel-Spalten ${colLetter}-${endColLetter}">${colLetter}-${endColLetter}</th>`;
                        return;
                    }
                }
                
                headerHtml += `<th style="text-align: center; padding: 2px 4px; background: var(--bg-lighter); color: var(--text-muted); font-size: 10px; font-weight: normal; border-bottom: none;" title="Excel-Spalte ${colLetter}">${colLetter}</th>`;
            });
            headerHtml += '</tr>';
            
            // Zweite Zeile: Spalten√ºberschriften mit Sortierung
            headerHtml += '<tr>';
            // Zeilennummer-Spalte (fest, nicht verschiebbar)
            headerHtml += `<th style="width: 40px; min-width: 40px; max-width: 40px; text-align: center; padding: 4px; background: var(--bg-lighter); color: var(--text-muted); font-size: 11px; position: sticky; left: 0; z-index: 2;" title="Zeilennummer">#</th>`;
            // Checkbox-Spalte f√ºr Zeilenauswahl
            headerHtml += `<th style="width: 40px; min-width: 40px; max-width: 40px; text-align: center; padding: 4px; position: sticky; left: 40px; z-index: 2; background: var(--bg-lighter);">
                <input type="checkbox" id="selectAllRows" ${allVisibleSelected ? 'checked' : ''} 
                    title="Alle sichtbaren Zeilen ausw√§hlen" style="cursor: pointer; width: 16px; height: 16px;">
            </th>`;
            
            displayColumns.forEach(colIndex => {
                // Pr√ºfe ob dieser Header Teil eines Merged-Bereichs ist
                const headerMergeInfo = getHeaderMergedCellInfo(colIndex);
                if (headerMergeInfo && headerMergeInfo.type === 'hidden') {
                    // Diese Spalte geh√∂rt zu einem Header-Merge, wird nicht gerendert (colspan √ºbernimmt)
                    return;
                }
                
                const headerText = escapeHtml(explorerState.headers[colIndex] || `Spalte ${colIndex + 1}`);
                const colLetter = getColumnLetter(colIndex + 1);
                let sortIcon = '';
                if (explorerState.sortColumn === colIndex) {
                    sortIcon = explorerState.sortDirection === 'asc' ? ' ‚ñ≤' : ' ‚ñº';
                }
                
                // Header-Styles anwenden (Zeile 0)
                const headerStyleKey = `0-${colIndex}`;
                const headerStyle = explorerState.cellStyles[headerStyleKey];
                let inlineStyle = '';
                if (headerStyle) {
                    const styles = [];
                    if (headerStyle.bold) styles.push('font-weight: bold');
                    if (headerStyle.italic) styles.push('font-style: italic');
                    if (headerStyle.fontColor) styles.push(`color: ${headerStyle.fontColor}`);
                    if (headerStyle.fill) styles.push(`background-color: ${headerStyle.fill}`);
                    if (styles.length > 0) {
                        inlineStyle = ` style="${styles.join('; ')}"`;
                    }
                }
                
                // Merged Cell Attribute f√ºr Header
                let mergedAttrs = '';
                let mergedClass = '';
                let mergedIcon = '';
                if (headerMergeInfo && headerMergeInfo.type === 'master') {
                    mergedClass = ' merged-cell merged-cell-master';
                    // colspan nur f√ºr sichtbare Spalten berechnen
                    const colSpan = headerMergeInfo.colSpan;
                    // Berechne wie viele der Merge-Spalten tats√§chlich in displayColumns sind
                    let visibleColSpan = 0;
                    for (let i = 0; i < colSpan; i++) {
                        if (displayColumns.includes(colIndex + i)) {
                            visibleColSpan++;
                        }
                    }
                    if (visibleColSpan > 1) {
                        mergedAttrs = ` colspan="${visibleColSpan}"`;
                    }
                    // Icon anzeigen wenn merged
                    if (headerMergeInfo.colSpan > 1) {
                        mergedIcon = `<span class="merged-icon" title="Verbundene Header-Zellen: 1√ó${headerMergeInfo.colSpan}">‚äû</span>`;
                    }
                }
                
                // Merged Headers sind NICHT verschiebbar (zu komplex)
                const isMergedHeader = headerMergeInfo && headerMergeInfo.type === 'master' && headerMergeInfo.colSpan > 1;
                const draggableAttr = isMergedHeader ? 'draggable="false"' : 'draggable="true"';
                const titleText = isMergedHeader 
                    ? `Spalte ${colLetter} - Verbundene Spalten k√∂nnen nicht verschoben werden` 
                    : `Spalte ${colLetter} - Klicken zum Sortieren, Ziehen zum Verschieben`;
                const notDraggableStyle = isMergedHeader ? ' style="cursor: not-allowed;"' : '';
                
                headerHtml += `<th class="sortable-header${mergedClass}${isMergedHeader ? ' not-draggable' : ''}" data-col="${colIndex}" ${draggableAttr} title="${titleText}"${inlineStyle}${mergedAttrs}${notDraggableStyle}>${mergedIcon}${headerText}${sortIcon}</th>`;
            });
            headerHtml += '</tr>';
            elements.explorerTableHead.innerHTML = headerHtml;
            
            // Select-All Checkbox Event-Listener
            const selectAllCheckbox = document.getElementById('selectAllRows');
            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', function() {
                    pageData.forEach(item => {
                        if (this.checked) {
                            explorerState.selectedRows.add(item.originalIndex);
                        } else {
                            explorerState.selectedRows.delete(item.originalIndex);
                        }
                    });
                    updateRowSelectionUI();
                    updateRowMoveToolbar();
                });
            }
            
            // Sortier- und Drag-Event-Listener
            document.querySelectorAll('#explorerTableHead .sortable-header').forEach(th => {
                // Klick zum Sortieren
                th.addEventListener('click', (e) => {
                    // Nur sortieren wenn nicht gerade gedraggt wurde
                    if (!th.classList.contains('was-dragged')) {
                        const colIndex = parseInt(th.dataset.col);
                        sortExplorerByColumn(colIndex);
                    }
                    th.classList.remove('was-dragged');
                });
                
                // Rechtsklick f√ºr Kontextmen√º wird jetzt via Event-Delegation auf thead behandelt
                
                // Drag Start
                th.addEventListener('dragstart', (e) => {
                    explorerState.draggedColumn = parseInt(th.dataset.col);
                    th.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', th.dataset.col);
                });
                
                // Drag Over - OPTIMIERT: nur preventDefault ohne DOM-Manipulation
                th.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                });
                
                // Drag Enter - einmalig statt kontinuierlich
                th.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    if (parseInt(th.dataset.col) !== explorerState.draggedColumn) {
                        th.classList.add('drag-over');
                    }
                });
                
                // Drag Leave
                th.addEventListener('dragleave', (e) => {
                    // Nur entfernen wenn wirklich verlassen (nicht bei Child-Elements)
                    if (e.target === th) {
                        th.classList.remove('drag-over');
                    }
                });
                
                // Drag End
                th.addEventListener('dragend', () => {
                    th.classList.remove('dragging');
                    document.querySelectorAll('.sortable-header').forEach(h => h.classList.remove('drag-over'));
                });
                
                // Drop
                th.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    th.classList.remove('drag-over');
                    
                    const fromCol = explorerState.draggedColumn;
                    const toCol = parseInt(th.dataset.col);
                    
                    if (fromCol !== toCol && fromCol !== null) {
                        // Markiere dass gedraggt wurde (verhindert Sortierung beim Klick)
                        th.classList.add('was-dragged');
                        
                        // Aktualisiere die Spaltenreihenfolge
                        moveExplorerColumn(fromCol, toCol);
                    }
                    
                    explorerState.draggedColumn = null;
                });
            });
            
            // Body - nur die aktuelle Seite rendern (mit editierbaren Zellen)
            let bodyHtml = '';
            pageData.forEach(item => {
                const originalIndex = item.originalIndex;
                const row = item.row;
                const isSelected = explorerState.selectedRows.has(originalIndex);
                const selectedClass = isSelected ? ' class="row-selected"' : '';
                // Datenzeilen-Nummer = originalIndex + 1 (1-basiert, passend zur Verschiebe-Funktion)
                const dataRowNumber = originalIndex + 1;
                bodyHtml += `<tr data-original-index="${originalIndex}"${selectedClass}>`;
                // Zeilennummer-Zelle (fest, sticky)
                bodyHtml += `<td class="row-number-cell" style="width: 40px; min-width: 40px; max-width: 40px; text-align: center; padding: 4px; background: var(--bg-lighter); color: var(--text-muted); font-size: 11px; font-family: monospace; position: sticky; left: 0; z-index: 1; user-select: none;" title="Datenzeile ${dataRowNumber}">${dataRowNumber}</td>`;
                // Checkbox-Zelle f√ºr Zeilenauswahl
                bodyHtml += `<td class="row-checkbox-cell ${isSelected ? 'selected' : ''}" style="width: 40px; min-width: 40px; max-width: 40px; position: sticky; left: 40px; z-index: 1; background: var(--bg-secondary);">
                    <input type="checkbox" class="row-select-checkbox" data-row-index="${originalIndex}" 
                        ${isSelected ? 'checked' : ''}>
                </td>`;
                displayColumns.forEach(colIndex => {
                    // Pr√ºfe ob diese Zelle Teil eines Merged-Bereichs ist
                    const mergeInfo = getMergedCellInfo(originalIndex, colIndex);
                    if (mergeInfo && mergeInfo.type === 'hidden') {
                        // Diese Zelle geh√∂rt zu einem Merge, wird nicht gerendert (colspan/rowspan √ºbernimmt)
                        return;
                    }
                    
                    const cellValue = String(row[colIndex] ?? '');
                    const cellKey = `${originalIndex}-${colIndex}`;
                    const isEdited = explorerState.editedCells.has(cellKey);
                    const editedClass = isEdited ? ' edited' : '';
                    // Hole den echten Original-Wert aus originalData
                    const originalRow = explorerState.originalData[originalIndex];
                    const originalValue = originalRow ? String(originalRow[colIndex] ?? '') : cellValue;
                    
                    // Merged Cell Attribute
                    let mergedClass = '';
                    let mergedAttrs = '';
                    let mergedIcon = '';
                    let mergedMasterRow = originalIndex;  // F√ºr Style-Lookup bei Merged Cells
                    let mergedMasterCol = colIndex;
                    if (mergeInfo && mergeInfo.type === 'master') {
                        mergedClass = ' merged-cell merged-cell-master';
                        // colspan nur wenn Spalte sichtbar
                        const visibleColSpan = Math.min(mergeInfo.colSpan, displayColumns.length - displayColumns.indexOf(colIndex));
                        if (visibleColSpan > 1) {
                            mergedAttrs += ` colspan="${visibleColSpan}"`;
                        }
                        // rowspan - berechne wie viele Zeilen auf der aktuellen Seite sichtbar sind
                        if (mergeInfo.rowSpan > 1) {
                            // Berechne wie viele Zeilen des Merges auf dieser Seite sichtbar sind
                            const pageStartIndex = (explorerState.currentPage - 1) * explorerState.pageSize;
                            const pageEndIndex = pageStartIndex + explorerState.pageSize - 1;
                            const mergeEndRow = originalIndex + mergeInfo.rowSpan - 1;
                            const visibleRowSpan = Math.min(mergeInfo.rowSpan, pageEndIndex - originalIndex + 1);
                            if (visibleRowSpan > 1) {
                                mergedAttrs += ` rowspan="${visibleRowSpan}"`;
                            }
                        }
                        // Icon anzeigen wenn merged
                        if (mergeInfo.rowSpan > 1 || mergeInfo.colSpan > 1) {
                            mergedIcon = `<span class="merged-icon" title="Verbundene Zellen: ${mergeInfo.rowSpan}√ó${mergeInfo.colSpan}">‚äû</span>`;
                        }
                    }
                    
                    // Cell Styles aus Excel
                    // Bei Merged Cells: Style der Master-Zelle verwenden
                    const cellStyleKey = `${mergedMasterRow + 1}-${mergedMasterCol}`; // +1 weil Styles inkl. Header-Zeile gespeichert sind
                    const cellStyle = explorerState.cellStyles[cellStyleKey];
                    let inlineStyle = '';
                    
                    // Formel pr√ºfen (gleicher Key wie cellStyles)
                    const cellFormula = explorerState.cellFormulas[cellStyleKey];
                    const hasFormula = !!cellFormula;
                    const formulaTooltip = hasFormula ? ` title="Formel: =${escapeHtml(cellFormula)}"` : '';
                    const formulaClass = hasFormula ? ' has-formula' : '';
                    const formulaIcon = hasFormula ? '<span class="formula-icon" title="Diese Zelle enth√§lt eine Formel">∆í</span>' : '';
                    
                    // Hyperlink pr√ºfen (gleicher Key wie cellStyles)
                    const cellHyperlink = explorerState.cellHyperlinks[cellStyleKey];
                    const hasHyperlink = !!cellHyperlink;
                    const hyperlinkClass = hasHyperlink ? ' has-hyperlink' : '';
                    const hyperlinkIcon = hasHyperlink ? '<span class="hyperlink-icon" title="Link √∂ffnen: ' + escapeHtml(cellHyperlink) + '">üîó</span>' : '';
                    
                    // Rich Text pr√ºfen (gleicher Key wie cellStyles)
                    const richTextFragments = explorerState.richTextCells[cellStyleKey];
                    const hasRichText = richTextFragments && richTextFragments.length > 0;
                    let richTextHtml = '';
                    if (hasRichText) {
                        // Generiere HTML f√ºr Rich Text Fragmente
                        richTextHtml = richTextFragments.map(fragment => {
                            const styles = [];
                            if (fragment.styles) {
                                if (fragment.styles.bold) styles.push('font-weight: bold');
                                if (fragment.styles.italic) styles.push('font-style: italic');
                                if (fragment.styles.underline) styles.push('text-decoration: underline');
                                if (fragment.styles.strikethrough) styles.push('text-decoration: line-through');
                                if (fragment.styles.subscript) styles.push('vertical-align: sub; font-size: smaller');
                                if (fragment.styles.superscript) styles.push('vertical-align: super; font-size: smaller');
                                // Unterst√ºtze sowohl "fontColor" als auch "color"
                                const fragmentColor = fragment.styles.fontColor || fragment.styles.color;
                                if (fragmentColor) styles.push(`color: ${fragmentColor}`);
                                if (fragment.styles.fontSize) styles.push(`font-size: ${fragment.styles.fontSize}px`);
                            }
                            const styleAttr = styles.length > 0 ? ` style="${styles.join('; ')}"` : '';
                            return `<span${styleAttr}>${escapeHtml(fragment.text)}</span>`;
                        }).join('');
                    }
                    const richTextClass = hasRichText ? ' has-rich-text' : '';
                    
                    // Echte Style-Anwendung
                    if (cellStyle) {
                        const styles = [];
                        if (cellStyle.bold) styles.push('font-weight: bold');
                        if (cellStyle.italic) styles.push('font-style: italic');
                        if (cellStyle.underline) styles.push('text-decoration: underline');
                        if (cellStyle.strikethrough) styles.push('text-decoration: line-through');
                        if (cellStyle.fontColor) styles.push(`color: ${cellStyle.fontColor}`);
                        if (cellStyle.fill) styles.push(`background-color: ${cellStyle.fill}`);
                        if (cellStyle.fontSize && cellStyle.fontSize !== 11) styles.push(`font-size: ${cellStyle.fontSize}px`);
                        if (cellStyle.textAlign) styles.push(`text-align: ${cellStyle.textAlign}`);
                        if (styles.length > 0) {
                            inlineStyle = ` style="${styles.join('; ')}"`;
                        }
                    }
                    
                    // Pr√ºfe auf Data Validation (Dropdown-Liste)
                    const validation = explorerState.dataValidations[colIndex];
                    let validationValues = null;
                    
                    if (validation) {
                        if (validation.type === 'column') {
                            // Spaltenweite Validation
                            validationValues = validation.values;
                        } else if (validation.type === 'rows' && validation.rows[originalIndex + 1]) {
                            // Zeilenspezifische Validation (+1 weil Header-Zeile abgezogen wurde)
                            validationValues = validation.rows[originalIndex + 1].values;
                        }
                    }
                    
                    if (validationValues && validationValues.length > 0) {
                        // Zelle mit Dropdown rendern
                        const options = validationValues.map(v => {
                            const escaped = escapeHtml(v);
                            const selected = v === cellValue ? ' selected' : '';
                            return `<option value="${escaped}"${selected}>${escaped}</option>`;
                        }).join('');
                        // F√ºge leere Option hinzu wenn allowBlank
                        const emptyOption = validation.allowBlank !== false ? '<option value=""></option>' : '';
                        bodyHtml += `<td class="has-dropdown${editedClass}${formulaClass}${hyperlinkClass}${mergedClass}" data-row="${originalIndex}" data-col="${colIndex}" data-original="${escapeHtml(originalValue)}"${inlineStyle}${formulaTooltip}${hasHyperlink ? ` data-hyperlink="${escapeHtml(cellHyperlink)}"` : ''}${mergedAttrs}>
                            ${mergedIcon}${hyperlinkIcon}${formulaIcon}<select class="cell-dropdown" data-row="${originalIndex}" data-col="${colIndex}"${inlineStyle}>
                                ${emptyOption}${options}
                            </select>
                        </td>`;
                    } else {
                        // Normale editierbare Zelle
                        // Bestimme den anzuzeigenden Inhalt (Rich Text oder normaler Text)
                        const cellContent = hasRichText ? richTextHtml : escapeHtml(cellValue);
                        
                        if (hasHyperlink) {
                            // Zelle mit klickbarem Hyperlink
                            bodyHtml += `<td contenteditable="true" data-row="${originalIndex}" data-col="${colIndex}" data-original="${escapeHtml(originalValue)}" data-hyperlink="${escapeHtml(cellHyperlink)}" class="${editedClass}${formulaClass}${hyperlinkClass}${richTextClass}${mergedClass}"${inlineStyle}${formulaTooltip}${mergedAttrs}>${mergedIcon}${hyperlinkIcon}${formulaIcon}<span class="cell-content">${cellContent}</span></td>`;
                        } else if (hasRichText) {
                            // Zelle mit Rich Text (gemischte Formatierung)
                            bodyHtml += `<td contenteditable="true" data-row="${originalIndex}" data-col="${colIndex}" data-original="${escapeHtml(originalValue)}" class="${editedClass}${formulaClass}${richTextClass}${mergedClass}"${inlineStyle}${formulaTooltip}${mergedAttrs}>${mergedIcon}${formulaIcon}<span class="cell-content">${cellContent}</span></td>`;
                        } else {
                            bodyHtml += `<td contenteditable="true" data-row="${originalIndex}" data-col="${colIndex}" data-original="${escapeHtml(originalValue)}" class="${editedClass}${formulaClass}${mergedClass}"${inlineStyle}${formulaTooltip}${mergedAttrs}>${mergedIcon}${formulaIcon}${cellContent}</td>`;
                        }
                    }
                });
                bodyHtml += '</tr>';
            });
            elements.explorerTableBody.innerHTML = bodyHtml || '<tr><td colspan="100" style="text-align: center; padding: 20px;">Keine Daten gefunden</td></tr>';
            
            // Zeilen-Highlights anwenden
            applyRowHighlights();
            
            // Event-Listener f√ºr Zeilen-Checkboxen
            document.querySelectorAll('.row-select-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const rowIndex = parseInt(this.dataset.rowIndex);
                    if (this.checked) {
                        explorerState.selectedRows.add(rowIndex);
                        this.closest('tr').classList.add('row-selected');
                        this.parentElement.classList.add('selected');
                    } else {
                        explorerState.selectedRows.delete(rowIndex);
                        this.closest('tr').classList.remove('row-selected');
                        this.parentElement.classList.remove('selected');
                    }
                    updateRowMoveToolbar();
                    // Update Select-All Checkbox
                    const selectAllCheckbox = document.getElementById('selectAllRows');
                    if (selectAllCheckbox) {
                        const allChecked = pageData.every(item => explorerState.selectedRows.has(item.originalIndex));
                        selectAllCheckbox.checked = allChecked && pageData.length > 0;
                    }
                });
            });
            
            // Rechtsklick-Kontextmen√º f√ºr Zeilen (nur Checkbox-Spalte)
            document.querySelectorAll('#explorerTableBody tr .row-checkbox-cell').forEach(cell => {
                cell.addEventListener('contextmenu', (e) => {
                    const tr = cell.closest('tr');
                    const rowIndex = parseInt(tr.dataset.originalIndex);
                    if (!isNaN(rowIndex)) {
                        showRowContextMenu(e, rowIndex);
                    }
                });
            });
            
            // Event-Listener f√ºr Hyperlinks (Ctrl+Click oder Doppelklick √∂ffnet den Link)
            document.querySelectorAll('#explorerTableBody td.has-hyperlink .cell-content').forEach(span => {
                span.addEventListener('click', function(e) {
                    // Ctrl+Click oder Cmd+Click √∂ffnet den Link
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        e.stopPropagation();
                        const td = this.closest('td');
                        const hyperlink = td.dataset.hyperlink;
                        if (hyperlink) {
                            window.electronAPI.openExternal(hyperlink);
                        }
                    }
                });
                
                span.addEventListener('dblclick', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const td = this.closest('td');
                    const hyperlink = td.dataset.hyperlink;
                    if (hyperlink) {
                        window.electronAPI.openExternal(hyperlink);
                    }
                });
            });
            
            // Event-Listener f√ºr editierbare Zellen
            document.querySelectorAll('#explorerTableBody td[contenteditable]').forEach(td => {
                // Speichere den letzten bekannten Wert f√ºr Undo
                td.dataset.lastValue = td.textContent;
                
                td.addEventListener('input', function() {
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    const original = this.dataset.original;
                    const current = this.textContent;
                    const cellKey = `${rowIndex}-${colIndex}`;
                    
                    if (original !== current) {
                        // √Ñnderung speichern
                        explorerState.editedCells.set(cellKey, current);
                        explorerState.data[rowIndex][colIndex] = current;
                        this.classList.add('edited');
                    } else {
                        // Zur√ºck zum Original
                        explorerState.editedCells.delete(cellKey);
                        this.classList.remove('edited');
                    }
                    
                    // Status aktualisieren
                    updateExplorerEditStatus();
                });
                
                // Blur: Undo-Aktion speichern
                td.addEventListener('blur', function() {
                    this.parentElement.classList.remove('editing-row');
                    
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    const original = this.dataset.original;
                    const lastValue = this.dataset.lastValue;
                    const current = this.textContent;
                    
                    // Nur Undo speichern wenn sich der Wert ge√§ndert hat
                    if (lastValue !== current) {
                        pushExplorerUndo({
                            rowIndex,
                            colIndex,
                            oldValue: lastValue,
                            newValue: current,
                            originalValue: original
                        });
                        this.dataset.lastValue = current;
                    }
                });
                
                // Fokus-Verhalten
                td.addEventListener('focus', function() {
                    this.parentElement.classList.add('editing-row');
                });
                
                // Paste-Handler f√ºr Einf√ºgen aus Zwischenablage
                td.addEventListener('paste', function(e) {
                    e.preventDefault();
                    const text = (e.clipboardData || window.clipboardData).getData('text/plain');
                    
                    // Text als reinen Text einf√ºgen (ohne Formatierung)
                    document.execCommand('insertText', false, text);
                });
                
                // Enter-Taste: Zur n√§chsten Zeile springen
                td.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        const nextRow = this.parentElement.nextElementSibling;
                        if (nextRow) {
                            const colIndex = parseInt(this.dataset.col);
                            const nextCell = nextRow.querySelector(`td[data-col="${colIndex}"]`);
                            if (nextCell) nextCell.focus();
                        }
                    } else if (e.key === 'Escape') {
                        // Escape: √Ñnderung verwerfen
                        this.textContent = this.dataset.original;
                        const rowIndex = parseInt(this.dataset.row);
                        const colIndex = parseInt(this.dataset.col);
                        const cellKey = `${rowIndex}-${colIndex}`;
                        explorerState.editedCells.delete(cellKey);
                        explorerState.data[rowIndex][colIndex] = this.dataset.original;
                        this.classList.remove('edited');
                        this.dataset.lastValue = this.dataset.original;
                        this.blur();
                        updateExplorerEditStatus();
                    } else if (e.key === 'Delete' || e.key === 'Backspace') {
                        // Delete/Backspace bei Zellen-Auswahl: Alle l√∂schen
                        if (explorerState.selectedCells.size > 1 && !document.activeElement.isContentEditable) {
                            e.preventDefault();
                            deleteSelectedCellsContent();
                        }
                    }
                });
                
                // Mausklick f√ºr Zellen-Auswahl
                td.addEventListener('mousedown', function(e) {
                    // Nur linke Maustaste und nicht bei Content-Bearbeitung
                    if (e.button !== 0) return;
                    
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    
                    if (e.shiftKey && explorerState.selectionAnchor) {
                        // Shift+Klick: Bereich ausw√§hlen
                        e.preventDefault();
                        selectCellRange(rowIndex, colIndex);
                    } else if (e.ctrlKey || e.metaKey) {
                        // Ctrl/Cmd+Klick: Zur Auswahl hinzuf√ºgen/entfernen
                        e.preventDefault();
                        toggleCellSelection(rowIndex, colIndex, true);
                    } else {
                        // Normaler Klick: Auswahl-Anker setzen (f√ºr sp√§tere Shift-Auswahl)
                        // Nicht die Auswahl leeren wenn die Zelle bereits ausgew√§hlt ist
                        if (!explorerState.selectedCells.has(`${rowIndex}-${colIndex}`)) {
                            explorerState.selectedCells.clear();
                        }
                        explorerState.selectionAnchor = { row: rowIndex, col: colIndex };
                        explorerState.isSelecting = true;
                    }
                });
                
                // Maus-Drag f√ºr Bereichsauswahl
                td.addEventListener('mouseenter', function(e) {
                    if (explorerState.isSelecting && e.buttons === 1) {
                        const rowIndex = parseInt(this.dataset.row);
                        const colIndex = parseInt(this.dataset.col);
                        selectCellRange(rowIndex, colIndex);
                    }
                });
                
                // Rechtsklick f√ºr Zellen-Kontextmen√º
                td.addEventListener('contextmenu', function(e) {
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    showCellContextMenu(e, rowIndex, colIndex);
                });
            });
            
            // Event-Listener f√ºr Dropdown-Zellen (Data Validation)
            document.querySelectorAll('#explorerTableBody .cell-dropdown').forEach(select => {
                // Speichere den initialen Wert f√ºr Undo
                select.dataset.lastValue = select.value;
                
                select.addEventListener('change', function() {
                    const rowIndex = parseInt(this.dataset.row);
                    const colIndex = parseInt(this.dataset.col);
                    const td = this.closest('td');
                    const original = td.dataset.original;
                    const lastValue = this.dataset.lastValue;
                    const current = this.value;
                    const cellKey = `${rowIndex}-${colIndex}`;
                    
                    if (original !== current) {
                        // √Ñnderung speichern
                        explorerState.editedCells.set(cellKey, current);
                        explorerState.data[rowIndex][colIndex] = current;
                        td.classList.add('edited');
                    } else {
                        // Zur√ºck zum Original
                        explorerState.editedCells.delete(cellKey);
                        td.classList.remove('edited');
                    }
                    
                    // Undo-Aktion speichern
                    if (lastValue !== current) {
                        pushExplorerUndo({
                            rowIndex,
                            colIndex,
                            oldValue: lastValue,
                            newValue: current,
                            originalValue: original
                        });
                        this.dataset.lastValue = current;
                    }
                    
                    // Status aktualisieren
                    updateExplorerEditStatus();
                });
            });
            
            // Maus-Release: Auswahl beenden
            document.addEventListener('mouseup', function() {
                explorerState.isSelecting = false;
            });
            
            // Ergebnis-Info mit Pagination
            if (totalRows > 0) {
                const editedCount = explorerState.editedCells.size;
                const editedInfo = editedCount > 0 ? ` (${editedCount} bearbeitet)` : '';
                elements.explorerResultCount.textContent = `Zeige ${startIndex + 1}-${endIndex} von ${totalRows} Zeilen (gesamt: ${explorerState.data.length})${editedInfo}`;
            } else {
                elements.explorerResultCount.textContent = `0 von ${explorerState.data.length} Zeilen`;
            }
            
            // Pagination UI aktualisieren
            updateExplorerPagination(totalPages);
            
            // Row Move Toolbar aktualisieren
            updateRowMoveToolbar();
        }
        
        // Aktualisiert die Row Move Toolbar basierend auf der Auswahl
        function updateRowMoveToolbar() {
            const toolbar = document.getElementById('rowMoveToolbar');
            const countSpan = document.getElementById('selectedRowCount');
            const selectedCount = explorerState.selectedRows.size;
            
            if (toolbar && countSpan) {
                countSpan.textContent = selectedCount;
                toolbar.style.display = selectedCount > 0 ? 'flex' : 'none';
            }
        }
        
        // Aktualisiert die visuelle Auswahl der Zeilen
        function updateRowSelectionUI() {
            document.querySelectorAll('.row-select-checkbox').forEach(checkbox => {
                const rowIndex = parseInt(checkbox.dataset.rowIndex);
                const isSelected = explorerState.selectedRows.has(rowIndex);
                checkbox.checked = isSelected;
                const tr = checkbox.closest('tr');
                const td = checkbox.parentElement;
                if (tr) {
                    if (isSelected) {
                        tr.classList.add('row-selected');
                        td.classList.add('selected');
                    } else {
                        tr.classList.remove('row-selected');
                        td.classList.remove('selected');
                    }
                }
            });
        }
        
        // F√ºhrt das Verschieben der ausgew√§hlten Zeilen aus
        async function executeRowMove() {
            const selectedCount = explorerState.selectedRows.size;
            if (selectedCount === 0) {
                showNotification('Keine Zeilen ausgew√§hlt', 'warning');
                return;
            }
            
            const movePosition = document.getElementById('movePosition').value; // 'before' oder 'after'
            const targetRowInput = document.getElementById('moveTargetRow');
            const targetRow = parseInt(targetRowInput.value);
            
            if (isNaN(targetRow) || targetRow < 1 || targetRow > explorerState.data.length) {
                showNotification(`Ung√ºltige Zielzeile. Bitte eine Zahl zwischen 1 und ${explorerState.data.length} eingeben.`, 'warning');
                return;
            }
            
            // Zielindex (0-basiert)
            let targetIndex = targetRow - 1;
            
            // Sortiere die ausgew√§hlten Indizes
            const selectedIndices = Array.from(explorerState.selectedRows).sort((a, b) => a - b);
            
            // Pr√ºfe ob Zielzeile in der Auswahl enthalten ist
            if (explorerState.selectedRows.has(targetIndex)) {
                showNotification('Die Zielzeile kann nicht in der Auswahl enthalten sein.', 'warning');
                return;
            }
            
            // Speichere den aktuellen Zustand f√ºr Undo - EFFIZIENT: nur betroffene Zeilen
            // Wir speichern nur die Indizes und lassen den State unver√§ndert im Undo-System
            const previousDataOrder = explorerState.data.map((_, i) => i);
            const previousCellStyles = { ...explorerState.cellStyles }; // Flache Kopie reicht
            const previousRichTextCells = { ...explorerState.richTextCells }; // Flache Kopie reicht
            
            // WICHTIG: Style-Keys haben Format "rowIndex-colIndex" wobei rowIndex 1 = erste Datenzeile
            // (rowIndex 0 = Header)
            // Daten-Index 0 entspricht Style-Index 1
            
            // OPTIMIERUNG: Gruppiere alle Metadaten einmalig nach Zeile (O(n) statt O(n¬≤))
            // WICHTIG: Tiefe Kopien erstellen um Referenzprobleme zu vermeiden!
            const stylesByRow = {};
            const richTextByRow = {};
            const formulasByRow = {};
            const hyperlinksByRow = {};
            
            for (const [key, value] of Object.entries(explorerState.cellStyles || {})) {
                const [keyRow, keyCol] = key.split('-');
                const rowIdx = parseInt(keyRow);
                if (rowIdx > 0) { // Nur Datenzeilen, nicht Header
                    if (!stylesByRow[rowIdx]) stylesByRow[rowIdx] = {};
                    // Direkte Referenz - wir verschieben nur, keine Modifikation
                    stylesByRow[rowIdx][keyCol] = value;
                }
            }
            
            for (const [key, value] of Object.entries(explorerState.richTextCells || {})) {
                const [keyRow, keyCol] = key.split('-');
                const rowIdx = parseInt(keyRow);
                if (rowIdx > 0) {
                    if (!richTextByRow[rowIdx]) richTextByRow[rowIdx] = {};
                    // Direkte Referenz - wir verschieben nur, keine Modifikation
                    richTextByRow[rowIdx][keyCol] = value;
                }
            }
            
            for (const [key, value] of Object.entries(explorerState.cellFormulas || {})) {
                const [keyRow, keyCol] = key.split('-');
                const rowIdx = parseInt(keyRow);
                if (rowIdx > 0) {
                    if (!formulasByRow[rowIdx]) formulasByRow[rowIdx] = {};
                    // Formeln sind Strings, brauchen keine tiefe Kopie
                    formulasByRow[rowIdx][keyCol] = value;
                }
            }
            
            for (const [key, value] of Object.entries(explorerState.cellHyperlinks || {})) {
                const [keyRow, keyCol] = key.split('-');
                const rowIdx = parseInt(keyRow);
                if (rowIdx > 0) {
                    if (!hyperlinksByRow[rowIdx]) hyperlinksByRow[rowIdx] = {};
                    // Hyperlinks sind Strings, brauchen keine tiefe Kopie
                    hyperlinksByRow[rowIdx][keyCol] = value;
                }
            }
            
            // Sammle Zeilen-Bundles mit allen Metadaten (jetzt O(n))
            // EFFIZIENT: Direkte Referenzen, keine Kopien n√∂tig da wir nur verschieben
            const totalRows = explorerState.data.length;
            const rowBundles = [];
            
            // Aktuelles rowMapping holen (oder initialisieren)
            const currentMapping = explorerState.rowMapping || explorerState.data.map((_, i) => i);
            
            for (let i = 0; i < totalRows; i++) {
                const styleRowIdx = i + 1; // Style-Key verwendet +1 (Header ist 0)
                const bundle = {
                    dataRef: explorerState.data[i],       // Direkte Referenz
                    originalRef: explorerState.originalData[i], // Direkte Referenz
                    originalExcelRow: currentMapping[i],  // Original Excel-Zeilen-Index (0-basiert in Daten)
                    styles: stylesByRow[styleRowIdx] || {},
                    richText: richTextByRow[styleRowIdx] || {},
                    formulas: formulasByRow[styleRowIdx] || {},
                    hyperlinks: hyperlinksByRow[styleRowIdx] || {},
                    isHidden: explorerState.hiddenRows?.has(i) || false
                };
                
                rowBundles.push(bundle);
            }
            
            // Extrahiere die zu verschiebenden Bundles
            const bundlesToMove = selectedIndices.map(idx => rowBundles[idx]);
            
            // Entferne sie aus der Liste (von hinten nach vorne)
            const sortedDescending = [...selectedIndices].sort((a, b) => b - a);
            sortedDescending.forEach(idx => {
                rowBundles.splice(idx, 1);
            });
            
            // Berechne den neuen Zielindex
            let newTargetIndex = targetIndex;
            selectedIndices.forEach(idx => {
                if (idx < targetIndex) {
                    newTargetIndex--;
                }
            });
            
            if (movePosition === 'after') {
                newTargetIndex++;
            }
            
            // F√ºge die Bundles an der neuen Position ein
            bundlesToMove.forEach((bundle, i) => {
                rowBundles.splice(newTargetIndex + i, 0, bundle);
            });
            
            // Rekonstruiere alle States aus den Bundles
            explorerState.data = [];
            explorerState.originalData = [];
            explorerState.cellStyles = {};
            explorerState.richTextCells = {};
            explorerState.cellFormulas = {};
            explorerState.cellHyperlinks = {};
            explorerState.hiddenRows = new Set();
            
            // Header-Styles behalten (Key "0-x")
            for (const [key, value] of Object.entries(previousCellStyles)) {
                const [keyRow] = key.split('-');
                if (parseInt(keyRow) === 0) {
                    explorerState.cellStyles[key] = value;
                }
            }
            
            rowBundles.forEach((bundle, newRowIdx) => {
                const newStyleRowIdx = newRowIdx + 1;
                
                explorerState.data.push(bundle.dataRef);  // Direkte Referenz
                explorerState.originalData.push(bundle.originalRef);  // Direkte Referenz
                
                if (bundle.isHidden) {
                    explorerState.hiddenRows.add(newRowIdx);
                }
                
                // Styles mit neuem Key
                for (const [col, style] of Object.entries(bundle.styles)) {
                    explorerState.cellStyles[`${newStyleRowIdx}-${col}`] = style;
                }
                
                // RichText mit neuem Key
                for (const [col, rt] of Object.entries(bundle.richText)) {
                    explorerState.richTextCells[`${newStyleRowIdx}-${col}`] = rt;
                }
                
                // Formeln mit neuem Key
                for (const [col, formula] of Object.entries(bundle.formulas)) {
                    explorerState.cellFormulas[`${newStyleRowIdx}-${col}`] = formula;
                }
                
                // Hyperlinks mit neuem Key
                for (const [col, link] of Object.entries(bundle.hyperlinks)) {
                    explorerState.cellHyperlinks[`${newStyleRowIdx}-${col}`] = link;
                }
            });
            
            // WICHTIG: rowMapping aktualisieren - trackt welche Original-Excel-Zeile an welcher neuen Position ist
            explorerState.rowMapping = rowBundles.map(bundle => bundle.originalExcelRow);
            
            // Speichere Undo-Aktion (keine tiefen Kopien mehr - Undo wird vereinfacht)
            pushExplorerUndo({
                type: 'moveRows',
                previousDataOrder: previousDataOrder,  // Nur die Reihenfolge speichern
                previousCellStyles: previousCellStyles,
                previousRichTextCells: previousRichTextCells,
                movedIndices: selectedIndices,
                targetRow: targetRow,
                movePosition: movePosition
            });
            
            // Auswahl zur√ºcksetzen
            explorerState.selectedRows.clear();
            
            // Tracke alle betroffenen Zeilen (alt und neu) f√ºr Style-Reset beim Speichern
            // WICHTIG: affectedRows verwendet STYLE-Indizes (rowIndex + 1 weil Header = 0)
            if (!explorerState.affectedRows) {
                explorerState.affectedRows = new Set();
            }
            // Alle Zeilen zwischen min und max der Bewegung sind betroffen (Style-Indizes!)
            const minDataIdx = Math.min(...selectedIndices, newTargetIndex);
            const maxDataIdx = Math.max(...selectedIndices, newTargetIndex + bundlesToMove.length - 1);
            for (let i = minDataIdx; i <= maxDataIdx; i++) {
                explorerState.affectedRows.add(i + 1); // +1 f√ºr Style-Index
            }
            
            // FilteredData neu erstellen
            explorerState.filteredData = explorerState.data.map((row, idx) => ({
                row: row,
                originalIndex: idx
            }));
            
            // Suchfilter erneut anwenden wenn aktiv
            const searchTerm = elements.explorerSearch?.value?.trim().toLowerCase();
            if (searchTerm) {
                explorerState.filteredData = explorerState.filteredData.filter(item => 
                    item.row.some(cell => String(cell ?? '').toLowerCase().includes(searchTerm))
                );
            }
            
            // Markierung, dass Zeilen neu angeordnet wurden (strukturelle √Ñnderung)
            explorerState.editedCells.set('_rowsReordered', true);
            
            // Markiere als ge√§ndert
            explorerState.hasUnsavedChanges = true;
            
            // Tabelle neu rendern
            renderExplorerTable();
            
            showNotification(`${selectedCount} Zeile(n) ${movePosition === 'before' ? 'vor' : 'nach'} Zeile ${targetRow} verschoben`, 'success');
            
            // Eingabefeld leeren
            targetRowInput.value = '';
        }
        
        // L√∂scht mehrere ausgew√§hlte Zeilen
        async function deleteSelectedRows() {
            const selectedCount = explorerState.selectedRows.size;
            if (selectedCount === 0) {
                showNotification('Keine Zeilen ausgew√§hlt', 'warning');
                return;
            }
            
            // Best√§tigung anfordern
            const deleteLabel = currentLanguage === 'en' ? 'Delete' : 'L√∂schen';
            const cancelLabel = currentLanguage === 'en' ? 'Cancel' : 'Abbrechen';
            const titleText = currentLanguage === 'en' 
                ? `Delete ${selectedCount} Row(s)?` 
                : `${selectedCount} Zeile(n) l√∂schen?`;
            const confirmText = currentLanguage === 'en'
                ? `Do you really want to delete the ${selectedCount} selected row(s)?\n\nThis action cannot be undone.`
                : `M√∂chten Sie die ${selectedCount} ausgew√§hlten Zeile(n) wirklich l√∂schen?\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden.`;
            
            const confirmed = await showConfirmDialog(
                titleText,
                confirmText,
                deleteLabel,
                cancelLabel
            );
            
            if (!confirmed) return;
            
            // Speichere den aktuellen Zustand f√ºr Undo
            const previousData = JSON.parse(JSON.stringify(explorerState.data));
            const previousOriginalData = JSON.parse(JSON.stringify(explorerState.originalData));
            const previousHighlights = new Map(explorerState.rowHighlights);
            const previousEditedCells = new Map(explorerState.editedCells);
            
            // Sortiere die ausgew√§hlten Indizes absteigend (wichtig f√ºr korrektes L√∂schen)
            const selectedIndices = Array.from(explorerState.selectedRows).sort((a, b) => b - a);
            
            // L√∂sche die Zeilen von hinten nach vorne
            selectedIndices.forEach(idx => {
                explorerState.data.splice(idx, 1);
                explorerState.originalData.splice(idx, 1);
            });
            
            // Highlights anpassen
            const deletedSet = new Set(selectedIndices);
            const newHighlights = new Map();
            explorerState.rowHighlights.forEach((color, idx) => {
                if (deletedSet.has(idx)) return; // Gel√∂schte Zeile √ºberspringen
                // Berechne wie viele gel√∂schte Zeilen vor dieser lagen
                let offset = 0;
                selectedIndices.forEach(delIdx => {
                    if (delIdx < idx) offset++;
                });
                newHighlights.set(idx - offset, color);
            });
            explorerState.rowHighlights = newHighlights;
            
            // cellStyles anpassen (Key ist "styleRowIdx-colIdx" wobei styleRowIdx = dataRowIdx + 1)
            const newCellStyles = {};
            for (const [key, value] of Object.entries(explorerState.cellStyles || {})) {
                const [rowStr, colStr] = key.split('-');
                const styleRow = parseInt(rowStr);
                const col = parseInt(colStr);
                if (styleRow === 0) {
                    // Header behalten
                    newCellStyles[key] = value;
                    continue;
                }
                const dataRow = styleRow - 1; // styleRow = dataRow + 1
                if (deletedSet.has(dataRow)) continue; // Gel√∂schte Zeile √ºberspringen
                let offset = 0;
                selectedIndices.forEach(delIdx => {
                    if (delIdx < dataRow) offset++;
                });
                newCellStyles[`${styleRow - offset}-${col}`] = value;
            }
            explorerState.cellStyles = newCellStyles;
            
            // cellHyperlinks anpassen
            const newCellHyperlinks = {};
            for (const [key, value] of Object.entries(explorerState.cellHyperlinks || {})) {
                const [rowStr, colStr] = key.split('-');
                const styleRow = parseInt(rowStr);
                const col = parseInt(colStr);
                if (styleRow === 0) {
                    newCellHyperlinks[key] = value;
                    continue;
                }
                const dataRow = styleRow - 1;
                if (deletedSet.has(dataRow)) continue;
                let offset = 0;
                selectedIndices.forEach(delIdx => {
                    if (delIdx < dataRow) offset++;
                });
                newCellHyperlinks[`${styleRow - offset}-${col}`] = value;
            }
            explorerState.cellHyperlinks = newCellHyperlinks;
            
            // richTextCells anpassen
            const newRichTextCells = {};
            for (const [key, value] of Object.entries(explorerState.richTextCells || {})) {
                const [rowStr, colStr] = key.split('-');
                const styleRow = parseInt(rowStr);
                const col = parseInt(colStr);
                if (styleRow === 0) {
                    newRichTextCells[key] = value;
                    continue;
                }
                const dataRow = styleRow - 1;
                if (deletedSet.has(dataRow)) continue;
                let offset = 0;
                selectedIndices.forEach(delIdx => {
                    if (delIdx < dataRow) offset++;
                });
                newRichTextCells[`${styleRow - offset}-${col}`] = value;
            }
            explorerState.richTextCells = newRichTextCells;
            
            // cellFormulas anpassen
            const newCellFormulas = {};
            for (const [key, value] of Object.entries(explorerState.cellFormulas || {})) {
                const [rowStr, colStr] = key.split('-');
                const styleRow = parseInt(rowStr);
                const col = parseInt(colStr);
                if (styleRow === 0) {
                    newCellFormulas[key] = value;
                    continue;
                }
                const dataRow = styleRow - 1;
                if (deletedSet.has(dataRow)) continue;
                let offset = 0;
                selectedIndices.forEach(delIdx => {
                    if (delIdx < dataRow) offset++;
                });
                newCellFormulas[`${styleRow - offset}-${col}`] = value;
            }
            explorerState.cellFormulas = newCellFormulas;
            
            // EditedCells anpassen
            const newEditedCells = new Map();
            explorerState.editedCells.forEach((value, key) => {
                if (key.startsWith('_')) {
                    newEditedCells.set(key, value);
                    return;
                }
                const [rowStr, colStr] = key.split('-');
                const row = parseInt(rowStr);
                const col = parseInt(colStr);
                if (deletedSet.has(row)) return; // Gel√∂schte Zeile √ºberspringen
                // Berechne wie viele gel√∂schte Zeilen vor dieser lagen
                let offset = 0;
                selectedIndices.forEach(delIdx => {
                    if (delIdx < row) offset++;
                });
                newEditedCells.set(`${row - offset}-${col}`, value);
            });
            explorerState.editedCells = newEditedCells;
            
            // Markierung, dass etwas gel√∂scht wurde
            explorerState.editedCells.set('_rowDeleted', true);
            
            // WICHTIG: rowMapping aktualisieren nach L√∂schen
            // Das Mapping zeigt welche Original-Excel-Zeile an welcher neuen Position ist
            // Nach dem L√∂schen m√ºssen die gel√∂schten Zeilen aus dem Mapping entfernt werden
            if (explorerState.rowMapping && explorerState.rowMapping.length > 0) {
                // Aktualisiere bestehendes Mapping
                const newRowMapping = [];
                for (let i = 0; i < explorerState.data.length; i++) {
                    // Finde die Original-Position f√ºr diese Datenzeile
                    // selectedIndices sind die gel√∂schten Indizes (absteigend sortiert)
                    // Wir m√ºssen den urspr√ºnglichen Index vor dem L√∂schen berechnen
                    let originalIdx = i;
                    // Z√§hle wie viele gel√∂schte Zeilen vor dieser Position waren
                    selectedIndices.slice().reverse().forEach(delIdx => {
                        if (delIdx <= originalIdx) originalIdx++;
                    });
                    if (originalIdx < explorerState.rowMapping.length) {
                        newRowMapping.push(explorerState.rowMapping[originalIdx]);
                    }
                }
                explorerState.rowMapping = newRowMapping;
            } else {
                // Erstelle neues Mapping: neue Position -> Original Excel-Zeile
                // Nach dem L√∂schen sind die verbleibenden Zeilen an neuen Positionen
                explorerState.rowMapping = [];
                for (let i = 0; i < explorerState.data.length; i++) {
                    // Berechne welche Original-Position (vor dem L√∂schen) diese Zeile hatte
                    let originalIdx = i;
                    // selectedIndices ist absteigend sortiert, wir brauchen aufsteigend
                    const sortedDeleted = selectedIndices.slice().sort((a, b) => a - b);
                    sortedDeleted.forEach(delIdx => {
                        if (delIdx <= originalIdx) originalIdx++;
                    });
                    explorerState.rowMapping.push(originalIdx);
                }
            }
            
            // WICHTIG: mergedCells in der GUI aktualisieren
            // Die mergedCells haben 0-basierte Zeilen-Indizes (Datenzeilen, nicht Excel-Zeilen)
            if (explorerState.mergedCells && explorerState.mergedCells.length > 0) {
                const sortedDeleted = selectedIndices.slice().sort((a, b) => a - b);
                const newMergedCells = [];
                
                for (const merge of explorerState.mergedCells) {
                    // mergedCells sind 0-basiert (startRow=0 ist Header, startRow=1 ist erste Datenzeile)
                    // Pr√ºfe ob die Merged Cell komplett oder teilweise gel√∂scht wird
                    let affectedRows = 0;
                    let allRowsDeleted = true;
                    
                    for (let row = merge.startRow; row <= merge.endRow; row++) {
                        // Pr√ºfe ob diese Zeile gel√∂scht wurde (row-1 weil mergedCells Header-Zeile einschlie√üt)
                        const dataRowIdx = row - 1; // -1 weil startRow=1 ist Datenzeile 0
                        if (dataRowIdx >= 0 && sortedDeleted.includes(dataRowIdx)) {
                            affectedRows++;
                        } else {
                            allRowsDeleted = false;
                        }
                    }
                    
                    // Wenn alle Zeilen gel√∂scht wurden, Merged Cell entfernen
                    if (allRowsDeleted && merge.startRow > 0) {
                        continue;
                    }
                    
                    // Berechne neue Positionen
                    let newStartRow = merge.startRow;
                    let newEndRow = merge.endRow;
                    
                    // F√ºr jede gel√∂schte Zeile vor der Merged Cell: verschiebe nach oben
                    for (const delIdx of sortedDeleted) {
                        const delRow = delIdx + 1; // +1 weil delIdx 0-basiert f√ºr Daten, mergedCells 1-basiert f√ºr Daten
                        if (delRow < merge.startRow) {
                            newStartRow--;
                            newEndRow--;
                        } else if (delRow >= merge.startRow && delRow <= merge.endRow) {
                            // Zeile innerhalb der Merged Cell gel√∂scht
                            newEndRow--;
                        }
                    }
                    
                    // Nur hinzuf√ºgen wenn die Merged Cell noch g√ºltig ist
                    if (newStartRow <= newEndRow && newEndRow >= 0) {
                        newMergedCells.push({
                            ...merge,
                            startRow: newStartRow,
                            endRow: newEndRow,
                            rowSpan: newEndRow - newStartRow + 1
                        });
                    }
                }
                
                explorerState.mergedCells = newMergedCells;
            }
            
            // Speichere Undo-Aktion
            pushExplorerUndo({
                type: 'deleteRows',
                previousData: previousData,
                previousOriginalData: previousOriginalData,
                previousHighlights: previousHighlights,
                previousEditedCells: previousEditedCells,
                deletedIndices: selectedIndices
            });
            
            // Auswahl zur√ºcksetzen
            explorerState.selectedRows.clear();
            
            // FilteredData neu erstellen
            explorerState.filteredData = explorerState.data.map((row, idx) => ({
                row: row,
                originalIndex: idx
            }));
            
            // Suchfilter erneut anwenden wenn aktiv
            const searchTerm = elements.explorerSearch?.value?.trim().toLowerCase();
            if (searchTerm) {
                explorerState.filteredData = explorerState.filteredData.filter(item => 
                    item.row.some(cell => String(cell ?? '').toLowerCase().includes(searchTerm))
                );
            }
            
            // Markiere als ge√§ndert
            explorerState.hasUnsavedChanges = true;
            
            // Tabelle neu rendern
            renderExplorerTable();
            
            const successMsg = currentLanguage === 'en'
                ? `${selectedCount} row(s) deleted`
                : `${selectedCount} Zeile(n) gel√∂scht`;
            showNotification(successMsg, 'success');
        }
        
        // Blendet mehrere ausgew√§hlte Zeilen aus
        function hideSelectedRows() {
            const selectedCount = explorerState.selectedRows.size;
            if (selectedCount === 0) {
                showNotification(currentLanguage === 'en' ? 'No rows selected' : 'Keine Zeilen ausgew√§hlt', 'warning');
                return;
            }
            
            // F√ºge alle ausgew√§hlten Zeilen zu den ausgeblendeten Zeilen hinzu
            // selectedRows enth√§lt originalIndex-Werte (0-basiert)
            // hiddenRows enth√§lt ebenfalls originalIndex-Werte (0-basiert)
            explorerState.selectedRows.forEach(originalIndex => {
                explorerState.hiddenRows.add(originalIndex);
            });
            
            // Markierung, dass Zeilen-Sichtbarkeit ge√§ndert wurde
            explorerState.editedCells.set('_rowVisibilityChanged', true);
            
            // Auswahl zur√ºcksetzen
            explorerState.selectedRows.clear();
            
            // Markiere als ge√§ndert
            explorerState.hasUnsavedChanges = true;
            
            // Gefilterte Daten und UI aktualisieren
            filterExplorerData();
            updateHiddenRowsIndicator();
            updateExplorerEditStatus();
            updateRowMoveToolbar();
            
            const successMsg = currentLanguage === 'en'
                ? `${selectedCount} row(s) hidden`
                : `${selectedCount} Zeile(n) ausgeblendet`;
            showNotification(successMsg, 'success');
        }
        
        // L√∂scht die Zeilenauswahl
        function clearRowSelection() {
            explorerState.selectedRows.clear();
            updateRowSelectionUI();
            updateRowMoveToolbar();
            
            // Select-All Checkbox zur√ºcksetzen
            const selectAllCheckbox = document.getElementById('selectAllRows');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
            }
        }

        function updateExplorerEditStatus() {
            const editedCount = explorerState.editedCells.size;
            const resultCount = elements.explorerResultCount.textContent;
            // Aktualisiere die Anzeige wenn sich die Anzahl ge√§nderter Zellen √§ndert
            if (editedCount > 0) {
                elements.explorerStatus.textContent = `${editedCount} Zelle(n) bearbeitet`;
                elements.explorerStatus.style.color = 'var(--warning-color)';
            } else {
                elements.explorerStatus.textContent = '';
            }
        }
        
        function updateExplorerPagination(totalPages) {
            const paginationEl = document.getElementById('explorerPagination');
            const pageInfoEl = document.getElementById('explorerPageInfo');
            const firstBtn = document.getElementById('btnExplorerFirstPage');
            const prevBtn = document.getElementById('btnExplorerPrevPage');
            const nextBtn = document.getElementById('btnExplorerNextPage');
            const lastBtn = document.getElementById('btnExplorerLastPage');
            
            // Pagination nur anzeigen wenn mehr als eine Seite
            if (explorerState.filteredData.length > explorerState.pageSize) {
                paginationEl.style.display = 'flex';
                pageInfoEl.textContent = `Seite ${explorerState.currentPage} von ${totalPages}`;
                
                // Buttons aktivieren/deaktivieren
                firstBtn.disabled = explorerState.currentPage === 1;
                prevBtn.disabled = explorerState.currentPage === 1;
                nextBtn.disabled = explorerState.currentPage === totalPages;
                lastBtn.disabled = explorerState.currentPage === totalPages;
            } else {
                paginationEl.style.display = 'none';
            }
        }
        
        function explorerGoToPage(page) {
            const totalPages = Math.ceil(explorerState.filteredData.length / explorerState.pageSize);
            explorerState.currentPage = Math.max(1, Math.min(page, totalPages));
            renderExplorerTable();
            
            // Zum Tabellenanfang scrollen
            document.getElementById('explorerTableContainer').scrollTop = 0;
        }
        
        function explorerChangePageSize(newSize) {
            explorerState.pageSize = parseInt(newSize);
            explorerState.currentPage = 1; // Zur√ºck zur ersten Seite
            renderExplorerTable();
        }
        
        function toggleColumnPanel() {
            const panel = document.getElementById('columnTogglePanel');
            panel.style.display = panel.style.display === 'none' ? 'flex' : 'none';
        }
        
        function updateColumnToggles() {
            const container = document.getElementById('columnToggles');
            container.innerHTML = explorerState.headers.map((header, i) => `
                <div class="column-toggle ${explorerState.visibleColumns.includes(i) ? '' : 'hidden-col'}">
                    <input type="checkbox" id="colToggle_${i}" ${explorerState.visibleColumns.includes(i) ? 'checked' : ''} 
                           onchange="toggleExplorerColumn(${i}, this.checked)">
                    <label for="colToggle_${i}">${escapeHtml(header || `Spalte ${i + 1}`)}</label>
                </div>
            `).join('');
        }
        
        window.toggleExplorerColumn = function(colIndex, visible) {
            if (visible) {
                if (!explorerState.visibleColumns.includes(colIndex)) {
                    explorerState.visibleColumns.push(colIndex);
                    explorerState.visibleColumns.sort((a, b) => a - b);
                }
            } else {
                explorerState.visibleColumns = explorerState.visibleColumns.filter(i => i !== colIndex);
            }
            // Markierung, dass Spalten-Sichtbarkeit ge√§ndert wurde
            explorerState.editedCells.set('_columnVisibilityChanged', true);
            renderExplorerTable();
            updateColumnToggles();
            updateHiddenColumnsIndicator();
            updateExplorerEditStatus();
            showFloatingStatus(visible ? (currentLanguage === 'en' ? 'Column shown' : 'Spalte eingeblendet') : (currentLanguage === 'en' ? 'Column hidden' : 'Spalte ausgeblendet'));
        };
        
        function showAllExplorerColumns() {
            explorerState.visibleColumns = explorerState.headers.map((_, i) => i);
            // Markierung, dass Spalten-Sichtbarkeit ge√§ndert wurde
            explorerState.editedCells.set('_columnVisibilityChanged', true);
            renderExplorerTable();
            updateColumnToggles();
            updateHiddenColumnsIndicator();
            updateExplorerEditStatus();
            showFloatingStatus(currentLanguage === 'en' ? 'All columns shown' : 'Alle Spalten eingeblendet');
        }
        
        function hideAllExplorerColumns() {
            explorerState.visibleColumns = [];
            // Markierung, dass Spalten-Sichtbarkeit ge√§ndert wurde
            explorerState.editedCells.set('_columnVisibilityChanged', true);
            renderExplorerTable();
            updateColumnToggles();
            updateHiddenColumnsIndicator();
            updateExplorerEditStatus();
        }
        
        function addExplorerFilter() {
            const template = document.getElementById('explorerFilterTemplate');
            const clone = template.content.cloneNode(true);
            const row = clone.querySelector('.explorer-filter-row');
            
            // Spalten-Dropdown bef√ºllen
            const colSelect = row.querySelector('.filter-column');
            colSelect.innerHTML = `<option value="">${t('selectColumn')}</option>` + 
                explorerState.headers.map((h, i) => `<option value="${i}">${escapeHtml(h || `Spalte ${i + 1}`)}</option>`).join('');
            
            const operatorSelect = row.querySelector('.filter-operator');
            const valueInput = row.querySelector('.filter-value');
            const daysInput = row.querySelector('.filter-days');
            
            // Operator-√Ñnderung: Tage-Feld anzeigen/ausblenden
            operatorSelect.onchange = () => {
                const op = operatorSelect.value;
                const needsDays = op === 'dateInDays' || op === 'dateOverdueDays';
                const needsNoValue = ['dateToday', 'datePast', 'dateFuture', 'dateThisWeek', 'dateThisMonth', 'isEmpty', 'isNotEmpty'].includes(op);
                
                daysInput.style.display = needsDays ? 'block' : 'none';
                valueInput.style.display = needsNoValue ? 'none' : (needsDays ? 'none' : 'block');
                
                if (needsNoValue) {
                    valueInput.value = '_no_value_required_';
                } else if (needsDays) {
                    valueInput.value = '';
                }
                
                updateFiltersFromDOM();
            };
            
            // Event-Listener
            row.querySelector('.remove-filter').onclick = () => {
                row.remove();
                updateFiltersFromDOM();
            };
            row.querySelector('.filter-column').onchange = updateFiltersFromDOM;
            daysInput.oninput = updateFiltersFromDOM;
            row.querySelector('.filter-value').oninput = updateFiltersFromDOM;
            
            document.getElementById('explorerFilters').appendChild(row);
            document.getElementById('btnClearExplorerFilters').disabled = false;
        }
        
        function updateFiltersFromDOM() {
            const rows = document.querySelectorAll('.explorer-filter-row');
            explorerState.filters = Array.from(rows).map(row => {
                const operator = row.querySelector('.filter-operator').value;
                const needsDays = operator === 'dateInDays' || operator === 'dateOverdueDays';
                const needsNoValue = ['dateToday', 'datePast', 'dateFuture', 'dateThisWeek', 'dateThisMonth', 'isEmpty', 'isNotEmpty'].includes(operator);
                
                let value = row.querySelector('.filter-value').value;
                const days = row.querySelector('.filter-days').value;
                
                // F√ºr Datums-Filter mit Tagen: days als value verwenden
                if (needsDays) {
                    value = days || '0';
                } else if (needsNoValue) {
                    value = '_no_value_required_';
                }
                
                return {
                    column: row.querySelector('.filter-column').value,
                    operator: operator,
                    value: value,
                    days: days
                };
            }).filter(f => f.column && (f.value || f.days));
            filterExplorerData();
        }
        
        function clearExplorerFilters() {
            document.getElementById('explorerFilters').innerHTML = '';
            explorerState.filters = [];
            document.getElementById('btnClearExplorerFilters').disabled = true;
            filterExplorerData();
        }
        
        async function exportExplorerData() {
            if (!explorerState.filePath) {
                elements.explorerStatus.textContent = 'Keine Datei geladen';
                return;
            }
            
            // Aktuelles Sheet im Cache speichern
            saveCurrentSheetToCache();
            
            // Sheet-Auswahl-Dialog anzeigen (inkl. Passwort-Option)
            const dialogResult = await showSheetSelectionDialog('export');
            if (!dialogResult || !dialogResult.sheets || dialogResult.sheets.length === 0) return;
            
            const selectedSheets = dialogResult.sheets;
            const exportPassword = dialogResult.password;
            
            // Dateiname ohne doppelte .xlsx Endung
            let baseName = explorerState.fileName || 'Daten';
            baseName = baseName.replace(/\.xlsx$/i, '');
            
            const savePath = await window.electronAPI.saveFileDialog({
                title: 'Export speichern',
                defaultPath: getWorkingDirectoryPath() ? (getWorkingDirectoryPath() + `/Export_${baseName}.xlsx`) : `Export_${baseName}.xlsx`,
                filters: [{ name: 'Excel', extensions: ['xlsx'] }]
            });
            
            if (savePath) {
                elements.explorerStatus.textContent = exportPassword ? 'Exportiere mit Passwortschutz...' : 'Exportiere...';
                
                // SPEICHEROPTIMIERUNG: Undo-Stack leeren vor dem Export
                if (undoRedoState.explorerUndoStack.length > 0) {
                    undoRedoState.explorerUndoStack = [];
                    undoRedoState.explorerRedoStack = [];
                    console.log('[Memory] Undo/Redo Stack geleert f√ºr Export');
                }
                
                // Sammle Daten f√ºr alle ausgew√§hlten Sheets
                const sheetsToExport = [];
                
                for (const sheetName of selectedSheets) {
                    let sheetData;
                    
                    // Pr√ºfe ob Sheet √Ñnderungen hat
                    const isCurrentSheet = sheetName === explorerState.selectedSheet;
                    const cachedSheet = explorerState.sheetDataCache.get(sheetName);
                    
                    // Pr√ºfe ob Filter aktiv sind (Zeilen werden ausgefiltert)
                    const hasActiveFilters = isCurrentSheet && explorerState.filters && explorerState.filters.length > 0;
                    const hasSearchFilter = isCurrentSheet && explorerState.searchTerm && explorerState.searchTerm.trim() !== '';
                    const rowsFiltered = isCurrentSheet && explorerState.filteredData.length < explorerState.data.length;
                    const isFiltered = (hasActiveFilters || hasSearchFilter) && rowsFiltered;
                    
                    // √Ñnderungen = editedCells ODER aktive Filter (gefilterte Daten exportieren)
                    const hasChanges = isCurrentSheet 
                        ? (explorerState.editedCells.size > 0 || isFiltered)
                        : (cachedSheet?.editedCells?.size > 0);
                    
                    if (isFiltered) {
                        console.log(`[Export] Filter aktiv f√ºr Sheet "${sheetName}": ${explorerState.filteredData.length} von ${explorerState.data.length} Zeilen werden exportiert`);
                    }
                    
                    if (!hasChanges) {
                        // Keine √Ñnderungen - Backend soll direkt aus Datei lesen (spart Speicher!)
                        // OPTIMIERUNG: Bei gro√üen Dateien (>50k Styles) keine Styles senden
                        // ExcelJS liest die meisten Fills korrekt aus der Datei
                        const stylesForSheet = isCurrentSheet 
                            ? explorerState.cellStyles 
                            : (cachedSheet?.cellStyles || {});
                        
                        // Bei gro√üen Dateien keine Styles senden - ExcelJS hat sie bereits
                        const styleCount = Object.keys(stylesForSheet || {}).length;
                        const finalStyles = styleCount > 50000 ? {} : stylesForSheet;
                        if (styleCount > 50000) {
                            console.log(`[Export] Sheet "${sheetName}": ${styleCount} Styles √ºbersprungen (Performance)`);
                        }
                        
                        // AutoFilter f√ºr dieses Sheet ermitteln
                        const autoFilterForSheet = isCurrentSheet 
                            ? explorerState.autoFilterRange 
                            : (cachedSheet?.autoFilterRange || null);
                        
                        // Versteckte Spalten berechnen
                        const visibleColsForSheet = isCurrentSheet 
                            ? explorerState.visibleColumns 
                            : (cachedSheet?.visibleColumns || []);
                        const headersForSheet = isCurrentSheet 
                            ? explorerState.headers 
                            : (cachedSheet?.headers || []);
                        const allCols = headersForSheet.map((_, i) => i);
                        const visibleSet = new Set(visibleColsForSheet || allCols);
                        const hiddenColsForSheet = allCols.filter(i => !visibleSet.has(i));
                        
                        sheetData = {
                            sheetName: sheetName,
                            fromFile: true,
                            cellStyles: finalStyles,
                            hiddenColumns: hiddenColsForSheet,
                            autoFilterRange: autoFilterForSheet
                        };
                        console.log(`[Export] fromFile Sheet "${sheetName}": ${hiddenColsForSheet.length} versteckte Spalten, AutoFilter: ${autoFilterForSheet || 'none'}`);
                    } else if (isCurrentSheet) {
                        // Aktuelles Sheet mit √Ñnderungen
                        const affectedRowsArray = explorerState.affectedRows ? Array.from(explorerState.affectedRows) : [];
                        const hasRowMoves = affectedRowsArray.length > 0;
                        
                        // Pr√ºfe ob Filter aktiv sind (Zeilen werden ausgefiltert)
                        const hasActiveFilters = explorerState.filters && explorerState.filters.length > 0;
                        const hasSearchFilter = explorerState.searchTerm && explorerState.searchTerm.trim() !== '';
                        const rowsFiltered = explorerState.filteredData.length < explorerState.data.length;
                        const isFiltered = (hasActiveFilters || hasSearchFilter) && rowsFiltered;
                        
                        // Strukturelle √Ñnderungen erkennen (Spalte/Zeile gel√∂scht/eingef√ºgt/verschoben, Filter aktiv)
                        // HINWEIS: _rowVisibilityChanged ist KEINE strukturelle √Ñnderung!
                        // Versteckte Zeilen bleiben im Excel, nur das hidden-Flag wird gesetzt.
                        // Die Styles bleiben dadurch an Ort und Stelle.
                        const hasStructuralChanges = hasRowMoves || 
                            explorerState.editedCells.has('_columnDeleted') || 
                            explorerState.editedCells.has('_columnInserted') ||
                            explorerState.editedCells.has('_columnMoved') ||
                            explorerState.editedCells.has('_rowsReordered') ||
                            explorerState.editedCells.has('_rowInserted') ||  // Zeile eingef√ºgt
                            explorerState.editedCells.has('_rowDeleted') ||   // Zeile gel√∂scht
                            explorerState.editedCells.has('_rowHighlightChanged') ||   // Zeilenfarben ge√§ndert
                            isFiltered;  // Filter = strukturelle √Ñnderung (nur gefilterte Zeilen exportieren)
                        
                        // HiddenRows aus dem aktuellen State ermitteln
                        // Bei strukturellen √Ñnderungen: Index in filteredData (da Zeilen umgeordnet werden)
                        // Bei Zell-Edits (ohne Filter): originalIndex (da Zeilen an Ort und Stelle bleiben)
                        let currentHiddenRows = [];
                        if (hasStructuralChanges) {
                            // Bei strukturellen √Ñnderungen: Index relativ zu filteredData
                            explorerState.filteredData.forEach((item, idx) => {
                                if (explorerState.hiddenRows && explorerState.hiddenRows.has(item.originalIndex)) {
                                    currentHiddenRows.push(idx);
                                }
                            });
                        } else {
                            // Bei Zell-Edits: Direkt die originalIndex-Werte verwenden
                            currentHiddenRows = Array.from(explorerState.hiddenRows || []);
                        }
                        
                        // Versteckte Spalten berechnen
                        const allCols = explorerState.headers.map((_, i) => i);
                        const visibleSet = new Set(explorerState.visibleColumns || allCols);
                        const hiddenCols = allCols.filter(i => !visibleSet.has(i));
                        
                        // STRATEGIE: Bei strukturellen √Ñnderungen FULL REWRITE
                        if (hasStructuralChanges) {
                            // Strukturelle √Ñnderung: FULL REWRITE
                            let allData = explorerState.filteredData.map(item => item.row);
                            
                            let exportHeaders = [...explorerState.headers];
                            // WICHTIG: cellStyles werden NICHT mitgesendet!
                            // xlwings √ºbernimmt Styles automatisch aus der Datei.
                            // Das spart erheblich Daten (z.B. 146.000 Styles bei gro√üen Dateien)
                            let exportCellStyles = {};  // Leer - xlwings √ºbernimmt aus Datei
                            let exportCellFormulas = { ...(explorerState.cellFormulas || {}) };
                            let exportCellHyperlinks = { ...(explorerState.cellHyperlinks || {}) };
                            let exportRichTextCells = { ...(explorerState.richTextCells || {}) };
                            let exportVisibleColumns = [...(explorerState.visibleColumns || [])];
                            let exportHiddenCols = [...hiddenCols];
                            
                            // Bei gefilterten Daten: Styles/Formeln/Hyperlinks auf neue Zeilen-Indizes mappen
                            // originalIndex -> neuer Index in filteredData
                            if (isFiltered) {
                                console.log(`[Export] Filter aktiv: Mappe ${explorerState.filteredData.length} von ${explorerState.data.length} Zeilen`);
                                
                                // Erstelle Mapping: originalIndex -> newIndex (0-basiert in exportierten Daten)
                                const rowIndexMap = new Map();
                                explorerState.filteredData.forEach((item, newIdx) => {
                                    rowIndexMap.set(item.originalIndex, newIdx);
                                });
                                
                                // Styles remappen
                                const remappedStyles = {};
                                for (const [key, style] of Object.entries(exportCellStyles)) {
                                    const [rowStr, colStr] = key.split('-');
                                    const originalRowIdx = parseInt(rowStr);
                                    const colIdx = parseInt(colStr);
                                    const newRowIdx = rowIndexMap.get(originalRowIdx);
                                    if (newRowIdx !== undefined) {
                                        remappedStyles[`${newRowIdx}-${colIdx}`] = style;
                                    }
                                }
                                exportCellStyles = remappedStyles;
                                
                                // Formeln remappen
                                const remappedFormulas = {};
                                for (const [key, formula] of Object.entries(exportCellFormulas)) {
                                    const [rowStr, colStr] = key.split('-');
                                    const originalRowIdx = parseInt(rowStr);
                                    const colIdx = parseInt(colStr);
                                    const newRowIdx = rowIndexMap.get(originalRowIdx);
                                    if (newRowIdx !== undefined) {
                                        remappedFormulas[`${newRowIdx}-${colIdx}`] = formula;
                                    }
                                }
                                exportCellFormulas = remappedFormulas;
                                
                                // Hyperlinks remappen
                                const remappedHyperlinks = {};
                                for (const [key, link] of Object.entries(exportCellHyperlinks)) {
                                    const [rowStr, colStr] = key.split('-');
                                    const originalRowIdx = parseInt(rowStr);
                                    const colIdx = parseInt(colStr);
                                    const newRowIdx = rowIndexMap.get(originalRowIdx);
                                    if (newRowIdx !== undefined) {
                                        remappedHyperlinks[`${newRowIdx}-${colIdx}`] = link;
                                    }
                                }
                                exportCellHyperlinks = remappedHyperlinks;
                                
                                // RichText remappen
                                const remappedRichText = {};
                                for (const [key, rt] of Object.entries(exportRichTextCells)) {
                                    const [rowStr, colStr] = key.split('-');
                                    const originalRowIdx = parseInt(rowStr);
                                    const colIdx = parseInt(colStr);
                                    const newRowIdx = rowIndexMap.get(originalRowIdx);
                                    if (newRowIdx !== undefined) {
                                        remappedRichText[`${newRowIdx}-${colIdx}`] = rt;
                                    }
                                }
                                exportRichTextCells = remappedRichText;
                            }
                            
                            // Bei Filter: rowMapping erstellen f√ºr physische Zeilen-Umordnung
                            // rowMapping[newPos] = originalPos (0-basiert f√ºr Datenzeilen)
                            // So bleiben die Excel-Styles erhalten!
                            let filterRowMapping = null;
                            if (isFiltered && !hasRowMoves) {
                                filterRowMapping = explorerState.filteredData.map(item => item.originalIndex);
                                
                                // Bei Filter-Mapping: KEINE Frontend-Styles remappen!
                                // Die Excel-Styles werden durch physische Umordnung √ºbernommen
                                exportCellStyles = {};
                                exportCellFormulas = {};
                                exportCellHyperlinks = {};
                                exportRichTextCells = {};
                            }
                            
                            // Bei Row-Move: ExcelJS ordnet die Zeilen direkt um (mit allen Styles)
                            // Kein Frontend-Remapping n√∂tig!
                            if (hasRowMoves && explorerState.rowMapping && explorerState.rowMapping.length > 0) {
                                // rowMapping wird an Writer gesendet
                            }
                            
                            // Hole die Indizes der gel√∂schten Spalten falls vorhanden
                            const columnDeletedInfo = explorerState.editedCells.get('_columnDeleted');
                            
                            // Extrahiere die Original-Indizes - unterst√ºtze neues Format und Legacy-Formate
                            let deletedColumnIndices = [];
                            if (columnDeletedInfo && typeof columnDeletedInfo === 'object') {
                                if ('originalIndices' in columnDeletedInfo && Array.isArray(columnDeletedInfo.originalIndices)) {
                                    // Neues Format mit Original-Indices
                                    deletedColumnIndices = columnDeletedInfo.originalIndices;
                                } else if ('indices' in columnDeletedInfo && Array.isArray(columnDeletedInfo.indices)) {
                                    // Altes Array-Format
                                    deletedColumnIndices = columnDeletedInfo.indices;
                                } else if ('index' in columnDeletedInfo) {
                                    // Legacy single-index Format
                                    deletedColumnIndices = [columnDeletedInfo.index];
                                }
                            } else if (typeof columnDeletedInfo === 'number') {
                                deletedColumnIndices = [columnDeletedInfo];
                            }
                            
                            // Hole Info √ºber eingef√ºgte Spalten falls vorhanden
                            const columnInsertedInfo = explorerState.editedCells.get('_columnInserted');
                            let insertedColumnInfo = null;
                            if (columnInsertedInfo && typeof columnInsertedInfo === 'object') {
                                // Unterst√ºtze neues Format mit 'operations' und alte Formate
                                if (columnInsertedInfo.operations) {
                                    // Neues Format mit operations Array
                                    insertedColumnInfo = {
                                        operations: columnInsertedInfo.operations
                                    };
                                } else if (columnInsertedInfo.position !== undefined) {
                                    // Altes Format mit position
                                    insertedColumnInfo = {
                                        operations: [{
                                            position: columnInsertedInfo.position,
                                            count: columnInsertedInfo.count || 1,
                                            headers: columnInsertedInfo.headers || []
                                        }]
                                    };
                                } else if (columnInsertedInfo.index !== undefined) {
                                    // Legacy Format mit index/name
                                    insertedColumnInfo = {
                                        operations: [{
                                            position: columnInsertedInfo.index,
                                            count: 1,
                                            headers: [columnInsertedInfo.name || 'New Column']
                                        }]
                                    };
                                }
                            }
                            
                            // Pr√ºfe ob Spalten verschoben wurden
                            const hasColumnMoves = explorerState.editedCells.has('_columnMoved');
                            let columnOrder = hasColumnMoves && explorerState.columnOrder.length > 0 
                                ? [...explorerState.columnOrder]
                                : null;
                            
                            // Wenn Spalten verschoben wurden, ordne die Daten im Frontend um
                            // WICHTIG: columnOrder wird trotzdem an Python gesendet,
                            // damit Python die Formatierung in der Excel-Datei umordnen kann!
                            if (columnOrder && deletedColumnIndices.length === 0) {
                                console.log('[Export] Ordne Daten gem√§√ü columnOrder um...');
                                
                                // Headers umordnen
                                exportHeaders = columnOrder.map(oldIdx => explorerState.headers[oldIdx]);
                                
                                // Daten umordnen
                                allData = allData.map(row => columnOrder.map(oldIdx => row[oldIdx]));
                                
                                // Styles umordnen (Keys sind "rowIdx-colIdx")
                                const newCellStyles = {};
                                for (const [key, style] of Object.entries(exportCellStyles)) {
                                    const [rowStr, colStr] = key.split('-');
                                    const rowIdx = parseInt(rowStr);
                                    const oldColIdx = parseInt(colStr);
                                    const newColIdx = columnOrder.indexOf(oldColIdx);
                                    if (newColIdx !== -1) {
                                        newCellStyles[`${rowIdx}-${newColIdx}`] = style;
                                    }
                                }
                                exportCellStyles = newCellStyles;
                                
                                // Formeln umordnen
                                const newFormulas = {};
                                for (const [key, formula] of Object.entries(exportCellFormulas)) {
                                    const [rowStr, colStr] = key.split('-');
                                    const rowIdx = parseInt(rowStr);
                                    const oldColIdx = parseInt(colStr);
                                    const newColIdx = columnOrder.indexOf(oldColIdx);
                                    if (newColIdx !== -1) {
                                        newFormulas[`${rowIdx}-${newColIdx}`] = formula;
                                    }
                                }
                                exportCellFormulas = newFormulas;
                                
                                // Hyperlinks umordnen
                                const newHyperlinks = {};
                                for (const [key, link] of Object.entries(exportCellHyperlinks)) {
                                    const [rowStr, colStr] = key.split('-');
                                    const rowIdx = parseInt(rowStr);
                                    const oldColIdx = parseInt(colStr);
                                    const newColIdx = columnOrder.indexOf(oldColIdx);
                                    if (newColIdx !== -1) {
                                        newHyperlinks[`${rowIdx}-${newColIdx}`] = link;
                                    }
                                }
                                exportCellHyperlinks = newHyperlinks;
                                
                                // RichText umordnen
                                const newRichText = {};
                                for (const [key, rt] of Object.entries(exportRichTextCells)) {
                                    const [rowStr, colStr] = key.split('-');
                                    const rowIdx = parseInt(rowStr);
                                    const oldColIdx = parseInt(colStr);
                                    const newColIdx = columnOrder.indexOf(oldColIdx);
                                    if (newColIdx !== -1) {
                                        newRichText[`${rowIdx}-${newColIdx}`] = rt;
                                    }
                                }
                                exportRichTextCells = newRichText;
                                
                                // VisibleColumns umordnen (jetzt sind es die neuen Indizes)
                                exportVisibleColumns = explorerState.visibleColumns.map(oldIdx => columnOrder.indexOf(oldIdx)).filter(idx => idx !== -1);
                                
                                // HiddenColumns umordnen
                                exportHiddenCols = hiddenCols.map(oldIdx => columnOrder.indexOf(oldIdx)).filter(idx => idx !== -1);
                                
                                console.log('[Export] Daten umgeordnet: Headers=' + exportHeaders.length + ', Rows=' + allData.length);
                                
                                // columnOrder wird an Python gesendet f√ºr Formatierungs-Umordnung
                                // NICHT auf null setzen!
                            }
                            
                            // RowHighlights f√ºr Export vorbereiten
                            // NUR NEUE Markierungen senden (die nicht in originalRowHighlights waren)
                            // Bestehende Markierungen √ºbernimmt xlwings automatisch aus der Datei
                            const exportRowHighlights = {};
                            explorerState.rowHighlights.forEach((color, originalIndex) => {
                                // Pr√ºfe ob dies eine NEUE Markierung ist (nicht in originalRowHighlights)
                                const isNewHighlight = !explorerState.originalRowHighlights.has(originalIndex);
                                if (isNewHighlight) {
                                    // Finde den neuen Index in filteredData
                                    const newIdx = explorerState.filteredData.findIndex(item => item.originalIndex === originalIndex);
                                    if (newIdx !== -1) {
                                        exportRowHighlights[newIdx] = color;
                                    }
                                }
                            });
                            
                            if (Object.keys(exportRowHighlights).length > 0) {
                                console.log(`[Export] ${Object.keys(exportRowHighlights).length} NEUE Zeilen-Markierungen werden gesendet`);
                            }
                            
                            // ClearedRowHighlights: Zeilen die urspr√ºnglich markiert waren, jetzt aber nicht mehr
                            const clearedRowHighlights = [];
                            explorerState.originalRowHighlights.forEach((color, originalIndex) => {
                                // Wenn diese Zeile nicht mehr in rowHighlights ist, wurde sie entfernt
                                if (!explorerState.rowHighlights.has(originalIndex)) {
                                    const newIdx = explorerState.filteredData.findIndex(item => item.originalIndex === originalIndex);
                                    if (newIdx !== -1) {
                                        clearedRowHighlights.push(newIdx);
                                    }
                                }
                            });
                            if (clearedRowHighlights.length > 0) {
                                console.log(`[Export] ${clearedRowHighlights.length} entfernte Zeilen-Markierungen: ${clearedRowHighlights.join(', ')}`);
                            }
                            
                            sheetData = {
                                sheetName: sheetName,
                                headers: exportHeaders,
                                data: allData,
                                visibleColumns: exportVisibleColumns,
                                hiddenRows: currentHiddenRows,
                                hiddenColumns: exportHiddenCols,
                                cellStyles: exportCellStyles,
                                cellFormulas: exportCellFormulas,
                                cellHyperlinks: exportCellHyperlinks,
                                richTextCells: exportRichTextCells,
                                // Nur NEUE Markierungen senden - bestehende √ºbernimmt xlwings aus der Datei
                                rowHighlights: exportRowHighlights,
                                clearedRowHighlights: clearedRowHighlights,
                                autoFilterRange: explorerState.autoFilterRange,
                                fullRewrite: true,
                                structuralChange: true,  // Signalisiert dass Styles komplett zur√ºckgesetzt werden m√ºssen
                                deletedColumnIndices: deletedColumnIndices,  // Array der gel√∂schten Spalten f√ºr spliceColumns
                                insertedColumnInfo: insertedColumnInfo,  // Info √ºber eingef√ºgte Spalten f√ºr spliceColumns
                                columnOrder: columnOrder,  // Neue Spaltenreihenfolge (null = keine √Ñnderung oder bereits angewendet)
                                affectedRows: affectedRowsArray,  // Betroffene Zeilen bei Row-Move f√ºr Style-Reset
                                // rowMapping wird gesendet bei: Filter, Row-Move ODER Row-Deleted
                                rowMapping: filterRowMapping || (explorerState.rowMapping && explorerState.rowMapping.length > 0 ? explorerState.rowMapping : null)
                            };
                            // Pr√ºfe ob rowMapping gesendet wird
                            const hasRowMapping = !!(filterRowMapping || (explorerState.rowMapping && explorerState.rowMapping.length > 0));
                            console.log(`[Export] Strukturelle √Ñnderung: Full Rewrite (${allData.length} Zeilen, ${exportHeaders.length} Spalten, ${exportHiddenCols.length} versteckte Spalten, ${currentHiddenRows.length} versteckte Zeilen, ${Object.keys(exportRowHighlights).length} Zeilen-Highlights, deletedColumnIndices: ${JSON.stringify(deletedColumnIndices)}, insertedColumnInfo: ${JSON.stringify(insertedColumnInfo)}, columnOrder: ${columnOrder ? 'angepasst' : 'original/angewendet'}, affectedRows: ${affectedRowsArray.length}, rowMapping: ${hasRowMapping ? 'ja' : 'nein'}, AutoFilter: ${explorerState.autoFilterRange || 'none'})`);
                        } else {
                            // Nur Zell-Edits: changedCells
                            const changedCells = {};
                            for (const cellKey of explorerState.editedCells.keys()) {
                                // √úberspringe spezielle Marker-Keys
                                if (cellKey.startsWith('_')) continue;
                                
                                const [rowStr, colStr] = cellKey.split('-');
                                const rowIdx = parseInt(rowStr);
                                const colIdx = parseInt(colStr);
                                if (rowIdx >= 0 && colIdx >= 0 && explorerState.data[rowIdx]) {
                                    changedCells[cellKey] = explorerState.data[rowIdx][colIdx];
                                }
                            }
                            
                            // Bei vielen √Ñnderungen (>100): Full Rewrite statt einzelne Zellen
                            // Einzelne Zell-Writes sind bei xlwings sehr langsam!
                            const useBulkWrite = Object.keys(changedCells).length > 100;
                            
                            if (useBulkWrite) {
                                console.log(`[Export] ${Object.keys(changedCells).length} √Ñnderungen - verwende Full Rewrite f√ºr Performance`);
                                
                                // Full Rewrite mit allen Daten
                                let allData = explorerState.filteredData.map(item => item.row);
                                
                                sheetData = {
                                    sheetName: sheetName,
                                    headers: [...explorerState.headers],
                                    data: allData,
                                    visibleColumns: [...(explorerState.visibleColumns || [])],
                                    hiddenRows: currentHiddenRows,
                                    hiddenColumns: hiddenCols,
                                    cellStyles: {},  // Styles bleiben erhalten
                                    cellFormulas: {},
                                    cellHyperlinks: {},
                                    richTextCells: {},
                                    rowHighlights: {},
                                    autoFilterRange: explorerState.autoFilterRange,
                                    fullRewrite: true,
                                    structuralChange: false  // Keine strukturelle √Ñnderung, nur Daten-Update
                                };
                            } else {
                                // RichText f√ºr ge√§nderte Zellen
                                const richTextForChanged = {};
                                for (const cellKey of explorerState.editedCells.keys()) {
                                    // √úberspringe spezielle Marker-Keys
                                    if (cellKey.startsWith('_')) continue;
                                    
                                    if (explorerState.richTextCells && explorerState.richTextCells[cellKey]) {
                                        richTextForChanged[cellKey] = explorerState.richTextCells[cellKey];
                                    }
                                }
                                
                                sheetData = {
                                    sheetName: sheetName,
                                    changedCells: changedCells,
                                    richTextCells: Object.keys(richTextForChanged).length > 0 ? richTextForChanged : undefined,
                                    hiddenColumns: hiddenCols,
                                    hiddenRows: currentHiddenRows,
                                    autoFilterRange: explorerState.autoFilterRange,
                                    fullRewrite: false
                                };
                                console.log(`[Export] Zell-Edits: ${Object.keys(changedCells).length} ge√§nderte Zellen, ${Object.keys(richTextForChanged).length} RichText, ${hiddenCols.length} versteckte Spalten, ${currentHiddenRows.length} versteckte Zeilen, AutoFilter: ${explorerState.autoFilterRange || 'none'}`);
                            }
                        }
                    } else if (cachedSheet) {
                        // Gecachtes Sheet mit √Ñnderungen - keine Styles senden (Backend beh√§lt Originale)
                        sheetData = {
                            sheetName: sheetName,
                            headers: cachedSheet.headers || [],
                            data: cachedSheet.data || [],
                            visibleColumns: cachedSheet.visibleColumns || [],
                            hiddenRows: cachedSheet.hiddenRows ? Array.from(cachedSheet.hiddenRows) : [],
                            hasChanges: true,
                            cellStyles: {},
                            cellFormulas: {},
                            cellHyperlinks: {},
                            richTextCells: {},
                            affectedRows: [],
                            autoFilterRange: cachedSheet.autoFilterRange || null
                        };
                    } else {
                        // Sheet nicht im Cache - Backend soll aus Datei lesen
                        // Hier sind keine cellStyles vorhanden, Backend muss sie selbst extrahieren
                        sheetData = {
                            sheetName: sheetName,
                            fromFile: true,
                            cellStyles: {},  // Leer - Backend wird sie aus der Datei extrahieren
                            autoFilterRange: null  // Backend wird es aus der Datei lesen
                        };
                    }
                    
                    sheetsToExport.push(sheetData);
                }
                
                // IMMER xlwings/Python f√ºr Export verwenden (CF-Erhaltung)
                // Die Checkbox steuert nur das LESEN, nicht das Schreiben
                console.log('[Export] Verwende xlwings/Python f√ºr CF-Erhaltung...');
                
                let result;
                result = await window.electronAPI.pythonExportMultipleSheets({
                    sourcePath: explorerState.filePath,
                    targetPath: savePath,
                    sheets: sheetsToExport,
                    password: exportPassword,
                    sourcePassword: explorerState.filePassword
                });
                
                if (result.success) {
                    const pwInfo = exportPassword ? ' (passwortgesch√ºtzt)' : '';
                    const engineInfo = result.method ? ` [${result.method}]` : '';
                    elements.explorerStatus.textContent = `‚úì ${selectedSheets.length} Arbeitsblatt/bl√§tter exportiert${pwInfo}${engineInfo}: ${savePath}`;
                    
                    // Pr√ºfe ob strukturelle √Ñnderungen vorlagen (Spalten eingef√ºgt/gel√∂scht)
                    const exportedSheet = sheetsToExport.find(s => s.sheetName === explorerState.selectedSheet);
                    const hadStructuralChange = exportedSheet && exportedSheet.structuralChange;
                    
                    if (hadStructuralChange) {
                        // Bei strukturellen √Ñnderungen: Datei neu einlesen f√ºr korrekte Styles
                        console.log('[Export] Strukturelle √Ñnderung - lade Datei neu f√ºr korrekte Styles...');
                        
                        // Speichere aktuelle Ansicht f√ºr Wiederherstellung
                        const currentSheet = explorerState.selectedSheet;
                        const currentPage = explorerState.currentPage;
                        const currentSort = { column: explorerState.sortColumn, direction: explorerState.sortDirection, type: explorerState.sortType };
                        
                        // Datei neu laden (l√§dt auch das aktuelle Sheet automatisch)
                        await reloadExplorerFile(savePath, explorerState.filePassword);
                        
                        // WICHTIG: Nach Reload nochmal sicherstellen dass alles sauber ist
                        explorerState.editedCells.clear();
                        explorerState.sheetDataCache.clear();
                        explorerState.rowMapping = null;
                        explorerState.affectedRows?.clear();
                        
                        // Sortierung wiederherstellen
                        if (currentSort.column !== null) {
                            explorerState.sortColumn = currentSort.column;
                            explorerState.sortDirection = currentSort.direction;
                            explorerState.sortType = currentSort.type;
                            applyExplorerSort();
                            renderExplorerTable();
                        }
                        
                        // Seite wiederherstellen
                        if (currentPage <= Math.ceil(explorerState.filteredData.length / explorerState.pageSize)) {
                            explorerState.currentPage = currentPage;
                            renderExplorerTable();
                        }
                    } else {
                        // Keine strukturelle √Ñnderung: Schneller Refresh ohne Datei neu lesen
                        console.log('[Export] Keine strukturelle √Ñnderung - schneller State-Refresh...');
                        
                        if (exportedSheet && exportedSheet.fullRewrite && exportedSheet.data) {
                            // Headers und Data √ºbernehmen
                            explorerState.headers = [...exportedSheet.headers];
                            explorerState.data = exportedSheet.data.map(row => [...row]);
                            explorerState.originalData = exportedSheet.data.map(row => [...row]);
                            
                            // filteredData neu aufbauen
                            explorerState.filteredData = explorerState.data.map((row, index) => ({
                                originalIndex: index,
                                row: row
                            }));
                            
                            // rowHighlights: Neue wurden gesetzt, sind jetzt "original"
                            explorerState.originalRowHighlights = new Map(explorerState.rowHighlights);
                        }
                        
                        // √Ñnderungsmarkierungen zur√ºcksetzen
                        explorerState.editedCells.clear();
                        explorerState.affectedRows?.clear();
                        explorerState.rowMapping = null;
                        
                        // Cache aktualisieren
                        saveCurrentSheetToCache();
                        
                        // UI aktualisieren
                        filterExplorerData();
                    }
                    
                    showFloatingStatus(`‚úì Export erfolgreich${pwInfo}${engineInfo}`, 'success');
                } else {
                    elements.explorerStatus.textContent = `Fehler: ${result.error}`;
                }
            }
        }
        
        // Interne Funktion: L√§dt eine Datei ohne "ungespeicherte √Ñnderungen"-Pr√ºfung
        // Wird nach dem Speichern verwendet um den State zu synchronisieren
        async function reloadExplorerFile(filePath, password = null) {
            elements.explorerStatus.textContent = 'Lade Datei...';
            
            let result = await window.electronAPI.readExcelFile(filePath, password);
            
            if (!result.success) {
                console.error('[Reload] Fehler beim Neuladen:', result.error);
                elements.explorerStatus.textContent = `Fehler beim Neuladen: ${result.error}`;
                return;
            }
            
            // Cache komplett leeren
            explorerState.sheetDataCache.clear();
            explorerState.editedCells.clear();
            explorerState.rowHighlights.clear();
            explorerState.affectedRows?.clear();
            explorerState.rowMapping = null;
            
            // State aktualisieren
            explorerState.filePath = filePath;
            explorerState.fileName = result.fileName;
            explorerState.sheets = result.sheets;
            explorerState.filePassword = password;
            
            // UI aktualisieren
            document.getElementById('explorerFileName').textContent = explorerState.fileName;
            
            // Sheet-Dropdown f√ºllen
            elements.explorerSheetSelect.innerHTML = explorerState.sheets
                .map(s => `<option value="${s}">${s}</option>`)
                .join('');
            
            // Aktuelles Sheet ausw√§hlen (falls es noch existiert)
            const currentSheet = explorerState.selectedSheet;
            if (currentSheet && explorerState.sheets.includes(currentSheet)) {
                elements.explorerSheetSelect.value = currentSheet;
                await loadExplorerSheet(currentSheet);
            } else if (explorerState.sheets.length > 0) {
                await loadExplorerSheet(explorerState.sheets[0]);
            }
            
            console.log('[Reload] Datei neu geladen:', filePath);
        }
        
        // Dialog zur Auswahl der Arbeitsbl√§tter
        function showSheetSelectionDialog(mode = 'export') {
            return new Promise((resolve) => {
                // Pr√ºfe ob bereits ein Dialog existiert
                const existingDialog = document.querySelector('.sheet-selection-overlay');
                if (existingDialog) existingDialog.remove();
                
                const title = mode === 'export' ? 'Arbeitsbl√§tter exportieren' : 'Arbeitsbl√§tter ausw√§hlen';
                const confirmText = mode === 'export' ? 'Exportieren' : 'OK';
                
                const overlay = document.createElement('div');
                overlay.className = 'sheet-selection-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.6);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10002;
                `;
                
                const dialog = document.createElement('div');
                dialog.className = 'sheet-selection-dialog';
                dialog.style.cssText = `
                    background: var(--bg-medium);
                    border: 1px solid var(--border);
                    border-radius: 8px;
                    padding: 20px;
                    min-width: 350px;
                    max-width: 500px;
                    max-height: 80vh;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                `;
                
                // Sheet-Liste erstellen
                let sheetListHtml = '';
                explorerState.sheets.forEach((sheetName, index) => {
                    const isCurrentSheet = sheetName === explorerState.selectedSheet;
                    const isCached = explorerState.sheetDataCache.has(sheetName);
                    const hasChanges = isCurrentSheet 
                        ? explorerState.editedCells.size > 0 
                        : (isCached && explorerState.sheetDataCache.get(sheetName).editedCells.size > 0);
                    
                    const changesBadge = hasChanges ? '<span style="color: var(--warning); margin-left: 8px; font-size: 11px;">‚óè √Ñnderungen</span>' : '';
                    const currentBadge = isCurrentSheet ? '<span style="color: var(--primary); margin-left: 8px; font-size: 11px;">(aktuell)</span>' : '';
                    
                    sheetListHtml += `
                        <label style="display: flex; align-items: center; padding: 10px 12px; background: var(--bg-light); border-radius: 4px; cursor: pointer; user-select: none;">
                            <input type="checkbox" class="sheet-checkbox" value="${escapeHtml(sheetName)}" 
                                ${isCurrentSheet ? 'checked' : ''} 
                                style="width: 18px; height: 18px; margin-right: 12px; cursor: pointer;">
                            <span style="flex: 1;">${escapeHtml(sheetName)}</span>
                            ${currentBadge}${changesBadge}
                        </label>
                    `;
                });
                
                dialog.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: var(--text);">üìë ${title}</h3>
                    <p style="margin: 0 0 15px 0; color: var(--text-secondary); font-size: 13px;">
                        W√§hlen Sie die Arbeitsbl√§tter aus, die exportiert werden sollen:
                    </p>
                    <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                        <button class="btn btn-sm btn-secondary" id="selectAllSheets">Alle ausw√§hlen</button>
                        <button class="btn btn-sm btn-secondary" id="selectNoneSheets">Keine ausw√§hlen</button>
                    </div>
                    <div style="overflow-y: auto; max-height: 300px; display: flex; flex-direction: column; gap: 6px; padding-right: 5px;">
                        ${sheetListHtml}
                    </div>
                    ${mode === 'export' ? `
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer; user-select: none;">
                            <input type="checkbox" id="exportPasswordCheckbox" style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="color: var(--text);">üîê Mit Passwortschutz exportieren</span>
                        </label>
                        <div id="passwordInputContainer" style="display: none; margin-top: 10px; padding-left: 28px;">
                            <input type="password" id="exportPasswordInput" placeholder="Passwort eingeben" 
                                style="width: 100%; padding: 8px 12px; background: var(--bg-light); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-size: 14px;">
                        </div>
                    </div>
                    ` : ''}
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border);">
                        <button class="btn btn-secondary" id="sheetDialogCancel">Abbrechen</button>
                        <button class="btn btn-primary" id="sheetDialogConfirm">${confirmText}</button>
                    </div>
                `;
                
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
                
                // Event handlers
                const confirmBtn = dialog.querySelector('#sheetDialogConfirm');
                const cancelBtn = dialog.querySelector('#sheetDialogCancel');
                const selectAllBtn = dialog.querySelector('#selectAllSheets');
                const selectNoneBtn = dialog.querySelector('#selectNoneSheets');
                const checkboxes = dialog.querySelectorAll('.sheet-checkbox');
                const passwordCheckbox = dialog.querySelector('#exportPasswordCheckbox');
                const passwordContainer = dialog.querySelector('#passwordInputContainer');
                const passwordInput = dialog.querySelector('#exportPasswordInput');
                
                // Passwort-Checkbox Toggle (nur im Export-Modus)
                if (passwordCheckbox) {
                    passwordCheckbox.onchange = () => {
                        passwordContainer.style.display = passwordCheckbox.checked ? 'block' : 'none';
                        if (passwordCheckbox.checked) {
                            passwordInput.focus();
                        }
                    };
                }
                
                selectAllBtn.onclick = () => {
                    checkboxes.forEach(cb => cb.checked = true);
                };
                
                selectNoneBtn.onclick = () => {
                    checkboxes.forEach(cb => cb.checked = false);
                };
                
                confirmBtn.onclick = () => {
                    const selected = Array.from(checkboxes)
                        .filter(cb => cb.checked)
                        .map(cb => cb.value);
                    
                    // Bei Export: Passwort mit zur√ºckgeben
                    const password = (mode === 'export' && passwordCheckbox && passwordCheckbox.checked) 
                        ? (passwordInput?.value || null) 
                        : null;
                    
                    overlay.remove();
                    
                    // R√ºckgabe als Objekt mit sheets und password
                    if (mode === 'export') {
                        resolve({ sheets: selected, password: password });
                    } else {
                        resolve(selected);
                    }
                };
                
                cancelBtn.onclick = () => {
                    overlay.remove();
                    resolve(null);
                };
                
                // ESC zum Abbrechen
                const escHandler = (e) => {
                    if (e.key === 'Escape') {
                        overlay.remove();
                        document.removeEventListener('keydown', escHandler);
                        resolve(null);
                    }
                };
                document.addEventListener('keydown', escHandler);
            });
        }
        
        // Dialog f√ºr Passwortschutz beim Speichern/Exportieren
        function showPasswordProtectionDialog(currentPassword = null, mode = 'save') {
            return new Promise((resolve) => {
                const existingDialog = document.querySelector('.password-dialog-overlay');
                if (existingDialog) existingDialog.remove();
                
                const overlay = document.createElement('div');
                overlay.className = 'password-dialog-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.6);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10002;
                `;
                
                const dialog = document.createElement('div');
                dialog.className = 'password-dialog';
                dialog.style.cssText = `
                    background: var(--bg-medium);
                    border: 1px solid var(--border);
                    border-radius: 8px;
                    padding: 20px;
                    max-width: 450px;
                    width: 90%;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                `;
                
                const title = mode === 'export' ? 'üîê Export-Passwortschutz' : 'üîê Datei-Passwortschutz';
                const hasCurrentPassword = !!currentPassword;
                
                dialog.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: var(--text);">${title}</h3>
                    <p style="margin: 0 0 15px 0; color: var(--text-secondary); font-size: 13px;">
                        ${mode === 'export' 
                            ? 'Die exportierte Datei kann mit einem Passwort gesch√ºtzt werden.'
                            : 'Die Datei kann mit einem Passwort gesch√ºtzt werden.'}
                        <br>Excel-kompatible Verschl√ºsselung - keine zus√§tzlichen Tools n√∂tig.
                    </p>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 10px;">
                            <input type="radio" name="passwordOption" value="none" ${!hasCurrentPassword ? 'checked' : ''}>
                            <span style="color: var(--text);">Kein Passwortschutz</span>
                        </label>
                        ${hasCurrentPassword ? `
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 10px;">
                            <input type="radio" name="passwordOption" value="keep" checked>
                            <span style="color: var(--text);">Bestehendes Passwort beibehalten</span>
                        </label>` : ''}
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="radio" name="passwordOption" value="new">
                            <span style="color: var(--text);">${hasCurrentPassword ? 'Neues Passwort setzen' : 'Mit Passwort sch√ºtzen'}</span>
                        </label>
                    </div>
                    
                    <div id="newPasswordSection" style="display: none; margin-bottom: 15px; padding: 12px; background: var(--bg-dark); border-radius: 6px;">
                        <label style="display: block; margin-bottom: 6px; color: var(--text-muted); font-size: 12px;">Neues Passwort:</label>
                        <input type="password" id="newPasswordInput" placeholder="Passwort eingeben..." 
                               style="width: 100%; padding: 8px 12px; border: 1px solid var(--border); border-radius: 4px; 
                                      background: var(--bg-light); color: var(--text); box-sizing: border-box; margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 6px; color: var(--text-muted); font-size: 12px;">Passwort best√§tigen:</label>
                        <input type="password" id="confirmPasswordInput" placeholder="Passwort wiederholen..." 
                               style="width: 100%; padding: 8px 12px; border: 1px solid var(--border); border-radius: 4px; 
                                      background: var(--bg-light); color: var(--text); box-sizing: border-box;">
                        <div id="passwordError" style="color: #F44336; font-size: 12px; margin-top: 8px; display: none;"></div>
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="btn btn-secondary" id="pwDialogCancel">Abbrechen</button>
                        <button class="btn btn-success" id="pwDialogConfirm">Fortfahren</button>
                    </div>
                `;
                
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
                
                // Radio-Button Handler
                const radios = dialog.querySelectorAll('input[name="passwordOption"]');
                const newPwSection = dialog.querySelector('#newPasswordSection');
                const newPwInput = dialog.querySelector('#newPasswordInput');
                const confirmPwInput = dialog.querySelector('#confirmPasswordInput');
                const pwError = dialog.querySelector('#passwordError');
                
                radios.forEach(radio => {
                    radio.onchange = () => {
                        newPwSection.style.display = radio.value === 'new' && radio.checked ? 'block' : 'none';
                        if (radio.value === 'new' && radio.checked) {
                            setTimeout(() => newPwInput.focus(), 100);
                        }
                    };
                });
                
                // Confirm Button
                dialog.querySelector('#pwDialogConfirm').onclick = () => {
                    const selectedOption = dialog.querySelector('input[name="passwordOption"]:checked').value;
                    
                    if (selectedOption === 'none') {
                        overlay.remove();
                        resolve({ action: 'none', password: null });
                    } else if (selectedOption === 'keep') {
                        overlay.remove();
                        resolve({ action: 'keep', password: currentPassword });
                    } else if (selectedOption === 'new') {
                        const newPw = newPwInput.value;
                        const confirmPw = confirmPwInput.value;
                        
                        if (!newPw) {
                            pwError.textContent = 'Bitte Passwort eingeben';
                            pwError.style.display = 'block';
                            newPwInput.focus();
                            return;
                        }
                        if (newPw.length < 4) {
                            pwError.textContent = 'Passwort muss mindestens 4 Zeichen haben';
                            pwError.style.display = 'block';
                            newPwInput.focus();
                            return;
                        }
                        if (newPw !== confirmPw) {
                            pwError.textContent = 'Passw√∂rter stimmen nicht √ºberein';
                            pwError.style.display = 'block';
                            confirmPwInput.focus();
                            return;
                        }
                        
                        overlay.remove();
                        resolve({ action: 'new', password: newPw });
                    }
                };
                
                // Cancel Button
                dialog.querySelector('#pwDialogCancel').onclick = () => {
                    overlay.remove();
                    resolve(null);
                };
                
                // ESC zum Abbrechen
                const escHandler = (e) => {
                    if (e.key === 'Escape') {
                        overlay.remove();
                        document.removeEventListener('keydown', escHandler);
                        resolve(null);
                    }
                };
                document.addEventListener('keydown', escHandler);
            });
        }

        // Best√§tigungsdialog anzeigen
        function showConfirmDialog(title, message, confirmText = 'OK', cancelText = 'Abbrechen') {
            return new Promise((resolve) => {
                // Pr√ºfe ob bereits ein Dialog existiert
                const existingDialog = document.querySelector('.confirm-dialog-overlay');
                if (existingDialog) existingDialog.remove();
                
                const overlay = document.createElement('div');
                overlay.className = 'confirm-dialog-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0,0,0,0.6);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10002;
                `;
                
                const dialog = document.createElement('div');
                dialog.className = 'confirm-dialog';
                dialog.style.cssText = `
                    background: var(--bg-medium);
                    border: 1px solid var(--border);
                    border-radius: 8px;
                    padding: 20px;
                    max-width: 400px;
                    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                `;
                
                const buttonsHtml = cancelText 
                    ? `<button class="btn btn-secondary" id="confirmDialogCancel">${cancelText}</button>
                       <button class="btn btn-success" id="confirmDialogConfirm">${confirmText}</button>`
                    : `<button class="btn btn-success" id="confirmDialogConfirm">${confirmText}</button>`;
                
                dialog.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: var(--text);">${title}</h3>
                    <p style="margin: 0 0 20px 0; color: var(--text-secondary); white-space: pre-line;">${message}</p>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        ${buttonsHtml}
                    </div>
                `;
                
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
                
                // Event handlers
                const confirmBtn = dialog.querySelector('#confirmDialogConfirm');
                const cancelBtn = dialog.querySelector('#confirmDialogCancel');
                
                confirmBtn.onclick = () => {
                    overlay.remove();
                    resolve(true);
                };
                
                if (cancelBtn) {
                    cancelBtn.onclick = () => {
                        overlay.remove();
                        resolve(false);
                    };
                }
                
                // ESC zum Abbrechen
                const escHandler = (e) => {
                    if (e.key === 'Escape') {
                        overlay.remove();
                        document.removeEventListener('keydown', escHandler);
                        resolve(false);
                    }
                };
                document.addEventListener('keydown', escHandler);
            });
        }
        
        // ==================== New Month Modal Functions ====================
        function openNewMonthModal() {
            if (!state.template.filePath && !state.template.data) {
                showStatus(elements.transferStatus, 'Bitte erst ein Template laden', 'error');
                return;
            }
            
            // Element direkt aus DOM holen (kann durch Sprachumschaltung ersetzt worden sein)
            const templateNameEl = document.getElementById('newMonthTemplateName');
            if (templateNameEl) {
                templateNameEl.textContent = state.template.name || '-';
            }
            
            // Vorschlag f√ºr neuen Dateinamen: Template-Name als Basis verwenden
            let baseName = state.template.name || 'Vertragsliste.xlsx';
            // Entferne .xlsx/.xls Endung falls vorhanden
            baseName = baseName.replace(/\.(xlsx|xls)$/i, '');
            // F√ºge aktuellen Monat hinzu
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            elements.newMonthFilename.value = `${baseName}_${year}-${month}.xlsx`;
            
            elements.newMonthModal.classList.remove('hidden');
        }
        
        function closeNewMonthModal() {
            elements.newMonthModal.classList.add('hidden');
        }
        
        async function confirmNewMonth() {
            const filename = elements.newMonthFilename.value.trim();
            if (!filename) {
                showStatus(elements.transferStatus, 'Bitte einen Dateinamen eingeben', 'error');
                return;
            }
            
            const finalFilename = filename.endsWith('.xlsx') ? filename : filename + '.xlsx';
            
            if (state.template.filePath) {
                const savePath = await window.electronAPI.saveFileDialog({
                    title: 'Neue Monatsdatei speichern',
                    defaultPath: getWorkingDirectoryPath() ? (getWorkingDirectoryPath() + '/' + finalFilename) : finalFilename,
                    filters: [{ name: 'Excel', extensions: ['xlsx'] }]
                });
                
                if (savePath) {
                    // Verwende copyExcelFile (wie in preload.js definiert)
                    const result = await window.electronAPI.copyExcelFile({
                        sourcePath: state.template.filePath,
                        targetPath: savePath
                    });
                    
                    if (result.success) {
                        closeNewMonthModal();
                        
                        // Neue Datei als Datei 2 laden
                        const readResult = await window.electronAPI.readExcelFile(savePath);
                        if (readResult.success) {
                            state.file2.name = readResult.fileName;
                            state.file2.filePath = savePath;
                            state.file2.sheets = readResult.sheets;
                            state.file2.workbook = { SheetNames: readResult.sheets };
                            
                            elements.selectSheet2.innerHTML = readResult.sheets.map(s => `<option value="${s}">${s}</option>`).join('');
                            elements.selectSheet2.disabled = false;
                            elements.file2Info.textContent = `‚úì ${readResult.fileName}`;
                            elements.file2Info.classList.add('loaded');
                            
                            await loadSheet2Electron(readResult.sheets[0]);
                            
                            showStatus(elements.transferStatus, `‚úì Neue Monatsdatei erstellt: ${readResult.fileName}`, 'success');
                        }
                    } else {
                        showStatus(elements.transferStatus, `Fehler: ${result.error}`, 'error');
                    }
                }
            }
        }
        
        // ==================== Flag/Comment Column Visibility ====================
        function isFlagEnabled() {
            return document.getElementById('enableFlagColumn')?.checked ?? true;
        }
        
        function isCommentEnabled() {
            return document.getElementById('enableCommentColumn')?.checked ?? true;
        }
        
        // Automatische Spaltenberechnung:
        // - Flag ist immer Spalte 1 (wenn aktiviert)
        // - Kommentar ist nach Flag (Spalte 1 oder 2)
        // - Daten beginnen nach Flag und Kommentar
        function getFlagColumn() {
            // Flag ist immer Spalte 1 (A)
            return 1;
        }
        
        function getCommentColumn() {
            // Kommentar kommt nach Flag:
            // - Wenn Flag aktiviert: Spalte 2 (B)
            // - Wenn Flag deaktiviert: Spalte 1 (A)
            return isFlagEnabled() ? 2 : 1;
        }
        
        function getDataStartColumn() {
            // Daten beginnen nach Flag und Kommentar:
            // - Beide aktiviert: Spalte 3 (C)
            // - Nur eines aktiviert: Spalte 2 (B)
            // - Beide deaktiviert: Spalte 1 (A)
            let startCol = 1;
            if (isFlagEnabled()) startCol++;
            if (isCommentEnabled()) startCol++;
            return startCol;
        }
        
        // Aktualisiert die Anzeige der automatischen Spaltenberechnung
        function updateColumnDisplays() {
            const flagEnabled = isFlagEnabled();
            const commentEnabled = isCommentEnabled();
            
            const flagDisplay = document.getElementById('flagColumnDisplay');
            const commentDisplay = document.getElementById('commentColumnDisplay');
            const startDisplay = document.getElementById('targetStartColumnDisplay');
            
            if (flagDisplay) {
                flagDisplay.textContent = flagEnabled ? '‚Üí Spalte A' : '(deaktiviert)';
                flagDisplay.style.color = flagEnabled ? 'var(--excel-green)' : 'var(--text-muted)';
            }
            
            if (commentDisplay) {
                if (commentEnabled) {
                    const col = getCommentColumn();
                    commentDisplay.textContent = `‚Üí Spalte ${String.fromCharCode(64 + col)}`;
                    commentDisplay.style.color = 'var(--excel-green)';
                } else {
                    commentDisplay.textContent = '(deaktiviert)';
                    commentDisplay.style.color = 'var(--text-muted)';
                }
            }
            
            if (startDisplay) {
                const startCol = getDataStartColumn();
                startDisplay.textContent = `Spalte ${String.fromCharCode(64 + startCol)} (automatisch berechnet)`;
            }
        }
        
        function getFlagValues() {
            const input = document.getElementById('flagValues')?.value || 'A,D,C,leer';
            return input.split(',').map(v => v.trim()).filter(v => v);
        }
        
        function getCommentPlaceholder() {
            return document.getElementById('commentPlaceholder')?.value || 'Freier Text...';
        }
        
        function updateFlagDropdownOptions() {
            const values = getFlagValues();
            
            // Standard-Labels f√ºr bekannte Flags
            const flagLabels = {
                'A': 'A (Add)',
                'D': 'D (Delete)',
                'C': 'C (Change)',
                'leer': 'Leerzeile'
            };
            
            // Optionen HTML generieren
            const optionsHtml = values.map(v => {
                const label = flagLabels[v] || v;
                return `<option value="${escapeHtml(v)}">${escapeHtml(label)}</option>`;
            }).join('');
            
            // Beide Flag-Dropdowns aktualisieren
            if (elements.transferFlag) {
                elements.transferFlag.innerHTML = optionsHtml;
            }
            if (elements.newRowFlag) {
                elements.newRowFlag.innerHTML = optionsHtml;
            }
        }
        
        function updateCommentPlaceholders() {
            const placeholder = getCommentPlaceholder();
            if (elements.transferComment) {
                elements.transferComment.placeholder = placeholder;
            }
            if (elements.newRowComment) {
                elements.newRowComment.placeholder = placeholder;
            }
        }
        
        function updateFlagCommentVisibility() {
            const flagEnabled = isFlagEnabled();
            const commentEnabled = isCommentEnabled();
            
            // Transfer Panel
            const transferFlagField = elements.transferFlag?.closest('.transfer-field');
            const transferCommentField = elements.transferComment?.closest('.transfer-field');
            
            if (transferFlagField) {
                transferFlagField.style.display = flagEnabled ? '' : 'none';
            }
            if (transferCommentField) {
                transferCommentField.style.display = commentEnabled ? '' : 'none';
            }
            
            // New Row Panel
            const newRowFlagField = elements.newRowFlag?.closest('.transfer-field');
            const newRowCommentField = elements.newRowComment?.closest('.transfer-field');
            
            if (newRowFlagField) {
                newRowFlagField.style.display = flagEnabled ? '' : 'none';
            }
            if (newRowCommentField) {
                newRowCommentField.style.display = commentEnabled ? '' : 'none';
            }
            
            // Modal Config Sections
            const flagConfig = document.getElementById('flagColumnConfig');
            const commentConfig = document.getElementById('commentColumnConfig');
            
            if (flagConfig) {
                flagConfig.style.display = flagEnabled ? '' : 'none';
            }
            if (commentConfig) {
                commentConfig.style.display = commentEnabled ? '' : 'none';
            }
            
            // Update Labels mit Spaltennummer
            const flagColumn = getFlagColumn();
            const commentColumn = getCommentColumn();
            const colLetters = ['', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            
            if (transferFlagField) {
                const label = transferFlagField.querySelector('label');
                if (label) label.textContent = `Spalte ${colLetters[flagColumn]} - Flag:`;
            }
            if (transferCommentField) {
                const label = transferCommentField.querySelector('label');
                if (label) label.textContent = `Spalte ${colLetters[commentColumn]} - Kommentar:`;
            }
            if (newRowFlagField) {
                const label = newRowFlagField.querySelector('label');
                if (label) label.textContent = `Flag (Spalte ${colLetters[flagColumn]}):`;
            }
            if (newRowCommentField) {
                const label = newRowCommentField.querySelector('label');
                if (label) label.textContent = `Kommentar (Spalte ${colLetters[commentColumn]}):`;
            }
        }
        
        // ==================== Initialize App ====================
        async function initApp() {
            // Initialize theme and language first
            setTheme(currentTheme);
            setLanguage(currentLanguage);
            document.getElementById('selectLanguage').value = currentLanguage;
            document.getElementById('selectTheme').value = currentTheme;
            document.getElementById('selectLanguage').onchange = (e) => setLanguage(e.target.value);
            document.getElementById('selectTheme').onchange = (e) => setTheme(e.target.value);
            
            // Flag/Comment Column Options
            const flagCheckbox = document.getElementById('enableFlagColumn');
            const commentCheckbox = document.getElementById('enableCommentColumn');
            const flagValuesInput = document.getElementById('flagValues');
            const commentPlaceholderInput = document.getElementById('commentPlaceholder');
            
            // Load saved preferences
            const savedFlagEnabled = localStorage.getItem('excelSyncEnableFlag');
            const savedCommentEnabled = localStorage.getItem('excelSyncEnableComment');
            const savedFlagValues = localStorage.getItem('excelSyncFlagValues');
            const savedCommentPlaceholder = localStorage.getItem('excelSyncCommentPlaceholder');
            
            if (savedFlagEnabled !== null) {
                flagCheckbox.checked = savedFlagEnabled === 'true';
            }
            if (savedCommentEnabled !== null) {
                commentCheckbox.checked = savedCommentEnabled === 'true';
            }
            if (savedFlagValues) {
                flagValuesInput.value = savedFlagValues;
            }
            if (savedCommentPlaceholder) {
                commentPlaceholderInput.value = savedCommentPlaceholder;
            }
            
            // Apply initial settings
            updateFlagDropdownOptions();
            updateCommentPlaceholders();
            updateFlagCommentVisibility();
            updateColumnDisplays();
            
            flagCheckbox.onchange = () => {
                localStorage.setItem('excelSyncEnableFlag', flagCheckbox.checked);
                updateFlagCommentVisibility();
                updateColumnDisplays();
                renderMappingList();
            };
            
            commentCheckbox.onchange = () => {
                localStorage.setItem('excelSyncEnableComment', commentCheckbox.checked);
                updateFlagCommentVisibility();
                updateColumnDisplays();
                renderMappingList();
            };
            
            flagValuesInput.onchange = () => {
                localStorage.setItem('excelSyncFlagValues', flagValuesInput.value);
                updateFlagDropdownOptions();
            };
            
            commentPlaceholderInput.onchange = () => {
                localStorage.setItem('excelSyncCommentPlaceholder', commentPlaceholderInput.value);
                updateCommentPlaceholders();
            };
            
            // Globaler Keyboard-Handler f√ºr Undo/Redo
            document.addEventListener('keydown', (e) => {
                // Strg+Z (Windows/Linux) oder Cmd+Z (Mac)
                if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    
                    // Pr√ºfe welches Modal aktiv ist
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (explorerOpen) {
                        if (undoExplorer()) {
                            showUndoRedoFeedback('R√ºckg√§ngig');
                        }
                    } else {
                        if (undoSearch()) {
                            showUndoRedoFeedback('R√ºckg√§ngig');
                        }
                    }
                }
                
                // Strg+Y oder Strg+Shift+Z (Redo)
                if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                    e.preventDefault();
                    
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (explorerOpen) {
                        if (redoExplorer()) {
                            showUndoRedoFeedback('Wiederherstellen');
                        }
                    } else {
                        if (redoSearch()) {
                            showUndoRedoFeedback('Wiederherstellen');
                        }
                    }
                }
                
                // Strg+F ‚Üí Fokus auf Suchfeld
                if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (explorerOpen) {
                        e.preventDefault();
                        elements.explorerSearch.focus();
                        elements.explorerSearch.select();
                    } else if (!document.querySelector('.modal-backdrop:not(.hidden)')) {
                        // Nur wenn kein Modal offen ist
                        e.preventDefault();
                        elements.searchInput.focus();
                        elements.searchInput.select();
                    }
                }
                
                // Strg+S ‚Üí Warteschlange exportieren
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (explorerOpen) {
                        // Im Explorer: Exportieren
                        if (explorerState.data.length > 0) {
                            exportExplorerData();
                        }
                    } else if (state.transferQueue.length > 0) {
                        // Warteschlange exportieren
                        transferQueueToExcel();
                    }
                }
                
                // Strg+Enter ‚Üí Direkt √ºbertragen
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (!explorerOpen && state.selectedRows.length > 0) {
                        transferSelectedDirect();
                    }
                }
                
                // F5 ‚Üí Suche wiederholen / Daten neu laden
                if (e.key === 'F5') {
                    e.preventDefault();
                    const explorerOpen = !elements.dataExplorerModal.classList.contains('hidden');
                    
                    if (explorerOpen && explorerState.selectedSheet) {
                        loadExplorerSheet(explorerState.selectedSheet);
                        showUndoRedoFeedback('Neu geladen');
                    } else if (elements.searchInput.value) {
                        search();
                        showUndoRedoFeedback('Suche aktualisiert');
                    }
                }
                
                // Escape ‚Üí Modal schlie√üen
                if (e.key === 'Escape') {
                    // Pr√ºfe welche Modals offen sind und schlie√üe das oberste
                    if (!elements.dataExplorerModal.classList.contains('hidden')) {
                        closeDataExplorer();
                    } else if (!document.getElementById('helpModal').classList.contains('hidden')) {
                        document.getElementById('helpModal').classList.add('hidden');
                        document.body.classList.remove('modal-open');
                    } else if (!document.getElementById('mappingModal').classList.contains('hidden')) {
                        closeMappingModal();
                    } else if (!document.getElementById('newMonthModal').classList.contains('hidden')) {
                        closeNewMonthModal();
                    } else if (!document.getElementById('licenseModal').classList.contains('hidden')) {
                        document.getElementById('licenseModal').classList.add('hidden');
                        document.body.classList.remove('modal-open');
                    } else if (!elements.newRowPanel.classList.contains('hidden')) {
                        closeNewRowPanel();
                    }
                }
            });
            
            try { await initDB(); } catch (e) { console.warn('IndexedDB nicht verf√ºgbar'); }
            loadConfig(); updateMappingPreview(); checkReadyState();
            
            // Auto-Save starten und Recovery pr√ºfen
            startAutoSave();
            setTimeout(() => checkAutoSaveRecovery(), 500); // Kurze Verz√∂gerung f√ºr UI-Initialisierung
            
            // Pr√ºfung beim Schlie√üen der App
            window.electronAPI.onBeforeClose(() => {
                // Bei normalem Schlie√üen: Recovery-Daten l√∂schen (nur bei Crash sollen sie bleiben)
                clearExplorerRecoveryData();
                
                if (state.transferQueue.length > 0) {
                    const msg = `Es befinden sich noch ${state.transferQueue.length} Eintr√§ge in der Warteschlange.\n\nWirklich schlie√üen? Ungespeicherte Daten gehen verloren!`;
                    if (confirm(msg)) {
                        window.electronAPI.confirmClose(true);
                    } else {
                        window.electronAPI.confirmClose(false);
                    }
                } else {
                    window.electronAPI.confirmClose(true);
                }
            });
            
            // Search Event Listeners - WICHTIG!
            elements.searchInput.addEventListener('keydown', (e) => {
                const dropdown = document.getElementById('searchHistoryDropdown');
                const isDropdownOpen = dropdown && dropdown.classList.contains('show');
                
                if (e.key === 'Enter') {
                    e.preventDefault();
                    hideSearchHistoryDropdown();
                    search();
                } else if (e.key === 'ArrowDown') {
                    if (!isDropdownOpen) {
                        showSearchHistoryDropdown();
                    }
                    navigateSearchHistory('down');
                    e.preventDefault();
                } else if (e.key === 'ArrowUp') {
                    navigateSearchHistory('up');
                    e.preventDefault();
                } else if (e.key === 'Escape') {
                    hideSearchHistoryDropdown();
                }
            });
            
            elements.searchInput.addEventListener('focus', () => {
                showSearchHistoryDropdown();
            });
            
            elements.searchInput.addEventListener('input', () => {
                renderSearchHistoryDropdown(elements.searchInput.value);
                const dropdown = document.getElementById('searchHistoryDropdown');
                const history = getSearchHistory();
                const filterText = elements.searchInput.value;
                const filtered = filterText 
                    ? history.filter(item => item.term.toLowerCase().includes(filterText.toLowerCase()))
                    : history;
                if (filtered.length > 0) {
                    dropdown.classList.add('show');
                }
            });
            
            // Dropdown schlie√üen bei Klick au√üerhalb
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-wrapper')) {
                    hideSearchHistoryDropdown();
                }
            });
            
            elements.btnSearch.onclick = search;
            
            elements.btnNewRow.onclick = openNewRowPanel;
            elements.btnCloseNewRow.onclick = closeNewRowPanel;
            elements.btnAddNewRowToQueue.onclick = addNewRowToQueue;
            elements.btnTransferNewRowDirect.onclick = transferNewRowDirect;
            document.getElementById('btnAddEmptyRow').onclick = addEmptyRowToQueue;
            elements.btnAddToQueue.onclick = addToQueue;
            elements.btnTransferDirect.onclick = transferSelectedDirect;
            elements.btnSelectAll.onclick = () => selectAllRows(true);
            elements.btnDeselectAll.onclick = () => selectAllRows(false);
            elements.btnClearQueue.onclick = clearQueue;
            elements.btnConfigMapping.onclick = openMappingModal;
            document.getElementById('btnCloseMappingModal').onclick = closeMappingModal;
            document.getElementById('btnCancelMapping').onclick = closeMappingModal;
            document.getElementById('btnSaveMapping').onclick = saveMapping;
            document.getElementById('btnAddMapping').onclick = addMappingColumn;
            
            // Data Explorer Event Listeners
            elements.btnDataExplorer.onclick = openDataExplorer;
            elements.btnCloseExplorerX.onclick = closeDataExplorer;
            elements.btnCloseExplorerFooter.onclick = closeDataExplorer;
            elements.btnExplorerFullscreen.onclick = toggleExplorerFullscreen;
            elements.btnExplorerOpenFile.onclick = loadExplorerFile;
            
            // Drag & Drop Event Listeners for Explorer
            setupExplorerDropZone();
            elements.explorerSheetSelect.onchange = (e) => loadExplorerSheet(e.target.value);
            
            // Debounced Explorer-Suche (300ms Verz√∂gerung)
            const debouncedExplorerSearch = debounce(() => {
                explorerState.searchTerm = elements.explorerSearch.value;
                filterExplorerData();
            }, 300);
            
            elements.explorerSearch.oninput = debouncedExplorerSearch;
            elements.explorerSearch.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    // Bei Enter sofort suchen (ohne Debounce)
                    explorerState.searchTerm = e.target.value;
                    filterExplorerData();
                }
            };
            elements.btnExplorerSearch.onclick = () => {
                explorerState.searchTerm = elements.explorerSearch.value;
                filterExplorerData();
            };
            elements.btnToggleColumns.onclick = toggleColumnPanel;
            elements.btnShowAllColumns.onclick = showAllExplorerColumns;
            elements.btnHideAllColumns.onclick = hideAllExplorerColumns;
            elements.btnAddExplorerFilter.onclick = addExplorerFilter;
            elements.btnClearExplorerFilters.onclick = clearExplorerFilters;
            elements.btnExplorerExport.onclick = exportExplorerData;
            
            // Data Join Event Listeners
            elements.btnDataJoin.onclick = openDataJoinModal;
            elements.btnCloseDataJoin.onclick = closeDataJoinModal;
            elements.btnCancelDataJoin.onclick = closeDataJoinModal;
            elements.btnJoinSelectFile.onclick = loadDataJoinSourceFile;
            elements.joinSourceSheet.onchange = (e) => loadDataJoinSourceSheet(e.target.value);
            elements.joinTargetKeyColumn.onchange = () => {
                dataJoinState.previewCalculated = false;
                elements.joinPreviewContainer.style.display = 'none';
                updateJoinButtons();
            };
            elements.joinSourceKeyColumn.onchange = () => {
                dataJoinState.previewCalculated = false;
                elements.joinPreviewContainer.style.display = 'none';
                updateJoinButtons();
            };
            elements.btnPreviewDataJoin.onclick = calculateDataJoinPreview;
            elements.btnExecuteDataJoin.onclick = executeDataJoin;
            
            // Data Join Drag & Drop Zone
            const joinDropZone = document.getElementById('joinDropZone');
            if (joinDropZone) {
                joinDropZone.addEventListener('click', loadDataJoinSourceFile);
                
                joinDropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    joinDropZone.style.borderColor = 'var(--primary)';
                    joinDropZone.style.background = 'rgba(0, 122, 204, 0.1)';
                });
                
                joinDropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    joinDropZone.style.borderColor = 'var(--border)';
                    joinDropZone.style.background = 'var(--bg-dark)';
                });
                
                joinDropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    joinDropZone.style.borderColor = 'var(--border)';
                    joinDropZone.style.background = 'var(--bg-dark)';
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const file = files[0];
                        const ext = file.name.split('.').pop().toLowerCase();
                        if (ext === 'xlsx' || ext === 'xls') {
                            // Dateipfad √ºber Electron API abrufen (contextIsolation-sicher)
                            const filePath = window.electronAPI.getPathForFile(file);
                            if (!filePath) {
                                showNotification('Dateipfad konnte nicht ermittelt werden', 'error');
                                return;
                            }
                            await loadDataJoinSourceFromPath(filePath);
                        } else {
                            showNotification('Bitte nur Excel-Dateien (.xlsx, .xls) ablegen', 'warning');
                        }
                    }
                });
            }
            
            // Sheet Management Event Listeners
            document.getElementById('btnSheetManage').onclick = openSheetManageModal;
            document.getElementById('btnCloseSheetManage').onclick = closeSheetManageModal;
            document.getElementById('btnSheetManageClose').onclick = closeSheetManageModal;
            document.getElementById('btnSheetAdd').onclick = addNewSheet;
            document.getElementById('btnSheetRename').onclick = renameSelectedSheet;
            document.getElementById('btnSheetClone').onclick = cloneSelectedSheet;
            document.getElementById('btnSheetMoveUp').onclick = () => moveSelectedSheet('up');
            document.getElementById('btnSheetMoveDown').onclick = () => moveSelectedSheet('down');
            document.getElementById('btnSheetDelete').onclick = deleteSelectedSheet;
            
            // Explorer-Vorschau Event Listeners
            elements.btnExplorerPreview.onclick = showExplorerPreview;
            document.getElementById('btnClosePreviewX').onclick = closeExplorerPreview;
            document.getElementById('btnClosePreview').onclick = closeExplorerPreview;
            
            // Row Move Toolbar Event Listeners
            document.getElementById('btnExecuteMove').onclick = executeRowMove;
            document.getElementById('btnHideSelectedRows').onclick = hideSelectedRows;
            document.getElementById('btnDeleteSelectedRows').onclick = deleteSelectedRows;
            document.getElementById('btnClearRowSelection').onclick = clearRowSelection;
            
            // Pagination Event Listeners (Data Explorer)
            elements.btnExplorerFirstPage.onclick = () => explorerGoToPage(1);
            elements.btnExplorerPrevPage.onclick = () => explorerGoToPage(explorerState.currentPage - 1);
            elements.btnExplorerNextPage.onclick = () => explorerGoToPage(explorerState.currentPage + 1);
            elements.btnExplorerLastPage.onclick = () => explorerGoToPage(Math.ceil(explorerState.filteredData.length / explorerState.pageSize));
            elements.explorerPageSize.onchange = (e) => explorerChangePageSize(e.target.value);
            
            // Pagination Event Listeners (Suchergebnisse)
            document.getElementById('btnSearchFirstPage').onclick = () => searchGoToPage(1);
            document.getElementById('btnSearchPrevPage').onclick = () => searchGoToPage(state.searchPagination.currentPage - 1);
            document.getElementById('btnSearchNextPage').onclick = () => searchGoToPage(state.searchPagination.currentPage + 1);
            document.getElementById('btnSearchLastPage').onclick = () => searchGoToPage(Math.ceil(state.searchResults.length / state.searchPagination.pageSize));
            document.getElementById('searchPageSize').onchange = (e) => searchChangePageSize(e.target.value);
            
            // New Month Modal Event Listeners
            elements.btnNewMonth.onclick = openNewMonthModal;
            document.getElementById('btnCloseNewMonthModal').onclick = closeNewMonthModal;
            document.getElementById('btnCancelNewMonth').onclick = closeNewMonthModal;
            document.getElementById('btnConfirmNewMonth').onclick = confirmNewMonth;
            
            // Create Template Modal Event Listeners
            document.getElementById('btnCloseCreateTemplateModal').onclick = closeCreateTemplateModal;
            document.getElementById('btnCancelCreateTemplate').onclick = closeCreateTemplateModal;
            document.getElementById('btnConfirmCreateTemplate').onclick = confirmCreateTemplate;
            document.getElementById('btnSelectAllSheets').onclick = () => {
                document.querySelectorAll('.template-sheet-checkbox').forEach(cb => cb.checked = true);
            };
            document.getElementById('btnDeselectAllSheets').onclick = () => {
                document.querySelectorAll('.template-sheet-checkbox').forEach(cb => cb.checked = false);
            };
            
            // Help Modal Event Listeners
            elements.btnHelp.onclick = () => elements.helpModal.classList.remove('hidden');
            document.getElementById('btnCloseHelpModal').onclick = () => elements.helpModal.classList.add('hidden');
            document.getElementById('btnCloseHelp').onclick = () => elements.helpModal.classList.add('hidden');
            
            // License Modal Event Listeners
            document.getElementById('btnLicense').onclick = () => document.getElementById('licenseModal').classList.remove('hidden');
            document.getElementById('btnCloseLicenseModal').onclick = () => document.getElementById('licenseModal').classList.add('hidden');
            document.getElementById('btnCloseLicense').onclick = () => document.getElementById('licenseModal').classList.add('hidden');
            
            // Security Logs Modal Event Listeners
            document.getElementById('btnSecurityLogs').onclick = openSecurityLogsModal;
            document.getElementById('btnCloseSecurityLogsModal').onclick = closeLogsModal;
            document.getElementById('btnCloseSecurityLogs').onclick = closeLogsModal;
            document.getElementById('btnRefreshLogs').onclick = loadSecurityLogs;
            document.getElementById('btnVerifyLogs').onclick = verifySecurityLogs;
            document.getElementById('btnClearLogs').onclick = clearSecurityLogs;
            document.getElementById('logsLevelFilter').onchange = filterSecurityLogs;
            document.getElementById('logsSearchFilter').oninput = filterSecurityLogs;
            
            // Tab-Switching f√ºr Logs
            document.getElementById('tabLocalLogs').onclick = () => switchLogsTab('local');
            document.getElementById('tabNetworkLogs').onclick = () => switchLogsTab('network');
            
            // Network Logs Event Listeners (innerhalb des Security Modals)
            document.getElementById('btnRefreshNetworkLogs').onclick = loadNetworkLogs;
            document.getElementById('networkLogsHostFilter').onchange = filterNetworkLogs;
            document.getElementById('networkLogsSearchFilter').oninput = filterNetworkLogs;
            
            // Sidebar Toggle
            document.getElementById('sidebarToggle').onclick = () => {
                document.getElementById('sidebar').classList.toggle('collapsed');
            };
            
            // Keyboard shortcuts
            document.onkeydown = (e) => {
                if (e.key === 'F1') {
                    e.preventDefault();
                    elements.helpModal.classList.toggle('hidden');
                }
                if (e.key === 'Escape') {
                    elements.helpModal.classList.add('hidden');
                    elements.mappingModal.classList.add('hidden');
                    elements.newMonthModal.classList.add('hidden');
                    elements.createTemplateModal.classList.add('hidden');
                    document.getElementById('licenseModal').classList.add('hidden');
                    closeLogsModal();
                    closeDataExplorer();
                }
            };
            
            // Electron-Modus: Verwende Electron-API f√ºr Dateioperationen
            elements.btnLoadFile1.onclick = loadFile1Electron;
            elements.btnLoadFile2.onclick = loadFile2Electron;
            elements.btnLoadTemplate.onclick = loadTemplateElectron;
            elements.btnCreateTemplate.onclick = createTemplateFromSourceElectron;
            elements.selectSheet1.onchange = (e) => loadSheet1Electron(e.target.value);
            elements.selectSheet2.onchange = (e) => loadSheet2Electron(e.target.value);
            elements.btnImportConfig.onclick = loadConfigFromAppDirOrDialog;
            elements.btnExportConfig.onclick = exportConfig;
            elements.btnExportPS.onclick = showDiffPreview;  // Zeigt zuerst Vorschau, dann Export via Modal
            elements.btnPreviewTransfer.onclick = showDiffPreview;
            
            // Arbeitsordner Event Handler
            elements.btnSelectWorkingDir.onclick = selectWorkingDirectory;
            elements.btnClearWorkingDir.onclick = clearWorkingDirectory;
            
            // Arbeitsordner aus localStorage laden
            loadWorkingDirectoryFromStorage();
            
            // Diff-Vorschau Modal Event Handler
            document.getElementById('btnCloseDiffModal').onclick = closeDiffPreview;
            document.getElementById('btnCancelDiff').onclick = closeDiffPreview;
            document.getElementById('btnConfirmTransfer').onclick = confirmTransferFromDiff;
            
            // Automatisch config.json aus Programmordner oder Arbeitsordner laden beim Start
            console.log('[Config] Suche automatisch nach config.json...');
            console.log('[Config] Arbeitsordner:', state.workingDirectory || '(nicht gesetzt)');
            try {
                const autoResult = await window.electronAPI.loadConfigFromAppDir(state.workingDirectory);
                console.log('[Config] loadConfigFromAppDir Ergebnis:', autoResult);
                
                if (autoResult.success && autoResult.config) {
                    await applyLoadedConfig(autoResult.config);
                    console.log('[Config] config.json automatisch geladen:', autoResult.path);
                    console.log('[Config] Computername:', autoResult.computerName || '(unbekannt)');
                    console.log('[Config] Hat Computer-Abschnitt:', autoResult.hasComputerSection);
                    console.log('[Config] Legacy-Format:', autoResult.isLegacyFormat);
                    
                    // Zeige Computer-spezifische Info
                    let statusMsg = `‚úì config.json geladen: ${autoResult.path}`;
                    if (autoResult.computerName && !autoResult.isLegacyFormat) {
                        statusMsg = autoResult.hasComputerSection 
                            ? `‚úì Config f√ºr "${autoResult.computerName}" geladen`
                            : `‚úì Config geladen (Standard, kein Abschnitt f√ºr "${autoResult.computerName}")`;
                    }
                    showStatus(elements.transferStatus, statusMsg, 'success');
                } else {
                    console.log('[Config] Keine config.json gefunden.');
                    if (autoResult.searchedPaths) {
                        console.log('[Config] Gesuchte Pfade:', autoResult.searchedPaths);
                    }
                }
            } catch (e) {
                console.error('[Config] Fehler beim automatischen Laden:', e);
            }
        }
        
        // ==================== SECURITY LOGS FUNCTIONS ====================
        
        let securityLogsCache = [];
        let currentLogsTab = 'local'; // 'local' oder 'network'
        
        async function openSecurityLogsModal() {
            document.getElementById('securityLogsModal').classList.remove('hidden');
            // Reset auf lokale Logs
            switchLogsTab('local');
        }
        
        function closeLogsModal() {
            document.getElementById('securityLogsModal').classList.add('hidden');
        }
        
        async function switchLogsTab(tab) {
            currentLogsTab = tab;
            const tabLocal = document.getElementById('tabLocalLogs');
            const tabNetwork = document.getElementById('tabNetworkLogs');
            const sectionLocal = document.getElementById('localLogsSection');
            const sectionNetwork = document.getElementById('networkLogsSection');
            const clearBtn = document.getElementById('btnClearLogs');
            
            if (tab === 'local') {
                // Lokale Logs Tab aktiv
                tabLocal.style.background = 'var(--primary)';
                tabLocal.style.color = 'white';
                tabLocal.style.borderColor = 'var(--primary)';
                tabNetwork.style.background = 'var(--bg-light)';
                tabNetwork.style.color = 'var(--text)';
                tabNetwork.style.borderColor = 'var(--border)';
                
                sectionLocal.classList.remove('hidden');
                sectionNetwork.classList.add('hidden');
                clearBtn.style.display = 'block';
                
                await loadSecurityLogs();
                await verifySecurityLogs();
            } else {
                // Netzwerk Logs Tab aktiv
                tabNetwork.style.background = 'var(--primary)';
                tabNetwork.style.color = 'white';
                tabNetwork.style.borderColor = 'var(--primary)';
                tabLocal.style.background = 'var(--bg-light)';
                tabLocal.style.color = 'var(--text)';
                tabLocal.style.borderColor = 'var(--border)';
                
                sectionNetwork.classList.remove('hidden');
                sectionLocal.classList.add('hidden');
                clearBtn.style.display = 'none'; // Netzwerk-Logs nicht l√∂schbar
                
                await loadNetworkLogs();
            }
        }
        
        async function loadSecurityLogs() {
            try {
                const result = await window.electronAPI.getSecurityLogs({ fromFile: true, limit: 500 });
                
                if (result.success) {
                    securityLogsCache = result.entries;
                    document.getElementById('logsCount').textContent = result.totalCount;
                    document.getElementById('logsPath').textContent = result.logFilePath || '-';
                    renderSecurityLogs(result.entries);
                } else {
                    document.getElementById('securityLogsTableBody').innerHTML = 
                        `<tr><td colspan="5" style="padding: 20px; text-align: center; color: var(--error);">Fehler: ${result.error}</td></tr>`;
                }
            } catch (e) {
                console.error('Fehler beim Laden der Security-Logs:', e);
            }
        }
        
        function renderSecurityLogs(entries) {
            const tbody = document.getElementById('securityLogsTableBody');
            
            if (!entries || entries.length === 0) {
                tbody.innerHTML = `<tr><td colspan="5" style="padding: 20px; text-align: center; color: var(--text-muted);">Keine Log-Eintr√§ge vorhanden</td></tr>`;
                return;
            }
            
            const levelColors = {
                'INFO': { bg: 'rgba(33, 150, 243, 0.2)', text: '#2196F3', icon: '‚ÑπÔ∏è' },
                'WARN': { bg: 'rgba(255, 152, 0, 0.2)', text: '#FF9800', icon: '‚ö†Ô∏è' },
                'ERROR': { bg: 'rgba(244, 67, 54, 0.2)', text: '#F44336', icon: '‚ùå' },
                'SECURITY': { bg: 'rgba(156, 39, 176, 0.2)', text: '#9C27B0', icon: 'üõ°Ô∏è' }
            };
            
            tbody.innerHTML = entries.map(entry => {
                const level = levelColors[entry.level] || levelColors['INFO'];
                const timestamp = new Date(entry.timestamp).toLocaleString('de-DE');
                const details = entry.details ? Object.entries(entry.details)
                    .filter(([k, v]) => k !== 'pid')
                    .map(([k, v]) => `<span style="color: var(--text-muted);">${k}:</span> ${typeof v === 'object' ? JSON.stringify(v) : v}`)
                    .join(', ') : '-';
                
                // Signature-Check Icon
                const sigValid = entry.signature ? '‚úì' : '?';
                const sigColor = entry.signature ? 'var(--success)' : 'var(--text-muted)';
                
                return `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 8px; white-space: nowrap; font-family: monospace; font-size: 11px;">${timestamp}</td>
                        <td style="padding: 8px; text-align: center;">
                            <span style="background: ${level.bg}; color: ${level.text}; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: bold;">
                                ${level.icon} ${entry.level}
                            </span>
                        </td>
                        <td style="padding: 8px; font-weight: 500;">${entry.action}</td>
                        <td style="padding: 8px; font-size: 11px; max-width: 350px; overflow: hidden; text-overflow: ellipsis;" title="${details}">${details}</td>
                        <td style="padding: 8px; text-align: center; color: ${sigColor}; font-weight: bold;">${sigValid}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function filterSecurityLogs() {
            const levelFilter = document.getElementById('logsLevelFilter').value;
            const searchFilter = document.getElementById('logsSearchFilter').value.toLowerCase();
            
            let filtered = securityLogsCache;
            
            if (levelFilter) {
                filtered = filtered.filter(e => e.level === levelFilter);
            }
            
            if (searchFilter) {
                filtered = filtered.filter(e => 
                    e.action.toLowerCase().includes(searchFilter) ||
                    JSON.stringify(e.details).toLowerCase().includes(searchFilter)
                );
            }
            
            renderSecurityLogs(filtered);
        }
        
        async function verifySecurityLogs() {
            const statusEl = document.getElementById('securityLogsStatus');
            const integrityBox = document.getElementById('securityLogsIntegrity');
            const errorsBox = document.getElementById('securityLogsErrors');
            const errorsList = document.getElementById('securityLogsErrorList');
            
            statusEl.textContent = 'Wird gepr√ºft...';
            
            try {
                const result = await window.electronAPI.verifySecurityLogs();
                
                if (result.success) {
                    if (result.valid) {
                        statusEl.innerHTML = `<span style="color: var(--success); font-weight: bold;">‚úì Alle ${result.verifiedEntries} Eintr√§ge verifiziert</span>`;
                        integrityBox.style.borderLeftColor = 'var(--success)';
                        errorsBox.classList.add('hidden');
                    } else {
                        statusEl.innerHTML = `<span style="color: var(--error); font-weight: bold;">‚ö†Ô∏è ${result.errors.length} Integrit√§tsfehler</span>`;
                        integrityBox.style.borderLeftColor = 'var(--error)';
                        errorsBox.classList.remove('hidden');
                        errorsList.innerHTML = result.errors.map(err => `<li>${err}</li>`).join('');
                    }
                } else {
                    statusEl.innerHTML = `<span style="color: var(--error);">Fehler: ${result.error}</span>`;
                }
            } catch (e) {
                statusEl.innerHTML = `<span style="color: var(--error);">Fehler bei Verifikation</span>`;
                console.error('Verifikationsfehler:', e);
            }
        }
        
        async function clearSecurityLogs() {
            if (!confirm('Alle Security-Logs wirklich l√∂schen?\n\nDies kann nicht r√ºckg√§ngig gemacht werden.')) {
                return;
            }
            
            try {
                const result = await window.electronAPI.clearSecurityLogs();
                
                if (result.success) {
                    await loadSecurityLogs();
                    await verifySecurityLogs();
                } else {
                    alert('Fehler beim L√∂schen: ' + result.error);
                }
            } catch (e) {
                console.error('Fehler beim L√∂schen der Logs:', e);
            }
        }
        
        // ==================== NETWORK LOGS FUNCTIONS ====================
        
        let networkLogsCache = [];
        let currentNetworkPath = null;
        
        /**
         * Pr√ºft ob eine Datei k√ºrzlich von einem anderen Rechner bearbeitet wurde
         * und zeigt ggf. eine Warnung an.
         * @param {string} filePath - Pfad zur Datei
         * @returns {{proceed: boolean}} - true wenn fortgefahren werden soll
         */
        async function checkAndWarnNetworkConflict(filePath) {
            try {
                const result = await window.electronAPI.checkNetworkConflict(filePath, 5);
                
                if (!result.success || !result.isNetworkPath) {
                    // Kein Netzlaufwerk oder Fehler - einfach fortfahren
                    return { proceed: true };
                }
                
                if (!result.conflict) {
                    // Kein Konflikt
                    return { proceed: true };
                }
                
                // Warnung zusammenstellen
                let message = '‚ö†Ô∏è Achtung: M√∂glicher Bearbeitungskonflikt!\n\n';
                
                if (result.activeLock) {
                    message += `Diese Datei ist m√∂glicherweise bereits ge√∂ffnet:\n`;
                    message += `‚Ä¢ Rechner: ${result.activeLock.hostname}\n`;
                    message += `‚Ä¢ Seit: ${result.activeLock.ageMinutes} Minute(n)\n\n`;
                }
                
                if (result.recentActivity) {
                    message += `Diese Datei wurde k√ºrzlich bearbeitet:\n`;
                    message += `‚Ä¢ Rechner: ${result.recentActivity.hostname}\n`;
                    message += `‚Ä¢ Aktion: ${result.recentActivity.action}\n`;
                    message += `‚Ä¢ Vor: ${result.recentActivity.ageMinutes} Minute(n)\n\n`;
                }
                
                message += 'Wenn Sie die Datei gleichzeitig bearbeiten, k√∂nnen √Ñnderungen verloren gehen.\n\n';
                message += 'Trotzdem √∂ffnen?';
                
                const proceed = confirm(message);
                
                return { proceed };
            } catch (e) {
                console.error('Fehler bei Konfliktpr√ºfung:', e);
                // Bei Fehler trotzdem fortfahren
                return { proceed: true };
            }
        }
        
        /**
         * Session-Locks beim Schlie√üen der App entfernen
         */
        async function cleanupSessionLocks() {
            try {
                if (state.file1?.filePath) {
                    await window.electronAPI.removeSessionLock(state.file1.filePath);
                }
                if (state.file2?.filePath) {
                    await window.electronAPI.removeSessionLock(state.file2.filePath);
                }
            } catch (e) {
                console.error('Fehler beim Entfernen der Session-Locks:', e);
            }
        }
        
        // Session-Locks beim Verlassen der Seite aufr√§umen
        window.addEventListener('beforeunload', () => {
            cleanupSessionLocks();
            // Markiere sauberen Shutdown - AutoSave wird gel√∂scht
            markCleanShutdown();
        });
        
        async function loadNetworkLogs() {
            const tbody = document.getElementById('networkLogsTableBody');
            const countEl = document.getElementById('networkLogsCount');
            const pathEl = document.getElementById('networkLogsPath');
            const hostnameEl = document.getElementById('networkHostname');
            const hostFilterEl = document.getElementById('networkLogsHostFilter');
            
            // Ermittle den aktuellen Dateipfad (von file1 oder file2)
            const filePath = state.file1?.filePath || state.file2?.filePath;
            
            if (!filePath) {
                tbody.innerHTML = `<tr><td colspan="5" style="padding: 20px; text-align: center; color: var(--text-muted);">Bitte zuerst eine Datei laden</td></tr>`;
                countEl.textContent = '0';
                pathEl.textContent = '-';
                return;
            }
            
            try {
                // Hostname abrufen
                const networkInfo = await window.electronAPI.isNetworkPath(filePath);
                hostnameEl.textContent = networkInfo.hostname || '-';
                
                if (!networkInfo.isNetwork) {
                    tbody.innerHTML = `<tr><td colspan="5" style="padding: 20px; text-align: center; color: var(--text-muted);">Die aktuelle Datei liegt nicht auf einem Netzlaufwerk.<br>Netzwerk-Logs werden nur f√ºr Dateien auf Netzlaufwerken gef√ºhrt.</td></tr>`;
                    countEl.textContent = '0';
                    pathEl.textContent = 'Kein Netzlaufwerk';
                    return;
                }
                
                // Netzwerk-Logs laden
                const result = await window.electronAPI.getNetworkLogs(filePath);
                
                if (result.success) {
                    networkLogsCache = result.entries;
                    currentNetworkPath = result.logFilePath;
                    countEl.textContent = result.totalCount;
                    pathEl.textContent = result.logFilePath || '-';
                    
                    // Host-Filter bef√ºllen
                    const hosts = [...new Set(result.entries.map(e => e.hostname))];
                    hostFilterEl.innerHTML = '<option value="">Alle Rechner</option>' + 
                        hosts.map(h => `<option value="${h}">${h}</option>`).join('');
                    
                    renderNetworkLogs(result.entries);
                } else {
                    tbody.innerHTML = `<tr><td colspan="5" style="padding: 20px; text-align: center; color: var(--error);">Fehler: ${result.error}</td></tr>`;
                }
            } catch (e) {
                console.error('Fehler beim Laden der Netzwerk-Logs:', e);
                tbody.innerHTML = `<tr><td colspan="5" style="padding: 20px; text-align: center; color: var(--error);">Fehler beim Laden</td></tr>`;
            }
        }
        
        function renderNetworkLogs(entries) {
            const tbody = document.getElementById('networkLogsTableBody');
            
            if (!entries || entries.length === 0) {
                tbody.innerHTML = `<tr><td colspan="5" style="padding: 20px; text-align: center; color: var(--text-muted);">Keine Netzwerk-Log-Eintr√§ge vorhanden</td></tr>`;
                return;
            }
            
            const actionColors = {
                'EXCEL_FILE_SAVED': { bg: 'rgba(76, 175, 80, 0.2)', text: '#4CAF50', icon: 'üíæ' },
                'EXCEL_EXPORT_SOURCE': { bg: 'rgba(33, 150, 243, 0.2)', text: '#2196F3', icon: 'üì§' },
                'EXCEL_EXPORT_TARGET': { bg: 'rgba(33, 150, 243, 0.2)', text: '#2196F3', icon: 'üì•' },
                'DATA_TRANSFER': { bg: 'rgba(156, 39, 176, 0.2)', text: '#9C27B0', icon: 'üîÄ' },
                'DATA_TRANSFER_SOURCE': { bg: 'rgba(255, 152, 0, 0.2)', text: '#FF9800', icon: 'üì§' }
            };
            
            tbody.innerHTML = entries.map(entry => {
                const actionStyle = actionColors[entry.action] || { bg: 'rgba(158, 158, 158, 0.2)', text: '#9E9E9E', icon: 'üìã' };
                const timestamp = new Date(entry.timestamp).toLocaleString('de-DE');
                const details = entry.details ? Object.entries(entry.details)
                    .filter(([k, v]) => v !== null && v !== undefined)
                    .map(([k, v]) => `<span style="color: var(--text-muted);">${k}:</span> ${v}`)
                    .join(', ') : '-';
                
                return `
                    <tr style="border-bottom: 1px solid var(--border);">
                        <td style="padding: 8px; white-space: nowrap; font-family: monospace; font-size: 11px;">${timestamp}</td>
                        <td style="padding: 8px; font-family: monospace; font-size: 11px;">${entry.hostname}</td>
                        <td style="padding: 8px;">
                            <span style="background: ${actionStyle.bg}; color: ${actionStyle.text}; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: bold;">
                                ${actionStyle.icon} ${entry.action}
                            </span>
                        </td>
                        <td style="padding: 8px; font-weight: 500;">${entry.file || '-'}</td>
                        <td style="padding: 8px; font-size: 11px; max-width: 300px; overflow: hidden; text-overflow: ellipsis;" title="${details}">${details}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function filterNetworkLogs() {
            const hostFilter = document.getElementById('networkLogsHostFilter').value;
            const searchFilter = document.getElementById('networkLogsSearchFilter').value.toLowerCase();
            
            let filtered = networkLogsCache;
            
            if (hostFilter) {
                filtered = filtered.filter(e => e.hostname === hostFilter);
            }
            
            if (searchFilter) {
                filtered = filtered.filter(e => 
                    e.action.toLowerCase().includes(searchFilter) ||
                    (e.file && e.file.toLowerCase().includes(searchFilter)) ||
                    JSON.stringify(e.details).toLowerCase().includes(searchFilter)
                );
            }
            
            renderNetworkLogs(filtered);
        }

        initApp();
    </script>
</body>
</html>
